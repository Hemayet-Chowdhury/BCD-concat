
###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_8 gsva_release_2_9

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_8 gsva_release_2_9",
    "desc_release_old": "1.0.1",
    "desc_release_new": "1.2.4",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_9 gsva_release_2_11

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_9 gsva_release_2_11",
    "desc_release_old": "1.2.4",
    "desc_release_new": "1.6.6",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_11 gsva_release_2_12

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_11 gsva_release_2_12",
    "desc_release_old": "1.6.6",
    "desc_release_new": "1.8.0",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_12 gsva_release_2_13

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_12 gsva_release_2_13",
    "desc_release_old": "1.8.0",
    "desc_release_new": "1.10.3",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_13 gsva_release_2_14

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_13 gsva_release_2_14",
    "desc_release_old": "1.10.3",
    "desc_release_new": "1.12.0",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_2_14 gsva_release_3_1

{
    "package": "GSVA",
    "release_versions": "gsva_release_2_14 gsva_release_3_1",
    "desc_release_old": "1.12.0",
    "desc_release_new": "1.16.0",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_1 gsva_release_3_2

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_1 gsva_release_3_2",
    "desc_release_old": "1.16.0",
    "desc_release_new": "1.18.0",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_2 gsva_release_3_3

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_2 gsva_release_3_3",
    "desc_release_old": "1.18.0",
    "desc_release_new": "1.20.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_3 gsva_release_3_4

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_3 gsva_release_3_4",
    "desc_release_old": "1.20.0",
    "desc_release_new": "1.22.4",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_4 gsva_release_3_5

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_4 gsva_release_3_5",
    "desc_release_old": "1.22.4",
    "desc_release_new": "1.24.2",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_5 gsva_release_3_6

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_5 gsva_release_3_6",
    "desc_release_old": "1.24.2",
    "desc_release_new": "1.26.0",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 4
}

##########
Functions Removed
##########



##########
Functions Added
##########

igsva


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   return (   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign ) ) } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  if (  return.old.value ) ## to be removed in the next release   rval -   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign )  rval } ",
    "filename": "gsva.txt"
  }
}

1.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (   Biobase :: annotation (  expr ) ) ) ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   return (   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign ) ) } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (   Biobase :: annotation (  expr ) ) ) ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  if (  return.old.value ) ## to be removed in the next release   rval -   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign )  rval } ",
    "filename": "gsva.txt"
  }
}

2.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ) } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (    method ==  \"gsva\" undefined  !  return.old.value ) ## to be removed in the next release   rval -   rval $ es.obs  rval } ",
    "filename": "gsva.txt"
  }
}

3.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ) } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (    method ==  \"gsva\" undefined  !  return.old.value ) ## to be removed in the next release   rval -   rval $ es.obs  rval } ",
    "filename": "gsva.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_6 gsva_release_3_7

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_6 gsva_release_3_7",
    "desc_release_old": "1.26.0",
    "desc_release_new": "1.28.0",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 4
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  if (  return.old.value ) ## to be removed in the next release   rval -   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign )  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )   eScoEset -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  rval } ",
    "filename": "gsva.txt"
  }
}

1.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (   Biobase :: annotation (  expr ) ) ) ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (   method !=  \"gsva\" )   eSco -   list ( es.obs =  eSco , bootstrap =  NULL , p.vals.sign =  NULL )   eScoEset -   new (  \"ExpressionSet\" , exprs =   eSco $ es.obs , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  if (  return.old.value ) ## to be removed in the next release   rval -   list ( es.obs =  eScoEset , bootstrap =   eSco $ bootstrap , p.vals.sign =   eSco $ p.vals.sign )  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (   Biobase :: annotation (  expr ) ) ) ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )   eScoEset -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  rval } ",
    "filename": "gsva.txt"
  }
}

2.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (    method ==  \"gsva\" undefined  !  return.old.value ) ## to be removed in the next release   rval -   rval $ es.obs  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  rval } ",
    "filename": "gsva.txt"
  }
}

3.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , rnaseq = FALSE , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , no.bootstraps = 0 , bootstrap.percent = .632 , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , kernel = TRUE , ssgsea.norm = TRUE , verbose = TRUE , return.old.value = FALSE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )  if (  !   missing (  rnaseq ) )   warning (  \"The argument 'rnaseq' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (  !   missing (  kernel ) )   warning (  \"The argument 'kernel' is deprecated and will be removed in the next release of GSVA. Please use the 'kcdf' argument instead.\" )  if (   no.bootstraps undefined  0 )   warning (  \"The argument 'no.bootstraps' is deprecated and will be removed in the next release of GSVA. This implies that the 'gsva()' function with the default argument 'method=\\\"gsva\\\"' only returns a matrix of GSVA enrichment scores. To obtain the same output in the form of a list as in previous versions you can set 'return.old.value=TRUE' during this release but this argument will not be available anymore in the next release.\" ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \"genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  no.bootstraps ,  bootstrap.percent ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  if (    method ==  \"gsva\" undefined  !  return.old.value ) ## to be removed in the next release   rval -   rval $ es.obs  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  rval } ",
    "filename": "gsva.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_7 gsva_release_3_8

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_7 gsva_release_3_8",
    "desc_release_old": "1.28.0",
    "desc_release_new": "1.30.0",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_8 gsva_release_3_9

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_8 gsva_release_3_9",
    "desc_release_old": "1.30.0",
    "desc_release_new": "1.32.0",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_9 gsva_release_3_11

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_9 gsva_release_3_11",
    "desc_release_old": "1.32.0",
    "desc_release_new": "1.36.3",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 4
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )   eScoEset -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 1L , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE , BPPARAM = SerialParam ( progressbar = verbose ) )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )   eset -  expr   expr -   exprs (  eset ) ## filter genes according to verious criteria, ## e.g., constant expression   expr -   .filterFeatures (  expr ,  method )  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" ) ## map to the actual features for which expression data is available   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   fastmatch :: fmatch (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ,  BPPARAM )   rval -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  eset ) , experimentData =   experimentData (  eset ) , annotation =  \"\" )  rval } ",
    "filename": "gsva.txt"
  }
}

1.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   Biobase :: esApply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (   Biobase :: annotation (  expr ) ) ) ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   featureNames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (   exprs (  expr ) ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )   eScoEset -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  expr ) , experimentData =   experimentData (  expr ) , annotation =  \"\" )   rval -  eScoEset  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  ExpressionSet , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 1L , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE , BPPARAM = SerialParam ( progressbar = verbose ) )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf )   eset -  expr   expr -   exprs (  eset ) ## filter genes according to verious criteria, ## e.g., constant expression   expr -   .filterFeatures (  expr ,  method )  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input ExpressionSet object\\n\" )   annotpkg -   Biobase :: annotation (  eset )  if (     length (  annotpkg ) undefined  0 undefined   annotpkg !=  \"\" )  {  if (  !   annotpkg %in%   installed.packages ( ) )   stop (   sprintf (  \"Please install the nnotation package %s\" ,  annotpkg ) )  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" ) ## map gene identifiers of the gene sets to the features in the chip ## Biobase::annotation() is necessary to disambiguate from the ## 'annotation' argument   mapped.gset.idx.list -   mapIdentifiers (  gset.idx.list ,   AnnoOrEntrezIdentifier (  annotpkg ) )   mapped.gset.idx.list -   geneIds (  mapped.gset.idx.list ) } else  {   mapped.gset.idx.list -  gset.idx.list  if (  verbose )  {   cat (  \"No annotation package name available in the input 'ExpressionSet' object 'expr'.\" ,  \"Attempting to directly match identifiers in 'expr' to gene sets.\" , sep =  \"\\n\" ) } } ## map to the actual features for which expression data is available   tmp -   lapply (  mapped.gset.idx.list ,  function ( x , y )   na.omit (   fastmatch :: fmatch (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   eSco -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ,  BPPARAM )   rval -   new (  \"ExpressionSet\" , exprs =  eSco , phenoData =   phenoData (  eset ) , experimentData =   experimentData (  eset ) , annotation =  \"\" )  rval } ",
    "filename": "gsva.txt"
  }
}

2.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   GSEABase :: mapIdentifiers (  gset.idx.list ,   GSEABase :: AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  GeneSetCollection )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 1L , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE , BPPARAM = SerialParam ( progressbar = verbose ) )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter genes according to verious criteria, ## e.g., constant expression   expr -   .filterFeatures (  expr ,  method )  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" ) ## map gene identifiers of the gene sets to the features in the matrix   mapped.gset.idx.list -  gset.idx.list  if (  !   missing (  annotation ) )  {  if (  verbose )   cat (  \"Mapping identifiers between gene sets and feature names\\n\" )   mapped.gset.idx.list -   mapIdentifiers (  gset.idx.list ,   AnnoOrEntrezIdentifier (  annotation ) ) } ## map to the actual features for which expression data is available   tmp -   lapply (   geneIds (  mapped.gset.idx.list ) ,  function ( x , y )   na.omit (   fastmatch :: fmatch (  x ,  y ) ) ,   rownames (  expr ) )    names (  tmp ) -   names (  mapped.gset.idx.list )  if (    length (   unlist (  tmp , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  tmp , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ,  BPPARAM )  rval } ",
    "filename": "gsva.txt"
  }
}

3.
{
  "old_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 0 , parallel.type = \"SOCK\" , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter out genes with constant expression values   sdGenes -   apply (  expr ,  1 ,  sd )  if (    any (   sdGenes ==  0 ) ||   any (   is.na (  sdGenes ) ) )  {   warning (   sum (    sdGenes ==  0 |   is.na (  sdGenes ) ) ,  \" genes with constant expression values throuhgout the samples.\" )  if (   method !=  \"ssgsea\" )  {   warning (  \"Since argument method!=\\\"ssgsea\\\", genes with constant expression values are discarded.\" )   expr -   expr [    sdGenes undefined  0 undefined  !   is.na (  sdGenes ) , , drop =  FALSE ] } }  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   match (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  parallel.type ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose )  rval } ",
    "filename": "gsva.txt"
  },
  "new_function": {
    "name": "gsva",
    "representation": "gsva",
    "signature": "signature ( expr =  matrix , gset.idx.list =  list )",
    "parameters": "function ( expr , gset.idx.list , annotation , method = c ( \"gsva\" , \"ssgsea\" , \"zscore\" , \"plage\" ) , kcdf = c ( \"Gaussian\" , \"Poisson\" , \"none\" ) , abs.ranking = FALSE , min.sz = 1 , max.sz = Inf , parallel.sz = 1L , mx.diff = TRUE , tau = switch ( method , gsva = 1 , ssgsea = 0.25 , NA ) , ssgsea.norm = TRUE , verbose = TRUE , BPPARAM = SerialParam ( progressbar = verbose ) )",
    "body": "{   method -   match.arg (  method )   kcdf -   match.arg (  kcdf ) ## filter genes according to verious criteria, ## e.g., constant expression   expr -   .filterFeatures (  expr ,  method )  if (    nrow (  expr ) undefined  2 )   stop (  \"Less than two genes in the input expression data matrix\\n\" )   mapped.gset.idx.list -   lapply (  gset.idx.list ,  function ( x , y )   na.omit (   fastmatch :: fmatch (  x ,  y ) ) ,   rownames (  expr ) )  if (    length (   unlist (  mapped.gset.idx.list , use.names =  FALSE ) ) ==  0 )   stop (  \"No identifiers in the gene sets could be matched to the identifiers in the expression data.\" ) ## remove gene sets from the analysis for which no features are available ## and meet the minimum and maximum gene-set size specified by the user   mapped.gset.idx.list -   filterGeneSets (  mapped.gset.idx.list , min.sz =   max (  1 ,  min.sz ) , max.sz =  max.sz )  if (  !   missing (  kcdf ) )  {  if (   kcdf ==  \"Gaussian\" )  {   rnaseq -  FALSE   kernel -  TRUE } else  if (   kcdf ==  \"Poisson\" )  {   rnaseq -  TRUE   kernel -  TRUE } else   kernel -  FALSE }   rval -   .gsva (  expr ,  mapped.gset.idx.list ,  method ,  kcdf ,  rnaseq ,  abs.ranking ,  parallel.sz ,  mx.diff ,  tau ,  kernel ,  ssgsea.norm ,  verbose ,  BPPARAM )  rval } ",
    "filename": "gsva.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_11 gsva_release_3_12

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_11 gsva_release_3_12",
    "desc_release_old": "1.36.3",
    "desc_release_new": "1.38.2",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_12 gsva_release_3_13

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_12 gsva_release_3_13",
    "desc_release_old": "1.38.2",
    "desc_release_new": "1.40.1",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_13 gsva_release_3_14

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_13 gsva_release_3_14",
    "desc_release_old": "1.40.1",
    "desc_release_new": "1.42.0",
    "old_release_number": 17,
    "new_release_number": 18,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  gsva_release_3_14 gsva_master

{
    "package": "GSVA",
    "release_versions": "gsva_release_3_14 gsva_master",
    "desc_release_old": "1.42.0",
    "desc_release_new": "1.43.1",
    "old_release_number": 18,
    "new_release_number": 19,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

