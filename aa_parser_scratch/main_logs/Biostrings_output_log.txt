
###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_1_8 biostrings_release_1_9

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_1_8 biostrings_release_1_9",
    "desc_release_old": "2.0.3",
    "desc_release_new": "2.2.1",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 1,
    "function_additions": 10,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 1
}

##########
Functions Removed
##########

debug_bbuf


##########
Functions Added
##########

debug_CharBuffer
IUPAC_CODE_MAP
AMINO_ACID_CODE
GENETIC_CODE
DNA_ALPHABET
RNA_ALPHABET
AA_ALPHABET
AAString
as.complex
alphabet


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_1_9 biostrings_release_2_1

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_1_9 biostrings_release_2_1",
    "desc_release_old": "2.2.1",
    "desc_release_new": "2.6.6",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 5,
    "function_additions": 32,
    "parameter_removals": 10,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 5,
    "total_count": 10
}

##########
Functions Removed
##########

debug_utils
debug_CharBuffer
debug_shiftor
print.needwunsQS
alignScore.needwunsQS


##########
Functions Added
##########

writeFASTA
gregexpr2
FASTArecordsToCharacter
CharacterToFASTArecords
FASTArecordsToBStringViews
BStringViewsToFASTArecords
read.BStringViews
write.BStringViews
subviews
toComplex
start
end
desc<-
subpatterns
pattern
align1
align2
score
substr
substring
mask
matchLRPatterns
matchProbePair
palindromeArmLength
palindromeLeftArm
palindromeRightArm
findPalindromes
consmat
lcprefix
lcsuffix
pmatchPattern
lcsubstr


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "BString",
    "parameters": "function ( x , baseOnly )",
    "body": "{   BString.char_frequency (  x ) } ",
    "filename": "alphabetFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "BString",
    "parameters": "function ( x , baseOnly = FALSE )",
    "body": "{   BString.char_frequency (  x ) } ",
    "filename": "alphabetFrequency.txt"
  }
}

1.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAString",
    "parameters": "function ( x , baseOnly )",
    "body": "{   BString.alphabet_frequency (  x ,  baseOnly ) } ",
    "filename": "alphabetFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAString",
    "parameters": "function ( x , baseOnly = FALSE )",
    "body": "{   BString.alphabet_frequency (  x ,  baseOnly ) } ",
    "filename": "alphabetFrequency.txt"
  }
}

2.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAString",
    "parameters": "function ( x , baseOnly )",
    "body": "{   BString.alphabet_frequency (  x ,  baseOnly ) } ",
    "filename": "alphabetFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAString",
    "parameters": "function ( x , baseOnly = FALSE )",
    "body": "{   BString.alphabet_frequency (  x ,  baseOnly ) } ",
    "filename": "alphabetFrequency.txt"
  }
}

3.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "BStringViews",
    "parameters": "function ( x , baseOnly )",
    "body": "{   lx -   length (  x ) # Just a trick to generate a zero-filled answer   ans -   alphabetFrequency (    x @ subject [  1 ] ,  baseOnly )    ans [ ] -  0  if (   lx ==  0 )   return (  ans )  for  ( i in   1 :  lx )   ans -   ans +   alphabetFrequency (   x [[  i ] ] ,  baseOnly )  ans } ",
    "filename": "alphabetFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "BStringViews",
    "parameters": "function ( x , baseOnly = FALSE )",
    "body": "{   lx -   length (  x ) ## Just a trick to generate a zero-filled answer   ans -   alphabetFrequency (    x @ subject [  1 ] ,  baseOnly )    ans [ ] -  0  if (   lx ==  0 )   return (  ans )  for  ( i in   1 :  lx )   ans -   ans +   alphabetFrequency (   x [[  i ] ] ,  baseOnly )  ans } ",
    "filename": "alphabetFrequency.txt"
  }
}

4.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "BStringCodec",
    "parameters": "function ( .Object , letters , codes , enc_hole , dec_hole , extra_letters , extra_codes )",
    "body": "{   checkCodecLettersAndCodes (  letters ,  codes )    .Object @ letters -   new (  \"PrintableCharBuffer\" ,   nchar (  letters ) )     .Object @ letters [ ] -  letters    .Object @ codes -   CharBuffer (   length (  codes ) )     .Object @ codes [ ] -  codes   ord -   as.integer (   .Object @ letters )    .Object @ dec_hash -   buildCodecHashTable (  codes ,  ord ,  dec_hole )  if (  !   missing (  extra_letters ) )  {   checkCodecLettersAndCodes (  extra_letters ,  extra_codes )   tmp -   new (  \"PrintableCharBuffer\" ,   nchar (  extra_letters ) )    tmp [ ] -  extra_letters   ord -   c (  ord ,   as.integer (  tmp ) )   codes -   c (  codes ,  extra_codes ) }    .Object @ enc_hash -   buildCodecHashTable (  ord ,  codes ,  enc_hole )  .Object } ",
    "filename": "BStringCodec.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "BStringCodec",
    "parameters": "function ( .Object , letters , codes , extra_letters = NULL , extra_codes = NULL )",
    "body": "{   letter_byte_vals -   letterAsByteVal (  letters )   codes -   as.integer (  codes )    .Object @ letters -  letters    .Object @ codes -  codes    .Object @ dec_lkup -   buildLookupTable (  codes ,  letter_byte_vals )  if (  !   is.null (  extra_letters ) )  {   letter_byte_vals -   c (  letter_byte_vals ,   letterAsByteVal (  extra_letters ) )   codes -   c (  codes ,   as.integer (  extra_codes ) ) }    .Object @ enc_lkup -   buildLookupTable (  letter_byte_vals ,  codes )  .Object } ",
    "filename": "BStringCodec-class.txt"
  }
}

5.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "file",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{   fasta -   readFASTA (  src )   src -   sapply (  fasta ,  function ( rec )   rec $ seq )   desc -   sapply (  fasta ,  function ( rec )   rec $ desc )   ans -   BStringViews (  src ,  subjectClass ,  sep ) # call the default method    ans @ desc -  desc  ans } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "file",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{   .Deprecated (  \"read.BStringViews\" )   read.BStringViews (  src ,  \"fasta\" ,  subjectClass ,  collapse ) } ",
    "filename": "BStringViews-constructors.txt"
  }
}

6.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BString",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{  if (  !   missing (  sep ) )  { # The semantic is: views are delimited by the occurences of 'sep' # in 'src' (a kind of strsplit() for BString objects). # Uncomment when normalize() and ! method are ready (see TODO file): #return(!normalize(matchPattern(sep, b, fixed=TRUE)))   stop (  \"'sep' not yet supported when 'src' is a \\\"BString\\\" object\" ) }  if (   !   missing (  subjectClass ) undefined   subjectClass !=   class (  src ) )   src -   new (  subjectClass ,  src )   new (  \"BStringViews\" ,  src ,   as.integer (  1 ) ,   src @ length ) } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BString",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{  if (  !   missing (  collapse ) )  { ## The semantic is: views are delimited by the occurences of 'collapse' ## in 'src' (a kind of strsplit() for BString objects). ## Uncomment when normalize() and ! method are ready (see TODO file): #return(!normalize(matchPattern(collapse, b, fixed=TRUE)))   stop (  \"'collapse' not yet supported when 'src' is a \\\"BString\\\" object\" ) }  if (   !   missing (  subjectClass ) undefined   subjectClass !=   class (  src ) )   src -   new (  subjectClass ,  src )   new (  \"BStringViews\" , subject =  src , views =   data.frame ( start =  1L , end =   nchar (  src ) ) ) } ",
    "filename": "BStringViews-constructors.txt"
  }
}

7.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BStringViews",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{  if (  !   missing (  sep ) )   stop (  \"'sep' not supported when 'src' is a \\\"BStringViews\\\" object\" )    src @ subject -   new (  subjectClass ,   src @ subject )  src } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BStringViews",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{  if (  !   missing (  collapse ) )   stop (  \"'collapse' not supported when 'src' is a \\\"BStringViews\\\" object\" )    src @ subject -   new (  subjectClass ,   src @ subject )  src } ",
    "filename": "BStringViews-constructors.txt"
  }
}

8.
{
  "old_function": {
    "name": "nchar",
    "representation": "nchar",
    "signature": "BStringViews",
    "parameters": "function ( x , type )",
    "body": "{   ls -   length (   x @ subject )     ifelse (    x @ last =  ls ,   x @ last ,  ls ) -   ifelse (    x @ first =  1 ,   x @ first ,  1 ) +  1 } ",
    "filename": "BStringViews.txt"
  },
  "new_function": {
    "name": "nchar",
    "representation": "nchar",
    "signature": "BStringViews",
    "parameters": "function ( x , type = \"chars\" , allowNA = FALSE )",
    "body": "{  if (    length (  x ) ==  0 )   return (   integer (  0 ) )   start0 -   pmax.int (   start (  x ) ,  1L )   end0 -   pmin.int (   end (  x ) ,   nchar (   x @ subject ) )   ans -    end0 -  start0 +  1L    ans [   ans undefined  0L ] -  0L  ans } ",
    "filename": "BStringViews-class.txt"
  }
}

9.
{
  "old_function": {
    "name": "nchar",
    "representation": "nchar",
    "signature": "BString",
    "parameters": "function ( x , type )",
    "body": "x @ length",
    "filename": "BString.txt"
  },
  "new_function": {
    "name": "nchar",
    "representation": "nchar",
    "signature": "BString",
    "parameters": "function ( x , type = \"chars\" , allowNA = FALSE )",
    "body": "x @ length",
    "filename": "BString-class.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "BStringCodec",
    "parameters": "function ( .Object , letters , codes , enc_hole , dec_hole , extra_letters , extra_codes )",
    "body": "{   checkCodecLettersAndCodes (  letters ,  codes )    .Object @ letters -   new (  \"PrintableCharBuffer\" ,   nchar (  letters ) )     .Object @ letters [ ] -  letters    .Object @ codes -   CharBuffer (   length (  codes ) )     .Object @ codes [ ] -  codes   ord -   as.integer (   .Object @ letters )    .Object @ dec_hash -   buildCodecHashTable (  codes ,  ord ,  dec_hole )  if (  !   missing (  extra_letters ) )  {   checkCodecLettersAndCodes (  extra_letters ,  extra_codes )   tmp -   new (  \"PrintableCharBuffer\" ,   nchar (  extra_letters ) )    tmp [ ] -  extra_letters   ord -   c (  ord ,   as.integer (  tmp ) )   codes -   c (  codes ,  extra_codes ) }    .Object @ enc_hash -   buildCodecHashTable (  ord ,  codes ,  enc_hole )  .Object } ",
    "filename": "BStringCodec.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "BStringCodec",
    "parameters": "function ( .Object , letters , codes , extra_letters = NULL , extra_codes = NULL )",
    "body": "{   letter_byte_vals -   letterAsByteVal (  letters )   codes -   as.integer (  codes )    .Object @ letters -  letters    .Object @ codes -  codes    .Object @ dec_lkup -   buildLookupTable (  codes ,  letter_byte_vals )  if (  !   is.null (  extra_letters ) )  {   letter_byte_vals -   c (  letter_byte_vals ,   letterAsByteVal (  extra_letters ) )   codes -   c (  codes ,   as.integer (  extra_codes ) ) }    .Object @ enc_lkup -   buildLookupTable (  letter_byte_vals ,  codes )  .Object } ",
    "filename": "BStringCodec-class.txt"
  }
}

1.
{
  "old_function": {
    "name": "views",
    "representation": "views",
    "parameters": "function ( subject , first = NA , last = NA )",
    "body": "{  if (    class (  subject ) ==  \"character\" )   subject -   BString (  subject )   ans -   new (  \"BStringViews\" ,  subject ) # Integrity checking  if (   !   isLooseNumeric (  first ) ||  !   isLooseNumeric (  last ) )   stop (  \"'first' and 'last' must be numerics\" ) #if (length(first) != length(last)) #    stop(\"'first' and 'last' must have the same length\")  if (  !   is.integer (  first ) )   first -   as.integer (  first )    first [   is.na (  first ) ] -   as.integer (  1 )  if (  !   is.integer (  last ) )   last -   as.integer (  last )    last [   is.na (  last ) ] -   subject @ length  if (    length (  first ) undefined   length (  last ) )   first -   recycleVector (  first ,   length (  last ) ) else  if (    length (  last ) undefined   length (  first ) )   last -   recycleVector (  last ,   length (  first ) ) # The NA-proof version of 'if (any(last  if (  !   isTRUE (   all (   first =  last ) ) )   stop (  \"'first' and 'last' must verify 'first )    ans @ first -  first    ans @ last -  last  ans } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "views",
    "representation": "views",
    "parameters": "function ( subject , start = NA , end = NA )",
    "body": "{  if (  !   is (  subject ,  \"BString\" ) )  {  if (    !   is.character (  subject ) ||    length (  subject ) !=  1 ||   is.na (  subject ) )   stop (  \"'subject' must be a BString (or derived) object or a single string\" )   subject -   BString (  subject ) }   ans -   new (  \"BStringViews\" , subject =  subject )    ans @ views -   .makeViews (  subject ,  start ,  end )  ans } ",
    "filename": "BStringViews-constructors.txt"
  }
}

2.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "file",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{   fasta -   readFASTA (  src )   src -   sapply (  fasta ,  function ( rec )   rec $ seq )   desc -   sapply (  fasta ,  function ( rec )   rec $ desc )   ans -   BStringViews (  src ,  subjectClass ,  sep ) # call the default method    ans @ desc -  desc  ans } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "file",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{   .Deprecated (  \"read.BStringViews\" )   read.BStringViews (  src ,  \"fasta\" ,  subjectClass ,  collapse ) } ",
    "filename": "BStringViews-constructors.txt"
  }
}

3.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BString",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{  if (  !   missing (  sep ) )  { # The semantic is: views are delimited by the occurences of 'sep' # in 'src' (a kind of strsplit() for BString objects). # Uncomment when normalize() and ! method are ready (see TODO file): #return(!normalize(matchPattern(sep, b, fixed=TRUE)))   stop (  \"'sep' not yet supported when 'src' is a \\\"BString\\\" object\" ) }  if (   !   missing (  subjectClass ) undefined   subjectClass !=   class (  src ) )   src -   new (  subjectClass ,  src )   new (  \"BStringViews\" ,  src ,   as.integer (  1 ) ,   src @ length ) } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BString",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{  if (  !   missing (  collapse ) )  { ## The semantic is: views are delimited by the occurences of 'collapse' ## in 'src' (a kind of strsplit() for BString objects). ## Uncomment when normalize() and ! method are ready (see TODO file): #return(!normalize(matchPattern(collapse, b, fixed=TRUE)))   stop (  \"'collapse' not yet supported when 'src' is a \\\"BString\\\" object\" ) }  if (   !   missing (  subjectClass ) undefined   subjectClass !=   class (  src ) )   src -   new (  subjectClass ,  src )   new (  \"BStringViews\" , subject =  src , views =   data.frame ( start =  1L , end =   nchar (  src ) ) ) } ",
    "filename": "BStringViews-constructors.txt"
  }
}

4.
{
  "old_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BStringViews",
    "parameters": "function ( src , subjectClass , sep )",
    "body": "{  if (  !   missing (  sep ) )   stop (  \"'sep' not supported when 'src' is a \\\"BStringViews\\\" object\" )    src @ subject -   new (  subjectClass ,   src @ subject )  src } ",
    "filename": "BStringViews-constructors.txt"
  },
  "new_function": {
    "name": "BStringViews",
    "representation": "BStringViews",
    "signature": "BStringViews",
    "parameters": "function ( src , subjectClass , collapse = \"\" )",
    "body": "{  if (  !   missing (  collapse ) )   stop (  \"'collapse' not supported when 'src' is a \\\"BStringViews\\\" object\" )    src @ subject -   new (  subjectClass ,   src @ subject )  src } ",
    "filename": "BStringViews-constructors.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_1 biostrings_release_2_2

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_1 biostrings_release_2_2",
    "desc_release_old": "2.6.6",
    "desc_release_new": "2.8.18",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 1,
    "function_additions": 102,
    "parameter_removals": 2,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 3,
    "total_count": 4
}

##########
Functions Removed
##########

BStringViewsToFASTArecords


##########
Functions Added
##########

IRanges
intToRanges
intToAdjacentRanges
shift
restrict
narrow
reduce
toNormalIRanges
gaps
Mask
read.gapMask
read.agpMask
read.liftMask
read.rmMask
read.trfMask
mergeIUPACLetters
BStringSet
DNAStringSet
RNAStringSet
AAStringSet
trim
FASTArecordsToXStringViews
XStringSetToFASTArecords
read.XStringViews
read.BStringSet
read.DNAStringSet
read.RNAStringSet
read.AAStringSet
write.XStringSet
write.XStringViews
subXString
strrev
mkAllStrings
dinucleotideFrequency
trinucleotideFrequency
transcribe
cDNA
dna2rna
rna2dna
.inplaceReplaceLetterAtLoc
maxWeights
maxScore
PWMscore
matchPWM
countPWM
extractAllMatches
names
duplicated
coerce
as.data.frame
update
isNormal
whichFirstNotNormal
isEmpty
max
min
start<-
width<-
end<-
nir_list
active
active<-
maskedwidth
maskedratio
append
ls
XString
subseq
XStringViews
BStringList
DNAStringList
RNAStringList
AAStringList
unmasked
masks
masks<-
oligonucleotideFrequency
chartr
replaceLetterAtLoc
maskMotif
injectHardMask
nmismatchStartingAt
nmismatchEndingAt
isMatching
coverage
vcountPattern
findComplementedPalindromes
complementedPalindromeArmLength
complementedPalindromeLeftArm
complementedPalindromeRightArm
patternFrequency
head
tail
startIndex
endIndex
countIndex
unlist
PDict
matchPDict
countPDict
type
pairwiseAlignment


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm , mismatch , fixed )",
    "body": "{   .matchPattern (  pattern ,  subject ,  algorithm ,  mismatch ,  fixed ) } ",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed )",
    "filename": "matchPattern.txt"
  }
}

1.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm , mismatch , fixed )",
    "body": "{   .matchPattern (  pattern ,  subject ,  algorithm ,  mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm , mismatch , fixed )",
    "body": "{   .matchPattern (  pattern ,  subject ,  algorithm ,  mismatch ,  fixed ) } ",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed )",
    "filename": "matchPattern.txt"
  }
}

1.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm , mismatch , fixed )",
    "body": "{   .matchPattern (  pattern ,  subject ,  algorithm ,  mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

2.
{
  "old_function": {
    "name": "subviews",
    "representation": "subviews",
    "parameters": "function ( x , start = NA , end = NA , width = NA , check.limits = TRUE )",
    "body": "{  if (  !   is (  x ,  \"BStringViews\" ) )   stop (  \"'x' must be a BStringViews object\" )  if (  !   isNumericOrNAs (  start ) )   stop (  \"'start' must be a numeric vector\" )  if (  !   isNumericOrNAs (  end ) )   stop (  \"'end' must be a numeric vector\" )  if (  !   isNumericOrNAs (  width ) )   stop (  \"'width' must be a numeric vector\" )  if (    length (  x ) ==  0 )   return (  x )  if (     length (  start ) ==  0 ||    length (  start ) undefined   length (  x ) )   stop (  \"length of 'start' must be != 0 and )  if (     length (  end ) ==  0 ||    length (  end ) undefined   length (  x ) )   stop (  \"length of 'end' must be != 0 and )  if (     length (  width ) ==  0 ||    length (  width ) undefined   length (  x ) )   stop (  \"length of 'width' must be != 0 and )  if (  !   is.integer (  start ) )   start -   as.integer (  start )  if (  !   is.integer (  end ) )   end -   as.integer (  end )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (    length (  start ) undefined   length (  x ) )   start -   rep (  start , length.out =   length (  x ) )  if (    length (  end ) undefined   length (  x ) )   end -   rep (  end , length.out =   length (  x ) )  if (    length (  width ) undefined   length (  x ) )   width -   rep (  width , length.out =   length (  x ) )   views -   solveViews (  start ,  end ,  width ,  1L ,   width (  x ) )   start -     start (  x ) +   views $ start -  1L   end -     start (  x ) +   views $ end -  1L  if (   check.limits undefined  (    any (   start undefined  1L ) ||   any (    nchar (   subject (  x ) ) undefined  end ) ) )   stop (  \"result contains \\\"out of limits\\\" views\" )     x @ views $ start -  start     x @ views $ end -  end  x } ",
    "filename": "subBString.txt"
  },
  "new_function": {
    "name": "subviews",
    "representation": "subviews",
    "parameters": "function ( x , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "{  if (  !   is (  x ,  \"XStringViews\" ) )   stop (  \"'x' must be an XStringViews object\" )   narrow (  x , start =  start , end =  end , width =  width , use.names =  use.names ) } ",
    "filename": "XStringViews-constructors.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_2 biostrings_release_2_3

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_2 biostrings_release_2_3",
    "desc_release_old": "2.8.18",
    "desc_release_new": "2.10.22",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 40,
    "function_additions": 56,
    "parameter_removals": 3,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 28,
    "total_count": 68
}

##########
Functions Removed
##########

IRanges
intToRanges
intToAdjacentRanges
shift
restrict
toNormalIRanges
Mask
read.gapMask
read.agpMask
read.liftMask
read.rmMask
read.trfMask
views
trim
subviews
.inplaceReplaceLetterAtLoc
desc
desc<-
as.data.frame
update
isNormal
whichFirstNotNormal
isEmpty
max
min
start<-
width<-
end<-
nir_list
active
active<-
subject
BStringList
DNAStringList
RNAStringList
AAStringList
align1
align2
first
last


##########
Functions Added
##########

RNA_GENETIC_CODE
DNA_BASES
RNA_BASES
fasta.info
hasOnlyBaseLetters
uniqueLetters
oligonucleotideTransitions
codons
translate
replaceLetterAt
.inplaceReplaceLetterAt
neditStartingAt
neditEndingAt
neditAt
isMatchingStartingAt
isMatchingEndingAt
isMatchingAt
nmatch
nmismatch
vmatchPattern
tb
tb.width
whichPDict
vmatchPDict
vcountPDict
PhredQuality
SolexaQuality
quality
QualityScaledBStringSet
QualityScaledDNAStringSet
QualityScaledRNAStringSet
QualityScaledAAStringSet
insertion
deletion
unaligned
aligned
indel
nindel
pid
mismatchTable
mismatchSummary
compareStrings
consensusMatrix
consensusString
nucleotideSubstitutionMatrix
errorSubstitutionMatrices
qualitySubstitutionMatrices
stringDist
rep
order
sort
Views
names<-
as.integer
as.numeric
summary


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

1.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{  if (    class (  pattern ) !=   class (   subject @ subject ) )   pattern -   XString (   class (   subject @ subject ) ,  pattern )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   class (  subject ) )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   matches -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   matches -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   ans_width -   rep.int (  pattern_length ,   length (  matches ) )   new (  \"XStringViews\" ,   subject @ subject , start =  matches , width =  ans_width , check =  FALSE ) } ",
    "filename": "matchPattern.BOC.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{  if (    class (  pattern ) !=   class (   subject @ subject ) )   pattern -   XString (   class (   subject @ subject ) ,  pattern )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   class (  subject ) )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  }
}

2.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree",
    "parameters": "function ( .Object , xp , base_codes )",
    "body": "{    .Object @ nodes -   XInteger (  1 )     .Object @ nodes @ xp -  xp    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree",
    "parameters": "function ( .Object , tb , dup2unq0 )",
    "body": "{   base_codes -   codes (  tb , baseOnly =  TRUE )   on.exit (   .Call (  \"free_actree_nodes_buf\" , PACKAGE =  \"Biostrings\" ) )   C_ans -   .Call (  \"build_ACtree\" ,  tb ,  dup2unq0 ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,   C_ans $ dup2unq )    .Object @ nodes -   C_ans $ nodes    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  }
}

1.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

2.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{  if (    class (  pattern ) !=   class (   subject @ subject ) )   pattern -   XString (   class (   subject @ subject ) ,  pattern )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   class (  subject ) )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   matches -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   matches -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   ans_width -   rep.int (  pattern_length ,   length (  matches ) )   new (  \"XStringViews\" ,   subject @ subject , start =  matches , width =  ans_width , check =  FALSE ) } ",
    "filename": "matchPattern.BOC.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{  if (    class (  pattern ) !=   class (   subject @ subject ) )   pattern -   XString (   class (   subject @ subject ) ,  pattern )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   class (  subject ) )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  }
}

3.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

4.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

5.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

6.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  }
}

7.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm , max.mismatch , fixed )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

8.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

9.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

10.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

11.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  }
}

12.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

13.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

14.
{
  "old_function": {
    "name": "countIndex",
    "representation": "countIndex",
    "signature": "MIndex",
    "parameters": "function ( x , all.names = FALSE )",
    "body": "{  if (  !   is.null (   names (  x ) ) )  {   end_index -   endIndex (  x , all.names =  all.names )  if (    length (  end_index ) ==  0 )   return (   integer (  0 ) )   return (   sapply (  end_index ,  length ) ) }  if (  !   missing (  all.names ) )   warning (  \"'all.names' is ignored when patterns have no names\" )   end_index -   endIndex (  x )  if (    length (  end_index ) ==  0 )   return (   integer (  0 ) )   sapply (  end_index ,  length ) } ",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countIndex",
    "representation": "countIndex",
    "signature": "MIndex",
    "parameters": "function ( x )",
    "body": "{   end_index -   endIndex (  x )  if (    length (  end_index ) ==  0 )   return (   integer (  0 ) )   sapply (  end_index ,  length ) } ",
    "filename": "MIndex-class.txt"
  }
}

15.
{
  "old_function": {
    "name": "startIndex",
    "representation": "startIndex",
    "signature": "ByPos_MIndex",
    "parameters": "function ( x , all.names = FALSE )",
    "body": "{  if (  !   missing (  all.names ) )   warning (  \"'all.names' is ignored when patterns have no names\" )   .Call (  \"shiftListOfInts\" ,   x @ ends ,   1L -   x @ width , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "startIndex",
    "representation": "startIndex",
    "signature": "ByPos_MIndex",
    "parameters": "function ( x )",
    "body": "{   .Call (  \"ByPos_MIndex_endIndex\" ,    x @ dups0 @ dup2unq ,   x @ ends ,   x @ width , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "MIndex-class.txt"
  }
}

16.
{
  "old_function": {
    "name": "startIndex",
    "representation": "startIndex",
    "signature": "ByName_MIndex",
    "parameters": "function ( x , all.names = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  all.names ) )   stop (  \"'all.names' must be 'TRUE' or 'FALSE'\" )   .Call (  \"extract_endIndex\" ,   x @ ends_envir ,   1L -   x @ width ,   x @ NAMES ,  all.names , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "startIndex",
    "representation": "startIndex",
    "signature": "ByName_MIndex",
    "parameters": "function ( x )",
    "body": "{   all.names -  TRUE   .Call (  \"ByName_MIndex_endIndex\" ,   x @ ends_envir ,   x @ width ,   x @ NAMES ,  all.names , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "MIndex-class.txt"
  }
}

17.
{
  "old_function": {
    "name": "endIndex",
    "representation": "endIndex",
    "signature": "ByPos_MIndex",
    "parameters": "function ( x , all.names = FALSE )",
    "body": "{  if (  !   missing (  all.names ) )   warning (  \"'all.names' is ignored when patterns have no names\" )   x @ ends } ",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "endIndex",
    "representation": "endIndex",
    "signature": "ByPos_MIndex",
    "parameters": "function ( x )",
    "body": "{   .Call (  \"ByPos_MIndex_endIndex\" ,    x @ dups0 @ dup2unq ,   x @ ends ,  NULL , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "MIndex-class.txt"
  }
}

18.
{
  "old_function": {
    "name": "endIndex",
    "representation": "endIndex",
    "signature": "ByName_MIndex",
    "parameters": "function ( x , all.names = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  all.names ) )   stop (  \"'all.names' must be 'TRUE' or 'FALSE'\" )   .Call (  \"extract_endIndex\" ,   x @ ends_envir ,  0L ,   x @ NAMES ,  all.names , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "endIndex",
    "representation": "endIndex",
    "signature": "ByName_MIndex",
    "parameters": "function ( x )",
    "body": "{   all.names -  TRUE   .Call (  \"ByName_MIndex_endIndex\" ,   x @ ends_envir ,  NULL ,   x @ NAMES ,  all.names , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "MIndex-class.txt"
  }
}

19.
{
  "old_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  character , subject =  character )",
    "parameters": "function ( pattern , subject , patternQuality = 22L , subjectQuality = 22L , type = \"global\" , substitutionMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "XString.pairwiseAlignment ( BString ( pattern ) , BString ( subject ) , patternQuality = patternQuality , subjectQuality = subjectQuality , type = type , substitutionMatrix = substitutionMatrix , gapExtension = gapExtension , gapOpening = gapOpening , scoreOnly = scoreOnly )",
    "filename": "pairwiseAlignment.txt"
  },
  "new_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  character , subject =  character )",
    "parameters": "function ( pattern , subject , patternQuality = PhredQuality ( 22L ) , subjectQuality = PhredQuality ( 22L ) , type = \"global\" , substitutionMatrix = NULL , fuzzyMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "{  if (  !   is.null (  substitutionMatrix ) )  {   XStringSet.pairwiseAlignment ( pattern =   BStringSet (  pattern ) , subject =   BStringSet (  subject ) , type =  type , substitutionMatrix =  substitutionMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } else  {   QualityScaledXStringSet.pairwiseAlignment ( pattern =   QualityScaledBStringSet (   BStringSet (  pattern ) ,  patternQuality ) , subject =   QualityScaledBStringSet (   BStringSet (  subject ) ,  subjectQuality ) , type =  type , fuzzyMatrix =  fuzzyMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } } ",
    "filename": "pairwiseAlignment.txt"
  }
}

20.
{
  "old_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  character , subject =  XString )",
    "parameters": "function ( pattern , subject , patternQuality = 22L , subjectQuality = 22L , type = \"global\" , substitutionMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "XString.pairwiseAlignment ( XString ( class ( subject ) , pattern ) , subject , patternQuality = patternQuality , subjectQuality = subjectQuality , type = type , substitutionMatrix = substitutionMatrix , gapExtension = gapExtension , gapOpening = gapOpening , scoreOnly = scoreOnly )",
    "filename": "pairwiseAlignment.txt"
  },
  "new_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  character , subject =  XString )",
    "parameters": "function ( pattern , subject , patternQuality = PhredQuality ( 22L ) , subjectQuality = PhredQuality ( 22L ) , type = \"global\" , substitutionMatrix = NULL , fuzzyMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "{  if (  !   is.null (  substitutionMatrix ) )  {   XStringSet.pairwiseAlignment ( pattern =   XStringSet (   class (  subject ) ,  pattern ) , subject =   XStringSet (   class (  subject ) ,  subject ) , type =  type , substitutionMatrix =  substitutionMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } else  {   QualityScaledXStringSet.pairwiseAlignment ( pattern =   QualityScaledXStringSet (   XStringSet (   class (  subject ) ,  pattern ) ,  patternQuality ) , subject =   QualityScaledXStringSet (   XStringSet (   class (  subject ) ,  subject ) ,  subjectQuality ) , type =  type , fuzzyMatrix =  fuzzyMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } } ",
    "filename": "pairwiseAlignment.txt"
  }
}

21.
{
  "old_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  XString , subject =  character )",
    "parameters": "function ( pattern , subject , patternQuality = 22L , subjectQuality = 22L , type = \"global\" , substitutionMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "XString.pairwiseAlignment ( pattern , XString ( class ( pattern ) , subject ) , patternQuality = patternQuality , subjectQuality = subjectQuality , type = type , substitutionMatrix = substitutionMatrix , gapExtension = gapExtension , gapOpening = gapOpening , scoreOnly = scoreOnly )",
    "filename": "pairwiseAlignment.txt"
  },
  "new_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  XString , subject =  character )",
    "parameters": "function ( pattern , subject , patternQuality = PhredQuality ( 22L ) , subjectQuality = PhredQuality ( 22L ) , type = \"global\" , substitutionMatrix = NULL , fuzzyMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "{  if (  !   is.null (  substitutionMatrix ) )  {   XStringSet.pairwiseAlignment ( pattern =   XStringSet (   class (  pattern ) ,  pattern ) , subject =   XStringSet (   class (  pattern ) ,  subject ) , type =  type , substitutionMatrix =  substitutionMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } else  {   QualityScaledXStringSet.pairwiseAlignment ( pattern =   QualityScaledXStringSet (   XStringSet (   class (  pattern ) ,  pattern ) ,  patternQuality ) , subject =   QualityScaledXStringSet (   XStringSet (   class (  pattern ) ,  subject ) ,  subjectQuality ) , type =  type , fuzzyMatrix =  fuzzyMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } } ",
    "filename": "pairwiseAlignment.txt"
  }
}

22.
{
  "old_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  XString , subject =  XString )",
    "parameters": "function ( pattern , subject , patternQuality = 22L , subjectQuality = 22L , type = \"global\" , substitutionMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "XString.pairwiseAlignment ( pattern , subject , patternQuality = patternQuality , subjectQuality = subjectQuality , type = type , substitutionMatrix = substitutionMatrix , gapExtension = gapExtension , gapOpening = gapOpening , scoreOnly = scoreOnly )",
    "filename": "pairwiseAlignment.txt"
  },
  "new_function": {
    "name": "pairwiseAlignment",
    "representation": "pairwiseAlignment",
    "signature": "signature ( pattern =  XString , subject =  XString )",
    "parameters": "function ( pattern , subject , patternQuality = PhredQuality ( 22L ) , subjectQuality = PhredQuality ( 22L ) , type = \"global\" , substitutionMatrix = NULL , fuzzyMatrix = NULL , gapOpening = - 10 , gapExtension = - 4 , scoreOnly = FALSE )",
    "body": "{  if (  !   is.null (  substitutionMatrix ) )  {   XStringSet.pairwiseAlignment ( pattern =   XStringSet (   class (  pattern ) ,  pattern ) , subject =   XStringSet (   class (  subject ) ,  subject ) , type =  type , substitutionMatrix =  substitutionMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } else  {   QualityScaledXStringSet.pairwiseAlignment ( pattern =   QualityScaledXStringSet (   XStringSet (   class (  pattern ) ,  pattern ) ,  patternQuality ) , subject =   QualityScaledXStringSet (   XStringSet (   class (  subject ) ,  subject ) ,  subjectQuality ) , type =  type , fuzzyMatrix =  fuzzyMatrix , gapExtension =  gapExtension , gapOpening =  gapOpening , scoreOnly =  scoreOnly ) } } ",
    "filename": "pairwiseAlignment.txt"
  }
}

23.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "character",
    "parameters": "function ( dict , tb.start = 1 , tb.end = NA , drop.head = FALSE , drop.tail = FALSE , skip.invalid.patterns = FALSE )",
    "body": "{  if (    length (  dict ) ==  0 )   stop (  \"'dict' must contain at least one pattern\" )   .PDict (  dict ,   names (  dict ) ,  tb.start ,  tb.end ,  drop.head ,  drop.tail ,  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "character",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

24.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "DNAStringSet",
    "parameters": "function ( dict , tb.start = 1 , tb.end = NA , drop.head = FALSE , drop.tail = FALSE , skip.invalid.patterns = FALSE )",
    "body": "{  if (    length (  dict ) ==  0 )   stop (  \"'dict' must contain at least one pattern\" )   .PDict (  dict ,   names (  dict ) ,  tb.start ,  tb.end ,  drop.head ,  drop.tail ,  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "DNAStringSet",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

25.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "XStringViews",
    "parameters": "function ( dict , tb.start = 1 , tb.end = NA , drop.head = FALSE , drop.tail = FALSE , skip.invalid.patterns = FALSE )",
    "body": "{   dict -   DNAStringSet (  dict )   PDict (  dict , tb.start =  tb.start , tb.end =  tb.end , drop.head =  drop.head , drop.tail =  drop.tail , skip.invalid.patterns =  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "XStringViews",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": "{  if (  !   is (   subject (  x ) ,  \"DNAString\" ) )   stop (  \"'subject(x)' must be a DNAString object\" )   .PDict (  x ,  max.mismatch ,  tb.start ,  tb.end ,  tb.width ,  type ,  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  }
}

26.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "AsIs",
    "parameters": "function ( dict , tb.start = 1 , tb.end = NA , drop.head = FALSE , drop.tail = FALSE , skip.invalid.patterns = FALSE )",
    "body": "{  if (  !   is.character (  dict ) )   stop (  \"unsuported 'dict' type\" )    class (  dict ) -  \"character\" # keeps the names (unlike as.character())   PDict (  dict , tb.start =  tb.start , tb.end =  tb.end , drop.head =  drop.head , drop.tail =  drop.tail , skip.invalid.patterns =  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "AsIs",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

27.
{
  "old_function": {
    "name": "readFASTA",
    "representation": "readFASTA",
    "parameters": "function ( file , checkComments = TRUE , strip.desc = TRUE )",
    "body": "{   if (   missing (  strip.desc ) )   warning (  \"use 'strip.desc=FALSE' for compatibility with old version\\n\" ,  \"  of readFASTA(), or 'strip.desc=TRUE' to remove the \\\" ,  \"  at the beginning of the description lines and to get\\n\" ,  \"  rid of this warning (see '?readFASTA' for more details)\" )  if (   is.character (  file ) )  {   file -   file (  file ,  \"r\" )   on.exit (   close (  file ) ) } else  {  if (  !   inherits (  file ,  \"connection\" ) )   stop (  \"'file' must be a character string or connection\" )  if (  !   isOpen (  file ) )  {   open (  file ,  \"r\" )   on.exit (   close (  file ) ) } }   s1 -   scan ( file =  file , what =  \"\" , sep =  \"\\n\" , quote =  \"\" , allowEscapes =  FALSE ) ;  if (  checkComments )  { ##comments are supposedly lines beginning with semi-colons   comments -   grep (  \"^;\" ,  s1 )  if (    length (  comments ) undefined  0 )   s1 -   s1 [  -  comments ] }   descriptions -   which (    substr (  s1 ,  1L ,  1L ) ==  \" )   numF -   length (  descriptions )  if (   numF ==  0 )   stop (  \"no FASTA sequences found\" )   dp -   descriptions +  1L   dm -   descriptions -  1L   end -   c (   dm [  -  1 ] ,   length (  s1 ) )   lapply (   seq_len (  numF ) ,  function ( i )  {   desc -   s1 [   descriptions [  i ] ]  if (  strip.desc )   desc -   substr (  desc ,  2L ,   nchar (  desc ) )   seq -   paste (   s1 [    dp [  i ] :   end [  i ] ] , collapse =  \"\" )   list ( desc =  desc , seq =  seq ) } ) } ",
    "filename": "readFASTA.txt"
  },
  "new_function": {
    "name": "readFASTA",
    "representation": "readFASTA",
    "parameters": "function ( file , checkComments = TRUE , strip.descs = TRUE )",
    "body": "{  if (   missing (  strip.descs ) )   warning (  \"use 'strip.descs=FALSE' for compatibility with old version\\n\" ,  \"  of readFASTA(), or 'strip.descs=TRUE' to remove the \\\" ,  \"  at the beginning of the description lines and to get\\n\" ,  \"  rid of this warning (see '?readFASTA' for more details)\" )  if (   is.character (  file ) )  {   file -   file (  file ,  \"r\" )   on.exit (   close (  file ) ) } else  {  if (  !   inherits (  file ,  \"connection\" ) )   stop (  \"'file' must be a character string or connection\" )  if (  !   isOpen (  file ) )  {   open (  file ,  \"r\" )   on.exit (   close (  file ) ) } }   s1 -   scan ( file =  file , what =  \"\" , sep =  \"\\n\" , quote =  \"\" , allowEscapes =  FALSE , quiet =  TRUE )  if (  checkComments )  { ##comments are supposedly lines beginning with semi-colons   comments -   grep (  \"^;\" ,  s1 )  if (    length (  comments ) undefined  0 )   s1 -   s1 [  -  comments ] }   descriptions -   which (    substr (  s1 ,  1L ,  1L ) ==  \" )   numF -   length (  descriptions )  if (   numF ==  0 )   stop (  \"no FASTA sequences found\" )   dp -   descriptions +  1L   dm -   descriptions -  1L   end -   c (   dm [  -  1 ] ,   length (  s1 ) )   lapply (   seq_len (  numF ) ,  function ( i )  {   desc -   s1 [   descriptions [  i ] ]  if (  strip.descs )   desc -   substr (  desc ,  2L ,   nchar (  desc ) )   seq -   paste (   s1 [    dp [  i ] :   end [  i ] ] , collapse =  \"\" )   list ( desc =  desc , seq =  seq ) } ) } ",
    "filename": "readFASTA.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_3 biostrings_release_2_4

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_3 biostrings_release_2_4",
    "desc_release_old": "2.10.22",
    "desc_release_new": "2.12.10",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 1,
    "function_additions": 29,
    "parameter_removals": 8,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 28,
    "total_count": 29
}

##########
Functions Removed
##########

XString


##########
Functions Added
##########

xsbasetype
xsbasetype<-
xscat
fastq.geometry
nucleotideFrequencyAt
hasLetterAt
trimLRPatterns
PWMscoreStartingAt
PairwiseAlignedXStringSet
PairwiseAlignedFixedSubject
nedit
basecontent
countbases
complementSeq
reverseSeq
revcompDNA
revcompRNA
longestConsecutive
matchprobes
union
intersect
setdiff
setequal
%in%
match
unique
rank
threebands
subseq<-


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "BString",
    "representation": "BString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"BString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "BString",
    "representation": "BString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"B\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

1.
{
  "old_function": {
    "name": "DNAString",
    "representation": "DNAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"DNAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "DNAString",
    "representation": "DNAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"DNA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

2.
{
  "old_function": {
    "name": "RNAString",
    "representation": "RNAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"RNAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "RNAString",
    "representation": "RNAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"RNA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "AAString",
    "representation": "AAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"AAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "AAString",
    "representation": "AAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"AA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

4.
{
  "old_function": {
    "name": "BStringSet",
    "representation": "BStringSet",
    "parameters": "function ( x , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"BString\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  },
  "new_function": {
    "name": "BStringSet",
    "representation": "BStringSet",
    "parameters": "function ( x = character ( ) , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"B\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  }
}

5.
{
  "old_function": {
    "name": "DNAStringSet",
    "representation": "DNAStringSet",
    "parameters": "function ( x , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"DNAString\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  },
  "new_function": {
    "name": "DNAStringSet",
    "representation": "DNAStringSet",
    "parameters": "function ( x = character ( ) , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"DNA\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  }
}

6.
{
  "old_function": {
    "name": "RNAStringSet",
    "representation": "RNAStringSet",
    "parameters": "function ( x , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"RNAString\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  },
  "new_function": {
    "name": "RNAStringSet",
    "representation": "RNAStringSet",
    "parameters": "function ( x = character ( ) , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"RNA\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  }
}

7.
{
  "old_function": {
    "name": "AAStringSet",
    "representation": "AAStringSet",
    "parameters": "function ( x , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"AAString\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  },
  "new_function": {
    "name": "AAStringSet",
    "representation": "AAStringSet",
    "parameters": "function ( x = character ( ) , start = NA , end = NA , width = NA , use.names = TRUE )",
    "body": "XStringSet ( \"AA\" , x , start = start , end = end , width = width , use.names = use.names )",
    "filename": "XStringSet-class.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , start = NA , end = NA , weight = 1L )",
    "body": "coverage ( subject ( x ) , start = NA , end = NA , weight = 1L )",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( subject ( x ) , start = start , end = end , shift = shift , width = width , weight = weight )",
    "filename": "align-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskedXString",
    "parameters": "function ( x , start = NA , end = NA , weight = 1L )",
    "body": "coverage ( masks ( x ) , start = start , end = end , weight = weight )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskedXString",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( masks ( x ) , start = start , end = end , shift = shift , width = width , weight = weight )",
    "filename": "match-utils.txt"
  }
}

2.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "Twobit",
    "parameters": "function ( .Object , tb , dup2unq0 )",
    "body": "{   base_codes -   codes (  tb , baseOnly =  TRUE )   C_ans -   .Call (  \"build_Twobit\" ,  tb ,  dup2unq0 ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,   C_ans $ dup2unq )    .Object @ sign2pos -   C_ans $ sign2pos    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "Twobit",
    "parameters": "function ( .Object , tb , pp_exclude )",
    "body": "{   base_codes -   xscodes (  tb , baseOnly =  TRUE )   C_ans -   .Call (  \"build_Twobit\" ,  tb ,  pp_exclude ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,  pp_exclude ,   C_ans $ dup2unq )    .Object @ sign2pos -   C_ans $ sign2pos    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  }
}

4.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree",
    "parameters": "function ( .Object , tb , dup2unq0 )",
    "body": "{   base_codes -   codes (  tb , baseOnly =  TRUE )   on.exit (   .Call (  \"free_actree_nodes_buf\" , PACKAGE =  \"Biostrings\" ) )   C_ans -   .Call (  \"build_ACtree\" ,  tb ,  dup2unq0 ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,   C_ans $ dup2unq )    .Object @ nodes -   C_ans $ nodes    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree",
    "parameters": "function ( .Object , tb , pp_exclude )",
    "body": "{   base_codes -   xscodes (  tb , baseOnly =  TRUE )   on.exit (   .Call (  \"free_actree_nodes_buf\" , PACKAGE =  \"Biostrings\" ) )   C_ans -   .Call (  \"build_ACtree\" ,  tb ,  pp_exclude ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,  pp_exclude ,   C_ans $ dup2unq )    .Object @ nodes -   C_ans $ nodes    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  }
}

5.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree2",
    "parameters": "function ( .Object , tb , dup2unq0 )",
    "body": "{   base_codes -   codes (  tb , baseOnly =  TRUE ) #on.exit(.Call(\"free_actree_nodes_buf\", PACKAGE=\"Biostrings\"))   C_ans -   .Call (  \"ACtree2_build\" ,  tb ,  dup2unq0 ,  base_codes , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,   C_ans $ dup2unq )    .Object @ nodes -    C_ans $ ACtree $ nodes    .Object @ extensions -    C_ans $ ACtree $ extensions    .Object @ nextensions -    C_ans $ ACtree $ nextensions    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "ACtree2",
    "parameters": "function ( .Object , tb , pp_exclude )",
    "body": "{   nodebuf_max_nblock -   .Call (  \"ACtree2_nodebuf_max_nblock\" , PACKAGE =  \"Biostrings\" )   nodebuf_ptr -   .Call (  \"IntegerBAB_new\" ,  nodebuf_max_nblock , PACKAGE =  \"Biostrings\" )   nodeextbuf_max_nblock -   .Call (  \"ACtree2_nodeextbuf_max_nblock\" , PACKAGE =  \"Biostrings\" )   nodeextbuf_ptr -   .Call (  \"IntegerBAB_new\" ,  nodeextbuf_max_nblock , PACKAGE =  \"Biostrings\" )   base_codes -   xscodes (  tb , baseOnly =  TRUE )   C_ans -   .Call (  \"ACtree2_build\" ,  tb ,  pp_exclude ,  base_codes ,  nodebuf_ptr ,  nodeextbuf_ptr , PACKAGE =  \"Biostrings\" )   .Object -   callNextMethod (  .Object ,  tb ,  pp_exclude ,   C_ans $ dup2unq )    .Object @ nodebuf_ptr -  nodebuf_ptr    .Object @ nodeextbuf_ptr -  nodeextbuf_ptr    .Object @ base_codes -  base_codes  .Object } ",
    "filename": "PDict-class.txt"
  }
}

6.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "MaskedXString",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "{  if (   any (   active (   masks (  subject ) ) ) )   warning (  \"masks were dropped\" )   Views (   unmasked (  subject ) , start =  start , end =  end , names =  names ) } ",
    "filename": "MaskedXString-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "MaskedXString",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "{  if (   any (   active (   masks (  subject ) ) ) )   warning (  \"masks were dropped\" )   Views (   unmasked (  subject ) , start =  start , end =  end , width =  width , names =  names ) } ",
    "filename": "MaskedXString-class.txt"
  }
}

7.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "{  if (   all (   is.na (  start ) ) )   start -   start (   subject (  subject ) ) else  if (   !   is.numeric (  start ) ||    length (  start ) undefined  1 )   stop (  \"'start' must be either NA or an integer vector of length 1\" ) else   start -    as.integer (  start ) +   start (   subject (  subject ) )  if (   all (   is.na (  end ) ) )   end -   end (   subject (  subject ) ) else  if (   !   is.numeric (  end ) ||    length (  end ) undefined  1 )   stop (  \"'end' must be either NA or an integer vector of length 1\" ) else   end -    as.integer (  end ) +   start (   subject (  subject ) )   Views (   super (   unaligned (   subject (  subject ) ) ) , start =  start , end =  end , names =  names ) } ",
    "filename": "PairwiseAlignedFixedSubject-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "{  if (  !   is.null (  width ) )   stop (  \"\\\"Views\\\" method for PairwiseAlignedFixedSubject objects \" ,  \"does not support the 'width' argument yet, sorry!\" )  if (   is.null (  start ) )   start -  NA  if (   all (   is.na (  start ) ) )   start -   start (   subject (  subject ) ) else  if (   !   is.numeric (  start ) ||    length (  start ) undefined  1 )   stop (  \"'start' must be either NA or an integer vector of length 1\" ) else   start -    as.integer (  start ) +   start (   subject (  subject ) )  if (   is.null (  end ) )   end -  NA  if (   all (   is.na (  end ) ) )   end -   end (   subject (  subject ) ) else  if (   !   is.numeric (  end ) ||    length (  end ) undefined  1 )   stop (  \"'end' must be either NA or an integer vector of length 1\" ) else   end -    as.integer (  end ) +   start (   subject (  subject ) )   Views (   super (   unaligned (   subject (  subject ) ) ) , start =  start , end =  end , names =  names ) } ",
    "filename": "PairwiseAlignedFixedSubject-class.txt"
  }
}

8.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XString",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , names = names , Class = \"XStringViews\" )",
    "filename": "XStringViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XString",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , width = width , names = names , Class = \"XStringViews\" )",
    "filename": "XStringViews-class.txt"
  }
}

9.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "character",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "{   xsubject -   XString (  NULL ,  subject )   Views (  xsubject , start =  start , end =  end , names =  names ) } ",
    "filename": "XStringViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "character",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "{   xsubject -   XString (  NULL ,  subject )   Views (  xsubject , start =  start , end =  end , width =  width , names =  names ) } ",
    "filename": "XStringViews-class.txt"
  }
}

10.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_end -   integer (  0 )   Lmatches -   matchPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , fixed =  Lfixed )  if (    length (  Lmatches ) !=  0L )  {   Rmatches -   matchPattern (  Rpattern ,  subject , max.mismatch =  max.Rmismatch , fixed =  Rfixed )  if (    length (  Rmatches ) !=  0L )  {  for  ( i in   seq_len (   length (  Lmatches ) ) )  {   ngaps -     start (  Rmatches ) -    end (  Lmatches ) [  i ] -  1L   jj -   which (    0L =  ngaps undefined   ngaps =  max.ngaps )   ans_start -   c (  ans_start ,   rep.int (    start (  Lmatches ) [  i ] ,   length (  jj ) ) )   ans_end -   c (  ans_end ,    end (  Rmatches ) [  jj ] ) } } }   ans_width -    ans_end -  ans_start +  1L   unsafe.newXStringViews (  subject ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_end -   integer (  0 )   Lmatches -   matchPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , with.indels =  with.Lindels , fixed =  Lfixed )  if (    length (  Lmatches ) !=  0L )  {   Rmatches -   matchPattern (  Rpattern ,  subject , max.mismatch =  max.Rmismatch , with.indels =  with.Rindels , fixed =  Rfixed )  if (    length (  Rmatches ) !=  0L )  {  for  ( i in   seq_len (   length (  Lmatches ) ) )  {   ngaps -     start (  Rmatches ) -    end (  Lmatches ) [  i ] -  1L   jj -   which (    0L =  ngaps undefined   ngaps =  max.ngaps )   ans_start -   c (  ans_start ,   rep.int (    start (  Lmatches ) [  i ] ,   length (  jj ) ) )   ans_end -   c (  ans_end ,    end (  Rmatches ) [  jj ] ) } } }   ans_width -    ans_end -  ans_start +  1L   unsafe.newXStringViews (  subject ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  }
}

11.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XStringViews",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_width -   integer (  0 )  for  ( i in   seq_len (   length (  subject ) ) )  {   pm -   matchLRPatterns (  Lpattern ,  Rpattern ,  max.ngaps ,   subject [[  i ] ] , max.Lmismatch =  max.Lmismatch , max.Rmismatch =  max.Rmismatch , Lfixed =  Lfixed , Rfixed =  Rfixed )   offset -     start (  subject ) [  i ] -  1L   ans_start -   c (  ans_start ,   offset +   start (  pm ) )   ans_width -   c (  ans_width ,   width (  pm ) ) }   unsafe.newXStringViews (   subject (  subject ) ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XStringViews",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_width -   integer (  0 )  for  ( i in   seq_len (   length (  subject ) ) )  {   pm -   matchLRPatterns (  Lpattern ,  Rpattern ,  max.ngaps ,   subject [[  i ] ] , max.Lmismatch =  max.Lmismatch , max.Rmismatch =  max.Rmismatch , with.Lindels =  with.Lindels , with.Rindels =  with.Rindels , Lfixed =  Lfixed , Rfixed =  Rfixed )   offset -     start (  subject ) [  i ] -  1L   ans_start -   c (  ans_start ,   offset +   start (  pm ) )   ans_width -   c (  ans_width ,   width (  pm ) ) }   unsafe.newXStringViews (   subject (  subject ) ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  }
}

12.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "MaskedXString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "matchLRPatterns ( Lpattern , Rpattern , max.ngaps , toXStringViewsOrXString ( subject ) , max.Lmismatch = max.Lmismatch , max.Rmismatch = max.Rmismatch , Lfixed = Lfixed , Rfixed = Rfixed )",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "MaskedXString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "matchLRPatterns ( Lpattern , Rpattern , max.ngaps , toXStringViewsOrXString ( subject ) , max.Lmismatch = max.Lmismatch , max.Rmismatch = max.Rmismatch , with.Lindels = with.Lindels , with.Rindels = with.Rindels , Lfixed = Lfixed , Rfixed = Rfixed )",
    "filename": "matchLRPatterns.txt"
  }
}

13.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

14.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose , count.only = TRUE )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , fixed , collapse , weight , verbose , count.only = TRUE )",
    "filename": "matchPDict.txt"
  }
}

15.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

16.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

17.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "character",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "character",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , algorithm = \"ACtree2\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , algorithm , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

18.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "DNAStringSet",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "DNAStringSet",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , algorithm = \"ACtree2\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , algorithm , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

19.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "XStringViews",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": "{  if (  !   is (   subject (  x ) ,  \"DNAString\" ) )   stop (  \"'subject(x)' must be a DNAString object\" )   .PDict (  x ,  max.mismatch ,  tb.start ,  tb.end ,  tb.width ,  type ,  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "XStringViews",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , algorithm = \"ACtree2\" , skip.invalid.patterns = FALSE )",
    "body": "{  if (  !   is (   subject (  x ) ,  \"DNAString\" ) )   stop (  \"'subject(x)' must be a DNAString object\" )   .PDict (  x ,  max.mismatch ,  tb.start ,  tb.end ,  tb.width ,  algorithm ,  skip.invalid.patterns ) } ",
    "filename": "PDict-class.txt"
  }
}

20.
{
  "old_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "AsIs",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , type = \"ACtree\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , type , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "PDict",
    "representation": "PDict",
    "signature": "AsIs",
    "parameters": "function ( x , max.mismatch = NA , tb.start = NA , tb.end = NA , tb.width = NA , algorithm = \"ACtree2\" , skip.invalid.patterns = FALSE )",
    "body": ".PDict ( x , max.mismatch , tb.start , tb.end , tb.width , algorithm , skip.invalid.patterns )",
    "filename": "PDict-class.txt"
  }
}

21.
{
  "old_function": {
    "name": "writeFASTA",
    "representation": "writeFASTA",
    "parameters": "function ( x , file = \"\" , width = 80 )",
    "body": "{  if (   is.character (  file ) )  {  if (     length (  file ) !=  1 ||   is.na (  file ) )   stop (  \"'file' must be a character string or connection\" )  if (   file !=  \"\" )  {   file -   file (  file ,  \"w\" )   on.exit (   close (  file ) ) } } else  {  if (  !   inherits (  file ,  \"connection\" ) )   stop (  \"'file' must be a character string or connection\" )  if (  !   isOpen (  file ) )  {   open (  file ,  \"w\" )   on.exit (   close (  file ) ) } }  if (    !   is.numeric (  width ) ||    length (  width ) !=  1 ||   is.na (  width ) )   stop (  \"'width' must be an integer )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   width undefined  1L )   stop (  \"'width' must be an integer )  for  ( rec in  x )  {   cat (  \" ,   rec $ desc ,  \"\\n\" , file =  file , sep =  \"\" )   nlines -     nchar (   rec $ seq ) %/%  width +  1L  for  ( i in   seq_len (  nlines ) )  {   start -    (   i -  1L ) *  width +  1L   stop -    start +  width -  1L  if (   stop undefined   nchar (   rec $ seq ) )   stop -   nchar (   rec $ seq )   line -   substr (   rec $ seq ,  start ,  stop )   cat (  line ,  \"\\n\" , file =  file , sep =  \"\" ) } } } ",
    "filename": "readFASTA.txt"
  },
  "new_function": {
    "name": "writeFASTA",
    "representation": "writeFASTA",
    "parameters": "function ( x , file = \"\" , append = FALSE , width = 80 )",
    "body": "{  if (  !   isTRUEorFALSE (  append ) )   stop (  \"'append' must be TRUE or FALSE\" )  if (   isSingleString (  file ) )  {  if (   file ==  \"\" )  {   file -   stdout ( ) } else  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  if (   inherits (  file ,  \"connection\" ) )  {  if (  !   isOpen (  file ) )  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  {   stop (  \"'file' must be a single string or connection\" ) }  if (  !   isSingleNumber (  width ) )   stop (  \"'width' must be an integer )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   width undefined  1L )   stop (  \"'width' must be an integer )  for  ( rec in  x )  {   cat (  \" ,   rec $ desc ,  \"\\n\" , file =  file , sep =  \"\" )   nlines -     nchar (   rec $ seq ) %/%  width +  1L  for  ( i in   seq_len (  nlines ) )  {   start -    (   i -  1L ) *  width +  1L   stop -    start +  width -  1L  if (   stop undefined   nchar (   rec $ seq ) )   stop -   nchar (   rec $ seq )   line -   substr (   rec $ seq ,  start ,  stop )   cat (  line ,  \"\\n\" , file =  file , sep =  \"\" ) } } } ",
    "filename": "readFASTA.txt"
  }
}

22.
{
  "old_function": {
    "name": "BString",
    "representation": "BString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"BString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "BString",
    "representation": "BString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"B\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

23.
{
  "old_function": {
    "name": "DNAString",
    "representation": "DNAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"DNAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "DNAString",
    "representation": "DNAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"DNA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

24.
{
  "old_function": {
    "name": "RNAString",
    "representation": "RNAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"RNAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "RNAString",
    "representation": "RNAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"RNA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

25.
{
  "old_function": {
    "name": "AAString",
    "representation": "AAString",
    "parameters": "function ( x , start = 1 , nchar = NA , check = TRUE )",
    "body": "XString ( \"AAString\" , x , start = start , nchar = nchar , check = check )",
    "filename": "XString-class.txt"
  },
  "new_function": {
    "name": "AAString",
    "representation": "AAString",
    "parameters": "function ( x = \"\" , start = 1 , nchar = NA )",
    "body": "XString ( \"AA\" , x , start = start , width = nchar )",
    "filename": "XString-class.txt"
  }
}

26.
{
  "old_function": {
    "name": "write.XStringSet",
    "representation": "write.XStringSet",
    "parameters": "function ( x , file = \"\" , format , width = 80 )",
    "body": "{  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ) )   switch (  format , \"fasta\" =   .write.fasta (  x ,  file ,  width ) ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "write.XStringSet",
    "representation": "write.XStringSet",
    "parameters": "function ( x , file = \"\" , append = FALSE , format , width = 80 )",
    "body": "{  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ) )   switch (  format , \"fasta\" =   .write.fasta (  x ,  file ,  append ,  width ) ) } ",
    "filename": "XStringSet-io.txt"
  }
}

27.
{
  "old_function": {
    "name": "write.XStringViews",
    "representation": "write.XStringViews",
    "parameters": "function ( x , file = \"\" , format , width = 80 )",
    "body": "{   y -   XStringViewsToSet (  x , use.names =  TRUE )   write.XStringSet (  y , file =  file ,  format , width =  width ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "write.XStringViews",
    "representation": "write.XStringViews",
    "parameters": "function ( x , file = \"\" , append = FALSE , format , width = 80 )",
    "body": "{   y -   XStringViewsToSet (  x , use.names =  TRUE )   write.XStringSet (  y , file =  file , append =  append ,  format , width =  width ) } ",
    "filename": "XStringSet-io.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_4 biostrings_release_2_5

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_4 biostrings_release_2_5",
    "desc_release_old": "2.12.10",
    "desc_release_new": "2.14.12",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 2,
    "function_additions": 36,
    "parameter_removals": 7,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 63,
    "total_count": 65
}

##########
Functions Removed
##########

alignScore
reduce


##########
Functions Added
##########

compact
partitioning
BKeySortedData
DNAKeySortedData
RNAKeySortedData
AAKeySortedData
dataKey
dataTable
BKeySortedDataList
DNAKeySortedDataList
RNAKeySortedDataList
AAKeySortedDataList
save.XStringSet
letterFrequencyInSlidingView
dinucleotideFrequencyTest
transcriptWidths
extractTranscripts
transcriptLocs2refLocs
N50
width0
which.isMatchingStartingAt
which.isMatchingEndingAt
which.isMatchingAt
minWeights
minScore
unitScale
PWM
WCPscoreStartingAt
matchWCP
countWCP
nnodes
vwhichPDict
updateObject
[[<-
is.unsorted
collapse


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "read.XStringViews",
    "representation": "read.XStringViews",
    "parameters": "function ( file , format , subjectClass , collapse = \"\" )",
    "body": "{  if (   !   is.character (  file ) ||   any (   is.na (  file ) ) )   stop (  \"'file' must be a character vector with no NAs\" )  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ,  \"fastq\" ) )  if (  !   isSingleString (  subjectClass ) )   stop (  \"'subjectClass' must be a single string\" )  if (  !   isSingleString (  collapse ) )   stop (  \"'collapse' must be a single string\" )   switch (  format , \"fasta\" =   .read.fasta (  file ,  subjectClass ,  collapse ) , \"fastq\" =   .read.fastq (  file , drop.quality =  TRUE ,  subjectClass ) ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.XStringViews",
    "representation": "read.XStringViews",
    "parameters": "function ( filepath , format = \"fasta\" , subjectClass , collapse = \"\" )",
    "body": "{  if (   !   is.character (  filepath ) ||   any (   is.na (  filepath ) ) )   stop (  \"'filepath' must be a character vector with no NAs\" )  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ,  \"fastq\" ) )  if (  !   isSingleString (  subjectClass ) )   stop (  \"'subjectClass' must be a single string\" )  if (  !   isSingleString (  collapse ) )   stop (  \"'collapse' must be a single string\" )   switch (  format , \"fasta\" =   .read.fasta (  filepath ,  subjectClass ,  collapse ) , \"fastq\" =   .read.fastq (  filepath , drop.quality =  TRUE ,  subjectClass ) ) } ",
    "filename": "XStringSet-io.txt"
  }
}

1.
{
  "old_function": {
    "name": "read.BStringSet",
    "representation": "read.BStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"BString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.BStringSet",
    "representation": "read.BStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"B\" )",
    "filename": "XStringSet-io.txt"
  }
}

2.
{
  "old_function": {
    "name": "read.DNAStringSet",
    "representation": "read.DNAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"DNAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.DNAStringSet",
    "representation": "read.DNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"DNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

3.
{
  "old_function": {
    "name": "read.RNAStringSet",
    "representation": "read.RNAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"RNAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.RNAStringSet",
    "representation": "read.RNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"RNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

4.
{
  "old_function": {
    "name": "read.AAStringSet",
    "representation": "read.AAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"AAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.AAStringSet",
    "representation": "read.AAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"AA\" )",
    "filename": "XStringSet-io.txt"
  }
}

5.
{
  "old_function": {
    "name": "write.XStringSet",
    "representation": "write.XStringSet",
    "parameters": "function ( x , file = \"\" , append = FALSE , format , width = 80 )",
    "body": "{  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ) )   switch (  format , \"fasta\" =   .write.fasta (  x ,  file ,  append ,  width ) ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "write.XStringSet",
    "representation": "write.XStringSet",
    "parameters": "function ( x , file = \"\" , append = FALSE , format = \"fasta\" , width = 80 )",
    "body": "{  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ) )   switch (  format , \"fasta\" =   .write.XStringSet.to.fasta (  x ,  file ,  append ,  width ) , \"fastq\" =   .write.XStringSet.to.fastq (  x ,  file ,  append ) ) } ",
    "filename": "XStringSet-io.txt"
  }
}

6.
{
  "old_function": {
    "name": "write.XStringViews",
    "representation": "write.XStringViews",
    "parameters": "function ( x , file = \"\" , append = FALSE , format , width = 80 )",
    "body": "{   y -   XStringViewsToSet (  x , use.names =  TRUE )   write.XStringSet (  y , file =  file , append =  append ,  format , width =  width ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "write.XStringViews",
    "representation": "write.XStringViews",
    "parameters": "function ( x , file = \"\" , append = FALSE , format = \"fasta\" , width = 80 )",
    "body": "{   y -   XStringViewsToSet (  x , use.names =  TRUE )   write.XStringSet (  y , file =  file , append =  append ,  format , width =  width ) } ",
    "filename": "XStringSet-io.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , high2low , base_codes )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  high2low )    .Object @ base_codes -  base_codes # should be 'xscodes(tb, baseOnly=TRUE)'  .Object } ",
    "filename": "PDict-class.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , baseOnly = FALSE , freq = FALSE , gapCode = \"-\" , endgapCode = \"-\" )",
    "body": "{   consensusMatrix (   aligned (  x , gapCode =  gapCode , endgapCode =  endgapCode ) , baseOnly =  baseOnly , freq =  freq ) } ",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL , baseOnly = FALSE , gapCode = \"-\" , endgapCode = \"-\" )",
    "body": "{  if (   !   identical (  shift ,  0L ) ||  !   identical (  width ,  NULL ) )   stop (  \"\\\"consensusMatrix\\\" method for PairwiseAlignedFixedSubject objects \" ,  \"doesn't support the 'shift' and 'width' arguments\" )   consensusMatrix (   aligned (  x , gapCode =  gapCode , endgapCode =  endgapCode ) , as.prob =  as.prob , freq =  freq , baseOnly =  baseOnly ) } ",
    "filename": "align-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "character",
    "parameters": "function ( x , freq = FALSE )",
    "body": "consensusMatrix ( BStringSet ( x ) , freq = freq )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "character",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( x ) , as.prob = as.prob , freq = freq , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  }
}

2.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "matrix",
    "parameters": "function ( x , freq = FALSE )",
    "body": "consensusMatrix ( BStringSet ( apply ( x , 1 , paste , collapse = \"\" ) ) , freq = freq )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "matrix",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( apply ( x , 1 , paste , collapse = \"\" ) ) , as.prob = as.prob , freq = freq , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  }
}

3.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "list",
    "parameters": "function ( x , freq = FALSE )",
    "body": "consensusMatrix ( BStringSet ( FASTArecordsToCharacter ( x , use.names = FALSE ) ) , freq = freq )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "list",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( FASTArecordsToCharacter ( x , use.names = FALSE ) ) , as.prob = as.prob , freq = freq , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  }
}

4.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "XStringSet",
    "parameters": "function ( x , baseOnly = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "{  if (  !   is.integer (  shift ) )   shift -   as.integer (  shift )  if (     length (  x ) !=  0 undefined    length (  shift ) undefined   length (  x ) )   stop (  \"'shift' has more elements than 'x'\" )  if (  !   is.null (  width ) )  {  if (   !   isSingleNumber (  width ) ||   width undefined  0 )   stop (  \"'width' must be NULL or a single non-negative integer\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width ) }   codes -   xscodes (  x , baseOnly =  baseOnly )  if (   is.null (   names (  codes ) ) )  {    names (  codes ) -   intToUtf8 (  codes , multiple =  TRUE )   removeUnused -  TRUE } else  {   removeUnused -  FALSE }   freq -   .normargFreq (  freq )   ans -   .Call (  \"XStringSet_consensus_matrix\" ,  x ,  codes ,  baseOnly ,  shift ,  width , PACKAGE =  \"Biostrings\" )  if (  removeUnused )  {   ans -   ans [    rowSums (  ans ) undefined  0 , , drop =  FALSE ] }  if (  freq )  {   col_sums -   colSums (  ans )    col_sums [   col_sums ==  0 ] -  1 # to avoid division by 0   ans -   ans /   rep (  col_sums , each =   nrow (  ans ) ) }  ans } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "XStringSet",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL , baseOnly = FALSE )",
    "body": "{  if (  !   is.integer (  shift ) )   shift -   as.integer (  shift )  if (     length (  x ) !=  0 undefined    length (  shift ) undefined   length (  x ) )   stop (  \"'shift' has more elements than 'x'\" )  if (  !   is.null (  width ) )  {  if (   !   isSingleNumber (  width ) ||   width undefined  0 )   stop (  \"'width' must be NULL or a single non-negative integer\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width ) }   codes -   xscodes (  x , baseOnly =  baseOnly )  if (   is.null (   names (  codes ) ) )  {    names (  codes ) -   intToUtf8 (  codes , multiple =  TRUE )   removeUnused -  TRUE } else  {   removeUnused -  FALSE }   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"consensusMatrix\" )   ans -   .Call (  \"XStringSet_consensus_matrix\" ,  x ,  shift ,  width ,  baseOnly ,  codes , PACKAGE =  \"Biostrings\" )  if (  removeUnused )  {   ans -   ans [    rowSums (  ans ) undefined  0 , , drop =  FALSE ] }  if (  as.prob )  {   col_sums -   colSums (  ans )    col_sums [   col_sums ==  0 ] -  1 # to avoid division by 0   ans -   ans /   rep (  col_sums , each =   nrow (  ans ) ) }  ans } ",
    "filename": "letterFrequency.txt"
  }
}

5.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   freq -   .normargFreq (  freq )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XString_oligo_frequency\" ,  x ,  base_codes ,  width ,  freq ,  as.array ,  fast.moving.side ,  with.labels , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , as.prob = FALSE , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"oligonucleotideFrequency\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XString_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

6.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   freq -   .normargFreq (  freq )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_oligo_frequency\" ,  x ,  base_codes ,  width ,  freq ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , as.prob = FALSE , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"oligonucleotideFrequency\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

7.
{
  "old_function": {
    "name": "oligonucleotideTransitions",
    "representation": "oligonucleotideTransitions",
    "parameters": "function ( x , left = 1 , right = 1 , freq = FALSE )",
    "body": "{   frequencies -   oligonucleotideFrequency (  x , width =   left +  right , freq =  freq )   transitions -   matrix (  frequencies , nrow =   4 ^  left , ncol =   4 ^  right , byrow =  TRUE , dimnames =   list (   unique (   substring (   names (  frequencies ) ,  1 ,  left ) ) ,   unique (   substring (   names (  frequencies ) ,   left +  1 ,   left +  right ) ) ) )  if (  freq )   transitions -   transitions /   rowSums (  transitions )  transitions } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideTransitions",
    "representation": "oligonucleotideTransitions",
    "parameters": "function ( x , left = 1 , right = 1 , as.prob = FALSE , freq = FALSE )",
    "body": "{   freqs -   oligonucleotideFrequency (  x , width =   left +  right , as.prob =  as.prob , freq =  freq )   transitions -   matrix (  freqs , nrow =   4 ^  left , ncol =   4 ^  right , byrow =  TRUE , dimnames =   list (   unique (   substring (   names (  freqs ) ,  1 ,  left ) ) ,   unique (   substring (   names (  freqs ) ,   left +  1 ,   left +  right ) ) ) )  if (  as.prob )   transitions -   transitions /   rowSums (  transitions )  transitions } ",
    "filename": "letterFrequency.txt"
  }
}

8.
{
  "old_function": {
    "name": "nucleotideFrequencyAt",
    "representation": "nucleotideFrequencyAt",
    "signature": "XStringSet",
    "parameters": "function ( x , at , freq = FALSE , as.array = TRUE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )  if (  !   is.integer (  at ) )   at -   as.integer (  at )   freq -   .normargFreq (  freq )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_nucleotide_frequency_at\" ,  x ,  base_codes ,  at ,  freq ,  as.array ,  fast.moving.side ,  with.labels , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "nucleotideFrequencyAt",
    "representation": "nucleotideFrequencyAt",
    "signature": "XStringSet",
    "parameters": "function ( x , at , as.prob = FALSE , freq = FALSE , as.array = TRUE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )  if (  !   is.integer (  at ) )   at -   as.integer (  at )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"nucleotideFrequencyAt\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_nucleotide_frequency_at\" ,  x ,  at ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

9.
{
  "old_function": {
    "name": "isMatchingAt",
    "representation": "isMatchingAt",
    "parameters": "function ( pattern , subject , at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )   isMatchingStartingAt (  pattern ,  subject , starting.at =  at , max.mismatch =  max.mismatch , with.indels =  with.indels , fixed =  fixed ) } ",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingAt",
    "representation": "isMatchingAt",
    "parameters": "function ( pattern , subject , at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )   isMatchingStartingAt (  pattern ,  subject , starting.at =  at , max.mismatch =  max.mismatch , min.mismatch =  min.mismatch , with.indels =  with.indels , fixed =  fixed ) } ",
    "filename": "lowlevel-matching.txt"
  }
}

10.
{
  "old_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "character",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "character",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

11.
{
  "old_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "XString",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "XString",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

12.
{
  "old_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".vmatchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingStartingAt",
    "representation": "isMatchingStartingAt",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , starting.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , starting.at , 0L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

13.
{
  "old_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "character",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "character",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

14.
{
  "old_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "XString",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "XString",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

15.
{
  "old_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".vmatchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , with.indels , fixed , 0L )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "isMatchingEndingAt",
    "representation": "isMatchingEndingAt",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , ending.at = 1 , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".matchPatternAt ( pattern , subject , ending.at , 1L , max.mismatch , min.mismatch , with.indels , fixed , 1L )",
    "filename": "lowlevel-matching.txt"
  }
}

16.
{
  "old_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , dup2unq )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  dup2unq )  .Object } ",
    "filename": "PDict-class.txt"
  },
  "new_function": {
    "name": "initialize",
    "representation": "initialize",
    "signature": "PreprocessedTB",
    "parameters": "function ( .Object , tb , pp_exclude , high2low , base_codes )",
    "body": "{    .Object @ tb -  tb    .Object @ exclude_dups0 -  !   is.null (  pp_exclude )    .Object @ dups -   Dups (  high2low )    .Object @ base_codes -  base_codes # should be 'xscodes(tb, baseOnly=TRUE)'  .Object } ",
    "filename": "PDict-class.txt"
  }
}

17.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

18.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   pattern -   normargPattern (  pattern ,   subject @ subject )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   subject @ subject )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   pattern -   normargPattern (  pattern ,   subject @ subject )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   subject @ subject )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  }
}

19.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

20.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

21.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vmatchPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vmatchPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

22.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

23.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  }
}

24.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

25.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

26.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

27.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vcountPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vcountPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

28.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

29.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  }
}

30.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

31.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

32.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  }
}

33.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"XStringViews objects are not supported yet, sorry\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"XStringViews objects are not supported yet, sorry\" )",
    "filename": "matchPattern.txt"
  }
}

34.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

35.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

36.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

37.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

38.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "vcountPattern ( pattern , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "vcountPattern ( pattern , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  }
}

39.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

40.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  }
}

41.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

42.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  }
}

43.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

44.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose , count.only = TRUE )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

45.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

46.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose , count.only = TRUE )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

47.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

48.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , fixed , verbose , count.only = NA )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

49.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  }
}

50.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

51.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

52.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

53.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , fixed , collapse , weight , verbose , count.only = TRUE )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , collapse , weight , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

54.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , fixed = fixed , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

55.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

56.
{
  "old_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( file , use.descs = TRUE )",
    "body": "{  if (  !   isSingleString (  file ) )   stop (  \"'file' must be a single string\" )   use.descs -   normargUseNames (  use.descs )   .Call (  \"fasta_info\" ,  file ,  use.descs , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "readFASTA.txt"
  },
  "new_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( filepath , use.descs = TRUE )",
    "body": "{  if (  !   is.character (  filepath ) )   stop (  \"'filepath' must be a character vector\" )   use.descs -   normargUseNames (  use.descs )   on.exit (   .Call (  \"io_cleanup\" , PACKAGE =  \"Biostrings\" ) )   .Call (  \"fasta_info\" ,  filepath ,  use.descs , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  }
}

57.
{
  "old_function": {
    "name": "fastq.geometry",
    "representation": "fastq.geometry",
    "parameters": "function ( file )",
    "body": "{   on.exit (   .Call (  \"fasta_io_cleanup\" , PACKAGE =  \"Biostrings\" ) )   .Call (  \"fastq_geometry\" ,  file , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "fastq.geometry",
    "representation": "fastq.geometry",
    "parameters": "function ( filepath )",
    "body": "{  if (  !   is.character (  filepath ) )   stop (  \"'filepath' must be a character vector\" )   on.exit (   .Call (  \"io_cleanup\" , PACKAGE =  \"Biostrings\" ) )   .Call (  \"fastq_geometry\" ,  filepath , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  }
}

58.
{
  "old_function": {
    "name": "read.XStringViews",
    "representation": "read.XStringViews",
    "parameters": "function ( file , format , subjectClass , collapse = \"\" )",
    "body": "{  if (   !   is.character (  file ) ||   any (   is.na (  file ) ) )   stop (  \"'file' must be a character vector with no NAs\" )  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ,  \"fastq\" ) )  if (  !   isSingleString (  subjectClass ) )   stop (  \"'subjectClass' must be a single string\" )  if (  !   isSingleString (  collapse ) )   stop (  \"'collapse' must be a single string\" )   switch (  format , \"fasta\" =   .read.fasta (  file ,  subjectClass ,  collapse ) , \"fastq\" =   .read.fastq (  file , drop.quality =  TRUE ,  subjectClass ) ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.XStringViews",
    "representation": "read.XStringViews",
    "parameters": "function ( filepath , format = \"fasta\" , subjectClass , collapse = \"\" )",
    "body": "{  if (   !   is.character (  filepath ) ||   any (   is.na (  filepath ) ) )   stop (  \"'filepath' must be a character vector with no NAs\" )  if (  !   isSingleString (  format ) )   stop (  \"'format' must be a single string\" )   format -   match.arg (   tolower (  format ) ,   c (  \"fasta\" ,  \"fastq\" ) )  if (  !   isSingleString (  subjectClass ) )   stop (  \"'subjectClass' must be a single string\" )  if (  !   isSingleString (  collapse ) )   stop (  \"'collapse' must be a single string\" )   switch (  format , \"fasta\" =   .read.fasta (  filepath ,  subjectClass ,  collapse ) , \"fastq\" =   .read.fastq (  filepath , drop.quality =  TRUE ,  subjectClass ) ) } ",
    "filename": "XStringSet-io.txt"
  }
}

59.
{
  "old_function": {
    "name": "read.BStringSet",
    "representation": "read.BStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"BString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.BStringSet",
    "representation": "read.BStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"B\" )",
    "filename": "XStringSet-io.txt"
  }
}

60.
{
  "old_function": {
    "name": "read.DNAStringSet",
    "representation": "read.DNAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"DNAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.DNAStringSet",
    "representation": "read.DNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"DNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

61.
{
  "old_function": {
    "name": "read.RNAStringSet",
    "representation": "read.RNAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"RNAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.RNAStringSet",
    "representation": "read.RNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"RNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

62.
{
  "old_function": {
    "name": "read.AAStringSet",
    "representation": "read.AAStringSet",
    "parameters": "function ( file , format )",
    "body": "as ( read.XStringViews ( file , format , \"AAString\" ) , \"XStringSet\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "read.AAStringSet",
    "representation": "read.AAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" )",
    "body": ".read.XStringSet ( filepath , format , TRUE , \"AA\" )",
    "filename": "XStringSet-io.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_5 biostrings_release_2_6

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_5 biostrings_release_2_6",
    "desc_release_old": "2.14.12",
    "desc_release_new": "2.16.9",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 52,
    "total_count": 52
}

##########
Functions Removed
##########



##########
Functions Added
##########

unsplit.list.of.XStringSet
hasAllFlinks
computeAllFlinks


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "AlignedXStringSet0",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start ) }   shift -   normargShift (  shift ,   length (   x @ range ) )  if (   is.null (  width ) )   width -    max (   nchar (   unaligned (  x ) ) ) +   max (  shift )   coverage (   x @ range , start =  start , end =  end , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "AlignedXStringSet0",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{   shift -   normargShift (  shift ,   length (   x @ range ) )  if (   is.null (  width ) )   width -    max (   nchar (   unaligned (  x ) ) ) +   max (  shift )   coverage (   x @ range , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "align-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( subject ( x ) , start = start , end = end , shift = shift , width = width , weight = weight )",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( subject ( x ) , shift = shift , width = width , weight = weight )",
    "filename": "align-utils.txt"
  }
}

2.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubjectSummary",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   shift !=  0L )   stop (  \"'shift' argument is not supported for 'PairwiseAlignedFixedSubjectSummary' objects\" )  if (   weight !=  1L )   stop (  \"'weight' argument is not supported for 'PairwiseAlignedFixedSubjectSummary' objects\" )   window (   x @ coverage , start =  start , end =  end , width =  width ) } ",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "PairwiseAlignedFixedSubjectSummary",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   shift !=  0L )   stop (  \"'shift' argument is not supported for 'PairwiseAlignedFixedSubjectSummary' objects\" )  if (   weight !=  1L )   stop (  \"'weight' argument is not supported for 'PairwiseAlignedFixedSubjectSummary' objects\" )   window (   x @ coverage , width =  width ) } ",
    "filename": "align-utils.txt"
  }
}

3.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskedXString",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( masks ( x ) , start = start , end = end , shift = shift , width = width , weight = weight )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskedXString",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( masks ( x ) , shift = shift , width = width , weight = weight )",
    "filename": "match-utils.txt"
  }
}

4.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MIndex",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( unlist ( x ) , start = start , end = end , shift = shift , width = width , weight = weight )",
    "filename": "match-utils.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MIndex",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "coverage ( unlist ( x ) , shift = shift , width = width , weight = weight )",
    "filename": "match-utils.txt"
  }
}

5.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_end -   integer (  0 )   Lmatches -   matchPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , with.indels =  with.Lindels , fixed =  Lfixed )  if (    length (  Lmatches ) !=  0L )  {   Rmatches -   matchPattern (  Rpattern ,  subject , max.mismatch =  max.Rmismatch , with.indels =  with.Rindels , fixed =  Rfixed )  if (    length (  Rmatches ) !=  0L )  {  for  ( i in   seq_len (   length (  Lmatches ) ) )  {   ngaps -     start (  Rmatches ) -    end (  Lmatches ) [  i ] -  1L   jj -   which (    0L =  ngaps undefined   ngaps =  max.ngaps )   ans_start -   c (  ans_start ,   rep.int (    start (  Lmatches ) [  i ] ,   length (  jj ) ) )   ans_end -   c (  ans_end ,    end (  Rmatches ) [  jj ] ) } } }   ans_width -    ans_end -  ans_start +  1L   unsafe.newXStringViews (  subject ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XString",
    "parameters": "function ( Lpattern , Rpattern , max.gaplength , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_end -   integer (  0 )   Lmatches -   matchPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , with.indels =  with.Lindels , fixed =  Lfixed )  if (    length (  Lmatches ) !=  0L )  {   Rmatches -   matchPattern (  Rpattern ,  subject , max.mismatch =  max.Rmismatch , with.indels =  with.Rindels , fixed =  Rfixed )  if (    length (  Rmatches ) !=  0L )  {  for  ( i in   seq_len (   length (  Lmatches ) ) )  {   gaplength -     start (  Rmatches ) -    end (  Lmatches ) [  i ] -  1L   jj -   which (    0L =  gaplength undefined   gaplength =  max.gaplength )   ans_start -   c (  ans_start ,   rep.int (    start (  Lmatches ) [  i ] ,   length (  jj ) ) )   ans_end -   c (  ans_end ,    end (  Rmatches ) [  jj ] ) } } }   ans_width -    ans_end -  ans_start +  1L   unsafe.newXStringViews (  subject ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  }
}

6.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XStringViews",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_width -   integer (  0 )  for  ( i in   seq_len (   length (  subject ) ) )  {   pm -   matchLRPatterns (  Lpattern ,  Rpattern ,  max.ngaps ,   subject [[  i ] ] , max.Lmismatch =  max.Lmismatch , max.Rmismatch =  max.Rmismatch , with.Lindels =  with.Lindels , with.Rindels =  with.Rindels , Lfixed =  Lfixed , Rfixed =  Rfixed )   offset -     start (  subject ) [  i ] -  1L   ans_start -   c (  ans_start ,   offset +   start (  pm ) )   ans_width -   c (  ans_width ,   width (  pm ) ) }   unsafe.newXStringViews (   subject (  subject ) ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "XStringViews",
    "parameters": "function ( Lpattern , Rpattern , max.gaplength , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "{   ans_start -   ans_width -   integer (  0 )   subject -   trim (  subject )   Lcounts -   vcountPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , with.indels =  with.Lindels , fixed =  Lfixed )   candidates -   which (   Lcounts undefined  0L )  if (    length (  candidates ) !=  0L )  {   subject -   subject [  candidates ]   Lcounts -   Lcounts [  candidates ]   Lmatches -   matchPattern (  Lpattern ,  subject , max.mismatch =  max.Lmismatch , with.indels =  with.Lindels , fixed =  Lfixed )   Rranges -   IRanges ( start =    end (  Lmatches ) +  1L , width =   max.gaplength +   nchar (  Rpattern ) )   Rranges -   pintersect (  Rranges ,   rep (   as (  subject ,  \"IRanges\" ) ,  Lcounts ) )   Rsubject -   as (   Views (   subject (  subject ) ,  Rranges ) ,  \"XStringSet\" )   Rmatches -   vmatchPattern (  Rpattern ,  Rsubject , max.mismatch =  max.Rmismatch , with.indels =  with.Rindels , fixed =  Rfixed )   Rcounts -   countIndex (  Rmatches )   Roffset -   unlist (   endIndex (  Rmatches ) , use.names =  FALSE )  if (    length (  Roffset ) !=  0L )  {   ans_start -   rep.int (   start (  Lmatches ) ,  Rcounts )   ans_width -    rep.int (   width (  Lmatches ) ,  Rcounts ) +  Roffset } }   unsafe.newXStringViews (   subject (  subject ) ,  ans_start ,  ans_width ) } ",
    "filename": "matchLRPatterns.txt"
  }
}

7.
{
  "old_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "MaskedXString",
    "parameters": "function ( Lpattern , Rpattern , max.ngaps , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "matchLRPatterns ( Lpattern , Rpattern , max.ngaps , toXStringViewsOrXString ( subject ) , max.Lmismatch = max.Lmismatch , max.Rmismatch = max.Rmismatch , with.Lindels = with.Lindels , with.Rindels = with.Rindels , Lfixed = Lfixed , Rfixed = Rfixed )",
    "filename": "matchLRPatterns.txt"
  },
  "new_function": {
    "name": "matchLRPatterns",
    "representation": "matchLRPatterns",
    "signature": "MaskedXString",
    "parameters": "function ( Lpattern , Rpattern , max.gaplength , subject , max.Lmismatch = 0 , max.Rmismatch = 0 , with.Lindels = FALSE , with.Rindels = FALSE , Lfixed = TRUE , Rfixed = TRUE )",
    "body": "matchLRPatterns ( Lpattern , Rpattern , max.gaplength , toXStringViewsOrXString ( subject ) , max.Lmismatch = max.Lmismatch , max.Rmismatch = max.Rmismatch , with.Lindels = with.Lindels , with.Rindels = with.Rindels , Lfixed = Lfixed , Rfixed = Rfixed )",
    "filename": "matchLRPatterns.txt"
  }
}

8.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

9.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   pattern -   normargPattern (  pattern ,   subject @ subject )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   subject @ subject )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "BOC_SubjectString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "{   pattern -   normargPattern (  pattern ,   subject @ subject )   pattern_length -   nchar (  pattern )  if (   pattern_length !=   subject @ pattern_length )   stop (  \"subject was preprocessed for patterns of length \" ,   subject @ pattern_length )   max.mismatch -   normargMaxMismatch (  max.mismatch )  if (  !   missing (  fixed ) )  {   fixed -   normargFixed (  fixed ,   subject @ subject )  if (  !   all (  fixed ) )   stop (  \"only 'fixed=TRUE' can be used with a subject of class \" ,   class (  subject ) ) }  if (   max.mismatch ==  0 )   C_ans -   .match.BOC.exact (  pattern ,  subject , count.only =  FALSE ) else   C_ans -   .match.BOC.inexact (  pattern ,  subject ,  max.mismatch , count.only =  FALSE )   unsafe.newXStringViews (   subject @ subject ,   start (  C_ans ) ,   width (  C_ans ) ) } ",
    "filename": "matchPattern.BOC.txt"
  }
}

10.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XString.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm )",
    "filename": "matchPattern.txt"
  }
}

11.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XString.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm )",
    "filename": "matchPattern.txt"
  }
}

12.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vmatchPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use vmatchPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

13.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringViews.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm )",
    "filename": "matchPattern.txt"
  }
}

14.
{
  "old_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "matchPattern",
    "representation": "matchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "matchPattern ( pattern , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm )",
    "filename": "matchPattern.txt"
  }
}

15.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "BOC2_SubjectString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "{   .matchPattern.BOC2 (  pattern ,  subject ,  max.mismatch ,  fixed , count.only =  TRUE ) } ",
    "filename": "matchPattern.BOC2.txt"
  }
}

16.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XString.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

17.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XString.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XString.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

18.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use vcountPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use vcountPattern() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

19.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringViews.matchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringViews.matchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

20.
{
  "old_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "countPattern",
    "representation": "countPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "countPattern ( pattern , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm )",
    "filename": "matchPattern.txt"
  }
}

21.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm )",
    "filename": "matchPattern.txt"
  }
}

22.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use matchPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

23.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm )",
    "filename": "matchPattern.txt"
  }
}

24.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"XStringViews objects are not supported yet, sorry\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"XStringViews objects are not supported yet, sorry\" )",
    "filename": "matchPattern.txt"
  }
}

25.
{
  "old_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use matchPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vmatchPattern",
    "representation": "vmatchPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use matchPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

26.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "character",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

27.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use countPattern() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

28.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0L , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , algorithm , max.mismatch , min.mismatch , with.indels , fixed , count.only = TRUE )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringSet",
    "parameters": "function ( pattern , subject , max.mismatch = 0L , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": ".XStringSet.vmatchPattern ( pattern , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , count.only = TRUE )",
    "filename": "matchPattern.txt"
  }
}

29.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "vcountPattern ( pattern , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "XStringViews",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "vcountPattern ( pattern , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm )",
    "filename": "matchPattern.txt"
  }
}

30.
{
  "old_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE )",
    "body": "stop ( \"please use countPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  },
  "new_function": {
    "name": "vcountPattern",
    "representation": "vcountPattern",
    "signature": "MaskedXString",
    "parameters": "function ( pattern , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" )",
    "body": "stop ( \"please use countPattern() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPattern.txt"
  }
}

31.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  }
}

32.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

33.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  }
}

34.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

35.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

36.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

37.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

38.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

39.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

40.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  }
}

41.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

42.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

43.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

44.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , collapse , weight , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , collapse , weight , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

45.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

46.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

47.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

48.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , algorithm , max.mismatch , min.mismatch , fixed , 0L , 1L , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , 0L , 1L , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

49.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "vwhichPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , algorithm = algorithm , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "vwhichPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

50.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , algorithm = \"auto\" , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

51.
{
  "old_function": {
    "name": "writeFASTA",
    "representation": "writeFASTA",
    "parameters": "function ( x , file = \"\" , append = FALSE , width = 80 )",
    "body": "{  if (  !   isTRUEorFALSE (  append ) )   stop (  \"'append' must be TRUE or FALSE\" )  if (   isSingleString (  file ) )  {  if (   file ==  \"\" )  {   file -   stdout ( ) } else  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  if (   inherits (  file ,  \"connection\" ) )  {  if (  !   isOpen (  file ) )  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  {   stop (  \"'file' must be a single string or connection\" ) }  if (  !   isSingleNumber (  width ) )   stop (  \"'width' must be an integer )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   width undefined  1L )   stop (  \"'width' must be an integer )  for  ( rec in  x )  {   cat (  \" ,   rec $ desc ,  \"\\n\" , file =  file , sep =  \"\" )   nlines -     nchar (   rec $ seq ) %/%  width +  1L  for  ( i in   seq_len (  nlines ) )  {   start -    (   i -  1L ) *  width +  1L   stop -    start +  width -  1L  if (   stop undefined   nchar (   rec $ seq ) )   stop -   nchar (   rec $ seq )   line -   substr (   rec $ seq ,  start ,  stop )   cat (  line ,  \"\\n\" , file =  file , sep =  \"\" ) } } } ",
    "filename": "readFASTA.txt"
  },
  "new_function": {
    "name": "writeFASTA",
    "representation": "writeFASTA",
    "parameters": "function ( x , file = \"\" , desc = NULL , append = FALSE , width = 80 )",
    "body": "{  if (  !   isTRUEorFALSE (  append ) )   stop (  \"'append' must be TRUE or FALSE\" )  if (   isSingleString (  file ) )  {  if (   file ==  \"\" )  {   file -   stdout ( ) } else  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  if (   inherits (  file ,  \"connection\" ) )  {  if (  !   isOpen (  file ) )  {   file -   file (  file ,   ifelse (  append ,  \"a\" ,  \"w\" ) )   on.exit (   close (  file ) ) } } else  {   stop (  \"'file' must be a single string or connection\" ) }  if (  !   isSingleNumber (  width ) )   stop (  \"'width' must be an integer )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   width undefined  1L )   stop (  \"'width' must be an integer )   writeBString -  function ( bstring )  {  if (    length (  bstring ) ==  0L )   return ( )   nlines -    (    length (  bstring ) -  1L ) %/%  width +  1L   lineIdx -   seq_len (  nlines )   start -    (   lineIdx -  1L ) *  width +  1L   end -    start +  width -  1L  if (    end [  nlines ] undefined   length (  bstring ) )    end [  nlines ] -   length (  bstring )   bigstring -   paste (   as.character (   Views (  bstring , start =  start , end =  end ) ) , collapse =  \"\\n\" )   cat (  bigstring ,  \"\\n\" , file =  file , sep =  \"\" ) }  if (   is.null (  desc ) )  {  for  ( rec in  x )  {   cat (  \" ,   rec $ desc ,  \"\\n\" , file =  file , sep =  \"\" )   writeBString (   BString (   rec $ seq ) ) } } else  {  if (  !   is.character (  desc ) )   stop (  \"when specified, 'desc' must be a character vector\" )  if (    length (  desc ) undefined   length (  x ) )   stop (  \"'desc' is longer than the number of sequences in 'x'\" )  for  ( i in   seq_len (   length (  desc ) ) )  {   cat (  \" ,   desc [  i ] ,  \"\\n\" , file =  file , sep =  \"\" )   xi -   x [[  i ] ]  if (   is.list (  xi ) )   xi -   xi $ seq   writeBString (   BString (  xi ) ) } } } ",
    "filename": "readFASTA.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_6 biostrings_release_2_7

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_6 biostrings_release_2_7",
    "desc_release_old": "2.16.9",
    "desc_release_new": "2.18.4",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 18,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 38,
    "total_count": 38
}

##########
Functions Removed
##########



##########
Functions Added
##########

letterFrequency
DNAMultipleAlignment
RNAMultipleAlignment
AAMultipleAlignment
rowmask
rowmask<-
colmask
colmask<-
maskGaps
maskednrow
maskedncol
maskeddim
read.DNAMultipleAlignment
read.RNAMultipleAlignment
read.AAMultipleAlignment
consensusViews
write.phylip
detail


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL , baseOnly = FALSE , gapCode = \"-\" , endgapCode = \"-\" )",
    "body": "{  if (   !   identical (  shift ,  0L ) ||  !   identical (  width ,  NULL ) )   stop (  \"\\\"consensusMatrix\\\" method for PairwiseAlignedFixedSubject objects \" ,  \"doesn't support the 'shift' and 'width' arguments\" )   consensusMatrix (   aligned (  x , gapCode =  gapCode , endgapCode =  endgapCode ) , as.prob =  as.prob , freq =  freq , baseOnly =  baseOnly ) } ",
    "filename": "align-utils.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "PairwiseAlignedFixedSubject",
    "parameters": "function ( x , as.prob = FALSE , shift = 0L , width = NULL , baseOnly = FALSE , gapCode = \"-\" , endgapCode = \"-\" )",
    "body": "{  if (   !   identical (  shift ,  0L ) ||  !   identical (  width ,  NULL ) )   stop (  \"\\\"consensusMatrix\\\" method for PairwiseAlignedFixedSubject objects \" ,  \"doesn't support the 'shift' and 'width' arguments\" )   consensusMatrix (   aligned (  x , gapCode =  gapCode , endgapCode =  endgapCode ) , as.prob =  as.prob , baseOnly =  baseOnly ) } ",
    "filename": "align-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "character",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( x ) , as.prob = as.prob , freq = freq , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "character",
    "parameters": "function ( x , as.prob = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( x ) , as.prob = as.prob , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  }
}

2.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "matrix",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( apply ( x , 1 , paste , collapse = \"\" ) ) , as.prob = as.prob , freq = freq , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "matrix",
    "parameters": "function ( x , as.prob = FALSE , shift = 0L , width = NULL )",
    "body": "consensusMatrix ( BStringSet ( apply ( x , 1 , paste , collapse = \"\" ) ) , as.prob = as.prob , shift = shift , width = width )",
    "filename": "letterFrequency.txt"
  }
}

3.
{
  "old_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "XStringSet",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , shift = 0L , width = NULL , baseOnly = FALSE )",
    "body": "{  if (  !   is.integer (  shift ) )   shift -   as.integer (  shift )  if (     length (  x ) !=  0 undefined    length (  shift ) undefined   length (  x ) )   stop (  \"'shift' has more elements than 'x'\" )  if (  !   is.null (  width ) )  {  if (   !   isSingleNumber (  width ) ||   width undefined  0 )   stop (  \"'width' must be NULL or a single non-negative integer\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width ) }   codes -   xscodes (  x , baseOnly =  baseOnly )  if (   is.null (   names (  codes ) ) )  {    names (  codes ) -   intToUtf8 (  codes , multiple =  TRUE )   removeUnused -  TRUE } else  {   removeUnused -  FALSE }   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"consensusMatrix\" )   ans -   .Call (  \"XStringSet_consensus_matrix\" ,  x ,  shift ,  width ,  baseOnly ,  codes , PACKAGE =  \"Biostrings\" )  if (  removeUnused )  {   ans -   ans [    rowSums (  ans ) undefined  0 , , drop =  FALSE ] }  if (  as.prob )  {   col_sums -   colSums (  ans )    col_sums [   col_sums ==  0 ] -  1 # to avoid division by 0   ans -   ans /   rep (  col_sums , each =   nrow (  ans ) ) }  ans } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "consensusMatrix",
    "representation": "consensusMatrix",
    "signature": "XStringSet",
    "parameters": "function ( x , as.prob = FALSE , shift = 0L , width = NULL , baseOnly = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )  if (  !   is.integer (  shift ) )   shift -   as.integer (  shift )  if (     length (  x ) !=  0 undefined    length (  shift ) undefined   length (  x ) )   stop (  \"'shift' has more elements than 'x'\" )  if (  !   is.null (  width ) )  {  if (   !   isSingleNumber (  width ) ||   width undefined  0 )   stop (  \"'width' must be NULL or a single non-negative integer\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width ) }   codes -   xscodes (  x , baseOnly =  baseOnly )  if (   is.null (   names (  codes ) ) )  {    names (  codes ) -   intToUtf8 (  codes , multiple =  TRUE )   removeUnused -  TRUE } else  {   removeUnused -  FALSE }   ans -   .Call (  \"XStringSet_consensus_matrix\" ,  x ,  shift ,  width ,  baseOnly ,  codes , PACKAGE =  \"Biostrings\" )  if (  removeUnused )  {   ans -   ans [    rowSums (  ans ) undefined  0 , , drop =  FALSE ] }  if (  as.prob )  {   col_sums -   colSums (  ans )    col_sums [   col_sums ==  0 ] -  1 # to avoid division by 0   ans -   ans /   rep (  col_sums , each =   nrow (  ans ) ) }  ans } ",
    "filename": "letterFrequency.txt"
  }
}

4.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "XString",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE )",
    "body": ".XString.letter_frequency ( x , as.prob , freq )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "XString",
    "parameters": "function ( x , as.prob = FALSE )",
    "body": ".XString.letter_frequency ( x , as.prob )",
    "filename": "letterFrequency.txt"
  }
}

5.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAString",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , baseOnly = FALSE )",
    "body": ".XString.code_frequency ( x , as.prob , freq , baseOnly )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAString",
    "parameters": "function ( x , as.prob = FALSE , baseOnly = FALSE )",
    "body": ".XString.code_frequency ( x , as.prob , baseOnly )",
    "filename": "letterFrequency.txt"
  }
}

6.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAString",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , baseOnly = FALSE )",
    "body": ".XString.code_frequency ( x , as.prob , freq , baseOnly )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAString",
    "parameters": "function ( x , as.prob = FALSE , baseOnly = FALSE )",
    "body": ".XString.code_frequency ( x , as.prob , baseOnly )",
    "filename": "letterFrequency.txt"
  }
}

7.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , collapse = FALSE )",
    "body": ".XStringSet.letter_frequency ( x , as.prob , freq , collapse )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , as.prob = FALSE , collapse = FALSE )",
    "body": ".XStringSet.letter_frequency ( x , as.prob , collapse )",
    "filename": "letterFrequency.txt"
  }
}

8.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAStringSet",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": ".XStringSet.code_frequency ( x , as.prob , freq , collapse , baseOnly )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "DNAStringSet",
    "parameters": "function ( x , as.prob = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": ".XStringSet.code_frequency ( x , as.prob , collapse , baseOnly )",
    "filename": "letterFrequency.txt"
  }
}

9.
{
  "old_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAStringSet",
    "parameters": "function ( x , as.prob = FALSE , freq = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": ".XStringSet.code_frequency ( x , as.prob , freq , collapse , baseOnly )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "alphabetFrequency",
    "representation": "alphabetFrequency",
    "signature": "RNAStringSet",
    "parameters": "function ( x , as.prob = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": ".XStringSet.code_frequency ( x , as.prob , collapse , baseOnly )",
    "filename": "letterFrequency.txt"
  }
}

10.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , as.prob = FALSE , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"oligonucleotideFrequency\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XString_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XString_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

11.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , as.prob = FALSE , freq = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"oligonucleotideFrequency\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )   width -   .normargWidth (  width )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

12.
{
  "old_function": {
    "name": "oligonucleotideTransitions",
    "representation": "oligonucleotideTransitions",
    "parameters": "function ( x , left = 1 , right = 1 , as.prob = FALSE , freq = FALSE )",
    "body": "{   freqs -   oligonucleotideFrequency (  x , width =   left +  right , as.prob =  as.prob , freq =  freq )   transitions -   matrix (  freqs , nrow =   4 ^  left , ncol =   4 ^  right , byrow =  TRUE , dimnames =   list (   unique (   substring (   names (  freqs ) ,  1 ,  left ) ) ,   unique (   substring (   names (  freqs ) ,   left +  1 ,   left +  right ) ) ) )  if (  as.prob )   transitions -   transitions /   rowSums (  transitions )  transitions } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideTransitions",
    "representation": "oligonucleotideTransitions",
    "parameters": "function ( x , left = 1 , right = 1 , as.prob = FALSE )",
    "body": "{   freqs -   oligonucleotideFrequency (  x , width =   left +  right , as.prob =  as.prob )   transitions -   matrix (  freqs , nrow =   4 ^  left , ncol =   4 ^  right , byrow =  TRUE , dimnames =   list (   unique (   substring (   names (  freqs ) ,  1 ,  left ) ) ,   unique (   substring (   names (  freqs ) ,   left +  1 ,   left +  right ) ) ) )  if (  as.prob )   transitions -   transitions /   rowSums (  transitions )  transitions } ",
    "filename": "letterFrequency.txt"
  }
}

13.
{
  "old_function": {
    "name": "nucleotideFrequencyAt",
    "representation": "nucleotideFrequencyAt",
    "signature": "XStringSet",
    "parameters": "function ( x , at , as.prob = FALSE , freq = FALSE , as.array = TRUE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )  if (  !   is.integer (  at ) )   at -   as.integer (  at )   as.prob -   .normargAsProb (  as.prob ,  freq ,  \"nucleotideFrequencyAt\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_nucleotide_frequency_at\" ,  x ,  at ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "nucleotideFrequencyAt",
    "representation": "nucleotideFrequencyAt",
    "signature": "XStringSet",
    "parameters": "function ( x , at , as.prob = FALSE , as.array = TRUE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    xsbasetype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must be of DNA or RNA base type\" )  if (  !   is.numeric (  at ) )   stop (  \"'at' must be a vector of integers\" )  if (  !   is.integer (  at ) )   at -   as.integer (  at )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call (  \"XStringSet_nucleotide_frequency_at\" ,  x ,  at ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

14.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  }
}

15.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vmatchPDict() when 'subject' is an XStringSet \" , \"object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

16.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose )",
    "filename": "matchPDict.txt"
  }
}

17.
{
  "old_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "matchPDict",
    "representation": "matchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "matchPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

18.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

19.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vcountPDict() when 'subject' is an XStringSet \" , \"object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

20.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

21.
{
  "old_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "countPDict",
    "representation": "countPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "countPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

22.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

23.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vwhichPDict() when 'subject' is an XStringSet object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use vwhichPDict() when 'subject' is an XStringSet \" , \"object (multiple sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

24.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".matchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

25.
{
  "old_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "whichPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "whichPDict",
    "representation": "whichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "whichPDict ( pdict , toXStringViewsOrXString ( subject ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

26.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "ANY",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"vmatchPDict() is not ready yet, sorry\" )",
    "filename": "matchPDict.txt"
  }
}

27.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is an XString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

28.
{
  "old_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vmatchPDict",
    "representation": "vmatchPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use matchPDict() when 'subject' is a MaskedXString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

29.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is an XString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

30.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , collapse , weight , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , collapse , weight , verbose , matches.as = \"MATCHES_AS_COUNTS\" )",
    "filename": "matchPDict.txt"
  }
}

31.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "vcountPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm , collapse = collapse , weight = weight , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

32.
{
  "old_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vcountPDict",
    "representation": "vcountPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , collapse = FALSE , weight = 1L , verbose = FALSE )",
    "body": "stop ( \"please use countPDict() when 'subject' is a MaskedXString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

33.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is an XString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is an XString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

34.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , fixed , algorithm , 0L , 1L , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringSet",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": ".vmatchPDict ( pdict , subject , max.mismatch , min.mismatch , with.indels , fixed , algorithm , 0L , 1L , verbose , matches.as = \"MATCHES_AS_WHICH\" )",
    "filename": "matchPDict.txt"
  }
}

35.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "vwhichPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "XStringViews",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "vwhichPDict ( pdict , XStringViewsToSet ( subject , FALSE , verbose = FALSE ) , max.mismatch = max.mismatch , min.mismatch = min.mismatch , with.indels = with.indels , fixed = fixed , algorithm = algorithm , verbose = verbose )",
    "filename": "matchPDict.txt"
  }
}

36.
{
  "old_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is a MaskedXString object (single sequence)\" )",
    "filename": "matchPDict.txt"
  },
  "new_function": {
    "name": "vwhichPDict",
    "representation": "vwhichPDict",
    "signature": "MaskedXString",
    "parameters": "function ( pdict , subject , max.mismatch = 0 , min.mismatch = 0 , with.indels = FALSE , fixed = TRUE , algorithm = \"auto\" , verbose = FALSE )",
    "body": "stop ( \"please use whichPDict() when 'subject' is a MaskedXString \" , \"object (single sequence)\" )",
    "filename": "matchPDict.txt"
  }
}

37.
{
  "old_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( filepath , use.descs = TRUE )",
    "body": "{   filepath -   .normargFilepath (  filepath )   use.descs -   normargUseNames (  use.descs )   on.exit (   .Call (  \"io_cleanup\" , PACKAGE =  \"Biostrings\" ) )   .Call (  \"fasta_info\" ,  filepath ,  use.descs , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( filepath , nrec = - 1L , skip = 0L , use.names = TRUE )",
    "body": "{   efp_list -   .openInputFiles (  filepath )   on.exit (   .closeFiles (  efp_list ) )   nrec -   .normargNrec (  nrec )   skip -   .normargSkip (  skip )   use.names -   normargUseNames (  use.names )   .Call (  \"fasta_info\" ,  efp_list ,  nrec ,  skip ,  use.names , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_7 biostrings_release_2_8

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_7 biostrings_release_2_8",
    "desc_release_old": "2.18.4",
    "desc_release_new": "2.20.4",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 11,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 2,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 3,
    "total_count": 14
}

##########
Functions Removed
##########

compact
transcriptWidths
extractTranscripts
transcriptLocs2refLocs
FASTArecordsToBStringViews
read.BStringViews
write.BStringViews
subBString
consmat
matchDNAPattern
as.complex


##########
Functions Added
##########

get_xsbasetypes_conversion_lookup


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "substr",
    "representation": "substr",
    "signature": "XString",
    "parameters": "function ( x , start = NA , stop = NA )",
    "body": "subseq ( x , start = start , end = stop )",
    "filename": "subXString.txt"
  },
  "new_function": {
    "name": "substr",
    "representation": "substr",
    "signature": "XString",
    "parameters": "function ( x , start , stop )",
    "body": "subseq ( x , start = start , end = stop )",
    "filename": "XString-class.txt"
  }
}

1.
{
  "old_function": {
    "name": "substring",
    "representation": "substring",
    "signature": "XString",
    "parameters": "function ( text , first = NA , last = NA )",
    "body": "subseq ( text , start = first , end = last )",
    "filename": "subXString.txt"
  },
  "new_function": {
    "name": "substring",
    "representation": "substring",
    "signature": "XString",
    "parameters": "function ( text , first , last = 1000000L )",
    "body": "subseq ( text , start = first , end = last )",
    "filename": "XString-class.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "letterFrequency",
    "representation": "letterFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , letters , OR = \"|\" , collapse = FALSE )",
    "body": ".letterFrequency ( x , NA , letters = letters , OR = OR , collapse = collapse )",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "letterFrequency",
    "representation": "letterFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , letters , OR = \"|\" , as.prob = FALSE , collapse = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  collapse ) )   stop (  \"'collapse' must be TRUE or FALSE\" )   ans -   .letterFrequency (  x ,  NA , letters =  letters , OR =  OR , collapse =  collapse )  if (  as.prob )  {   nc -   nchar (  x )  if (  collapse )   nc -   sum (  nc )   ans -   ans /  nc }  ans } ",
    "filename": "letterFrequency.txt"
  }
}

1.
{
  "old_function": {
    "name": "substr",
    "representation": "substr",
    "signature": "XString",
    "parameters": "function ( x , start = NA , stop = NA )",
    "body": "subseq ( x , start = start , end = stop )",
    "filename": "subXString.txt"
  },
  "new_function": {
    "name": "substr",
    "representation": "substr",
    "signature": "XString",
    "parameters": "function ( x , start , stop )",
    "body": "subseq ( x , start = start , end = stop )",
    "filename": "XString-class.txt"
  }
}

2.
{
  "old_function": {
    "name": "substring",
    "representation": "substring",
    "signature": "XString",
    "parameters": "function ( text , first = NA , last = NA )",
    "body": "subseq ( text , start = first , end = last )",
    "filename": "subXString.txt"
  },
  "new_function": {
    "name": "substring",
    "representation": "substring",
    "signature": "XString",
    "parameters": "function ( text , first , last = 1000000L )",
    "body": "subseq ( text , start = first , end = last )",
    "filename": "XString-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_8 biostrings_release_2_9

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_8 biostrings_release_2_9",
    "desc_release_old": "2.20.4",
    "desc_release_new": "2.22.0",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 23,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 23
}

##########
Functions Removed
##########

unsplit.list.of.XStringSet
BStringViews
adjacentViews
strrev
FASTArecordsToCharacter
CharacterToFASTArecords
FASTArecordsToXStringViews
XStringSetToFASTArecords
read.XStringViews
write.XStringViews
subXString
replaceLetterAtLoc
nmismatchStartingAt
nmismatchEndingAt
isMatching
PWMscore
basecontent
countbases
complementSeq
reverseSeq
revcompDNA
revcompRNA
ls


##########
Functions Added
##########

getSeq


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_9 biostrings_release_2_11

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_9 biostrings_release_2_11",
    "desc_release_old": "2.22.0",
    "desc_release_new": "2.26.3",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 9,
    "function_additions": 19,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 10
}

##########
Functions Removed
##########

xsbasetype
xsbasetype<-
get_xsbasetypes_conversion_lookup
XStringViews
WCPscoreStartingAt
matchWCP
countWCP
[[<-
unique


##########
Functions Added
##########

seqtype
seqtype<-
get_seqtype_conversion_lookup
DNAStringSetList
readBStringSet
readDNAStringSet
readRNAStringSet
readAAStringSet
writeXStringSet
saveXStringSet
IlluminaQuality
PairwiseAlignments
PairwiseAlignmentsSingleSubject
writePairwiseAlignments
readDNAMultipleAlignment
readRNAMultipleAlignment
readAAMultipleAlignment
splitAsListReturnedClass
compare


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "as.matrix",
    "representation": "as.matrix",
    "signature": "XStringViews",
    "parameters": "function ( x , mode = \"integer\" , use.names = TRUE , check.limits = TRUE )",
    "body": "{  if (    !   is.character (  mode ) ||    length (  mode ) !=  1 ||  !  (   mode %in%   c (  \"integer\" ,  \"character\" ) ) )   stop (  \"'mode' must be either \\\"integer\\\" or \\\"character\\\"\" )   use.names -   normargUseNames (  use.names )  if (   mode ==  \"integer\" )   return (   callNextMethod ( ) )   nrow -   length (  x )  if (   nrow ==  0 )   stop (  \"'x' must contain at least 1 view\" )   widths -   width (  x )   ncol -   widths [  1 ]  if (  !   all (   widths ==  ncol ) )   stop (  \"'x' views are not equal-width\" )   y -   as.character (  x , use.names =  FALSE , check.limits =  check.limits )   y -   unlist (   strsplit (  y ,  NULL ) , recursive =  FALSE , use.names =  FALSE )   m -   matrix (  y , nrow =  nrow , byrow =  TRUE )  if (  use.names )    rownames (  m ) -   names (  x )  m } ",
    "filename": "XStringViews-class.txt"
  },
  "new_function": {
    "name": "as.matrix",
    "representation": "as.matrix",
    "signature": "XStringViews",
    "parameters": "function ( x , use.names = TRUE )",
    "body": "{ ## TODO: Supress this warning in BioC 2.12.   msg -   c (  \"as.matrix() on an XStringViews object 'x' has changed \" ,  \"behavior: now the\\n  views in 'x' must be of equal width \" ,  \"and each view is converted into a row of\\n\" ,  \"  single characters. To achieve the old behavior, \" ,  \"do 'as.matrix(ranges(x))'.\\n  To supress this warning, do \" ,  \"'suppressWarnings(as.matrix(x))'.\\n  This warning will be \" ,  \"removed in BioC 2.12.\" )   warning (  msg )   y -   fromXStringViewsToStringSet (  x , out.of.limits =  \"error\" , use.names =  use.names )   as.matrix (  y ) } ",
    "filename": "XStringViews-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_11 biostrings_release_2_12

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_11 biostrings_release_2_12",
    "desc_release_old": "2.26.3",
    "desc_release_new": "2.28.0",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 12,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 12
}

##########
Functions Removed
##########

BKeySortedData
DNAKeySortedData
RNAKeySortedData
AAKeySortedData
dataKey
dataTable
BKeySortedDataList
DNAKeySortedDataList
RNAKeySortedDataList
AAKeySortedDataList
readFASTA
writeFASTA


##########
Functions Added
##########

twoWayAlphabetFrequency


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_12 biostrings_release_2_13

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_12 biostrings_release_2_13",
    "desc_release_old": "2.28.0",
    "desc_release_new": "2.30.1",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 11,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 15
}

##########
Functions Removed
##########

read.BStringSet
read.DNAStringSet
read.RNAStringSet
read.AAStringSet
write.XStringSet
save.XStringSet
PairwiseAlignedXStringSet
PairwiseAlignedFixedSubject
read.DNAMultipleAlignment
read.RNAMultipleAlignment
read.AAMultipleAlignment


##########
Functions Added
##########

AAStringSetList
extractAt
replaceAt
padAndClip
stackStrings
encoding


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    seqtype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must contain sequences of type DNA or RNA\" )   width -   .normargWidth (  width )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call2 (  \"XString_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XString",
    "parameters": "function ( x , width , step = 1 , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE )",
    "body": "{  if (  !  (    seqtype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must contain sequences of type DNA or RNA\" )   width -   .normargWidth (  width )   step -   .normargStep (  step )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call2 (  \"XString_oligo_frequency\" ,  x ,  width ,  step ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

1.
{
  "old_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    seqtype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must contain sequences of type DNA or RNA\" )   width -   .normargWidth (  width )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call2 (  \"XStringSet_oligo_frequency\" ,  x ,  width ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "oligonucleotideFrequency",
    "representation": "oligonucleotideFrequency",
    "signature": "XStringSet",
    "parameters": "function ( x , width , step = 1 , as.prob = FALSE , as.array = FALSE , fast.moving.side = \"right\" , with.labels = TRUE , simplify.as = \"matrix\" )",
    "body": "{  if (  !  (    seqtype (  x ) %in%   c (  \"DNA\" ,  \"RNA\" ) ) )   stop (  \"'x' must contain sequences of type DNA or RNA\" )   width -   .normargWidth (  width )   step -   .normargStep (  step )  if (  !   isTRUEorFALSE (  as.prob ) )   stop (  \"'as.prob' must be TRUE or FALSE\" )   as.array -   .normargAsArray (  as.array )   fast.moving.side -   .normargFastMovingSide (  fast.moving.side ,  as.array )   with.labels -   .normargWithLabels (  with.labels )   simplify.as -   .normargSimplifyAs (  simplify.as ,  as.array )   base_codes -   xscodes (  x , baseOnly =  TRUE )   .Call2 (  \"XStringSet_oligo_frequency\" ,  x ,  width ,  step ,  as.prob ,  as.array ,  fast.moving.side ,  with.labels ,  simplify.as ,  base_codes , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "letterFrequency.txt"
  }
}

2.
{
  "old_function": {
    "name": "twoWayAlphabetFrequency",
    "representation": "twoWayAlphabetFrequency",
    "signature": "c (  XString ,  XStringSet )",
    "parameters": "function ( x , y , as.prob = FALSE , baseOnly = FALSE )",
    "body": "{   x -   rep (   as (  x ,  \"XStringSet\" ) ,   length (  y ) )   .XString.two_way_code_frequency (  x ,  y ,  as.prob ,  baseOnly ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "twoWayAlphabetFrequency",
    "representation": "twoWayAlphabetFrequency",
    "signature": "c (  XString ,  XStringSet )",
    "parameters": "function ( x , y , as.prob = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": "{   x -   rep (   as (  x ,  \"XStringSet\" ) ,   length (  y ) )   .XStringSet.two_way_code_frequency (  x ,  y ,  as.prob ,  collapse ,  baseOnly ) } ",
    "filename": "letterFrequency.txt"
  }
}

3.
{
  "old_function": {
    "name": "twoWayAlphabetFrequency",
    "representation": "twoWayAlphabetFrequency",
    "signature": "c (  XStringSet ,  XString )",
    "parameters": "function ( x , y , as.prob = FALSE , baseOnly = FALSE )",
    "body": "{   y -   rep (   as (  y ,  \"XStringSet\" ) ,   length (  x ) )   .XString.two_way_code_frequency (  x ,  y ,  as.prob ,  baseOnly ) } ",
    "filename": "letterFrequency.txt"
  },
  "new_function": {
    "name": "twoWayAlphabetFrequency",
    "representation": "twoWayAlphabetFrequency",
    "signature": "c (  XStringSet ,  XString )",
    "parameters": "function ( x , y , as.prob = FALSE , collapse = FALSE , baseOnly = FALSE )",
    "body": "{   y -   rep (   as (  y ,  \"XStringSet\" ) ,   length (  x ) )   .XStringSet.two_way_code_frequency (  x ,  y ,  as.prob ,  collapse ,  baseOnly ) } ",
    "filename": "letterFrequency.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_13 biostrings_release_2_14

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_13 biostrings_release_2_14",
    "desc_release_old": "2.30.1",
    "desc_release_new": "2.32.1",
    "old_release_number": 17,
    "new_release_number": 18,
    "function_removals": 0,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 5,
    "total_count": 5
}

##########
Functions Removed
##########



##########
Functions Added
##########

AA_STANDARD
AA_PROTEINOGENIC
GENETIC_CODE_TABLE
getGeneticCode
relistToClass
unstrsplit


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( filepath , nrec = - 1L , skip = 0L , use.names = TRUE , seqtype = \"B\" )",
    "body": "{   efp_list -   .openInputFiles (  filepath )   on.exit (   .closeFiles (  efp_list ) )   nrec -   .normargNrec (  nrec )   skip -   .normargSkip (  skip )   use.names -   normargUseNames (  use.names )   seqtype -   match.arg (  seqtype ,   c (  \"B\" ,  \"DNA\" ,  \"RNA\" ,  \"AA\" ) )   lkup -   get_seqtype_conversion_lookup (  \"B\" ,  seqtype )   .Call2 (  \"fasta_info\" ,  efp_list ,  nrec ,  skip ,  use.names ,  lkup , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "fasta.info",
    "representation": "fasta.info",
    "parameters": "function ( filepath , nrec = - 1L , skip = 0L , seek.first.rec = FALSE , use.names = TRUE , seqtype = \"B\" )",
    "body": "{   efp_list -   .open_input_files (  filepath )   on.exit (   .finalize_efp_list (  efp_list ) )   nrec -   .normarg_nrec (  nrec )   skip -   .normarg_skip (  skip )  if (  !   isTRUEorFALSE (  seek.first.rec ) )   stop (  \"'seek.first.rec' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  use.names ) )   stop (  \"'use.names' must be TRUE or FALSE\" )   seqtype -   match.arg (  seqtype ,   c (  \"B\" ,  \"DNA\" ,  \"RNA\" ,  \"AA\" ) )   lkup -   get_seqtype_conversion_lookup (  \"B\" ,  seqtype )   .Call2 (  \"fasta_info\" ,  efp_list ,  nrec ,  skip ,  seek.first.rec ,  use.names ,  lkup , PACKAGE =  \"Biostrings\" ) } ",
    "filename": "XStringSet-io.txt"
  }
}

1.
{
  "old_function": {
    "name": "readBStringSet",
    "representation": "readBStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , use.names = TRUE )",
    "body": ".readXStringSet ( filepath , format , nrec , skip , use.names , \"B\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "readBStringSet",
    "representation": "readBStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , seek.first.rec = FALSE , use.names = TRUE )",
    "body": ".read_XStringSet ( filepath , format , nrec , skip , seek.first.rec , use.names , \"B\" )",
    "filename": "XStringSet-io.txt"
  }
}

2.
{
  "old_function": {
    "name": "readDNAStringSet",
    "representation": "readDNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , use.names = TRUE )",
    "body": ".readXStringSet ( filepath , format , nrec , skip , use.names , \"DNA\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "readDNAStringSet",
    "representation": "readDNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , seek.first.rec = FALSE , use.names = TRUE )",
    "body": ".read_XStringSet ( filepath , format , nrec , skip , seek.first.rec , use.names , \"DNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

3.
{
  "old_function": {
    "name": "readRNAStringSet",
    "representation": "readRNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , use.names = TRUE )",
    "body": ".readXStringSet ( filepath , format , nrec , skip , use.names , \"RNA\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "readRNAStringSet",
    "representation": "readRNAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , seek.first.rec = FALSE , use.names = TRUE )",
    "body": ".read_XStringSet ( filepath , format , nrec , skip , seek.first.rec , use.names , \"RNA\" )",
    "filename": "XStringSet-io.txt"
  }
}

4.
{
  "old_function": {
    "name": "readAAStringSet",
    "representation": "readAAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , use.names = TRUE )",
    "body": ".readXStringSet ( filepath , format , nrec , skip , use.names , \"AA\" )",
    "filename": "XStringSet-io.txt"
  },
  "new_function": {
    "name": "readAAStringSet",
    "representation": "readAAStringSet",
    "parameters": "function ( filepath , format = \"fasta\" , nrec = - 1L , skip = 0L , seek.first.rec = FALSE , use.names = TRUE )",
    "body": ".read_XStringSet ( filepath , format , nrec , skip , seek.first.rec , use.names , \"AA\" )",
    "filename": "XStringSet-io.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_2_14 biostrings_release_3_1

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_2_14 biostrings_release_3_1",
    "desc_release_old": "2.32.1",
    "desc_release_new": "2.36.4",
    "old_release_number": 18,
    "new_release_number": 19,
    "function_removals": 2,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 2
}

##########
Functions Removed
##########

partitioning
splitAsListReturnedClass


##########
Functions Added
##########

BStringSetList
RNAStringSetList
fasta.index
fasta.seqlengths
as.data.frame
subject


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_1 biostrings_release_3_2

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_1 biostrings_release_3_2",
    "desc_release_old": "2.36.4",
    "desc_release_new": "2.38.4",
    "old_release_number": 19,
    "new_release_number": 20,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_2 biostrings_release_3_3

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_2 biostrings_release_3_3",
    "desc_release_old": "2.38.4",
    "desc_release_new": "2.40.2",
    "old_release_number": 20,
    "new_release_number": 21,
    "function_removals": 8,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 8
}

##########
Functions Removed
##########

transcribe
cDNA
dna2rna
rna2dna
countIndex
compare
as.integer
as.numeric


##########
Functions Added
##########

showAsCell
pcompare
as.vector


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_3 biostrings_release_3_4

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_3 biostrings_release_3_4",
    "desc_release_old": "2.40.2",
    "desc_release_new": "2.42.1",
    "old_release_number": 21,
    "new_release_number": 22,
    "function_removals": 5,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 5
}

##########
Functions Removed
##########

fasta.info
findComplementedPalindromes
complementedPalindromeArmLength
complementedPalindromeLeftArm
complementedPalindromeRightArm


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_4 biostrings_release_3_5

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_4 biostrings_release_3_5",
    "desc_release_old": "2.42.1",
    "desc_release_new": "2.44.2",
    "old_release_number": 22,
    "new_release_number": 23,
    "function_removals": 0,
    "function_additions": 3,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

strsplit
parallelSlotNames
parallelVectorNames


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "getGeneticCode",
    "representation": "getGeneticCode",
    "parameters": "function ( id_or_name2 , full.search = FALSE )",
    "body": "{   idx -   .solve.id_or_name2 (  id_or_name2 , full.search =  full.search )   ans -   safeExplode (   GENETIC_CODE_TABLE [  idx ,  \"AAs\" ] )    names (  ans ) -   names (  GENETIC_CODE )  ans } ",
    "filename": "GENETIC_CODE.txt"
  },
  "new_function": {
    "name": "getGeneticCode",
    "representation": "getGeneticCode",
    "parameters": "function ( id_or_name2 = \"1\" , full.search = FALSE , as.data.frame = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  as.data.frame ) )   stop (  \"'as.data.frame' must be TRUE or FALSE\" )   idx -   .solve_id_or_name2 (  id_or_name2 , full.search =  full.search )   ans -   safeExplode (   GENETIC_CODE_TABLE [  idx ,  \"AAs\" ] )   Start -   safeExplode (   GENETIC_CODE_TABLE [  idx ,  \"Starts\" ] )  if (  as.data.frame )  {   ans -   data.frame ( AA =  ans , Start =  Start , stringsAsFactors =  FALSE )    rownames (  ans ) -   names (  GENETIC_CODE )   return (  ans ) }    names (  ans ) -   names (  GENETIC_CODE )   idx -   which (    Start !=  \"-\" undefined   Start !=  ans )   stopifnot (   all (    Start [  idx ] ==  \"M\" ) ) # should never happen    attr (  ans ,  \"alt_init_codons\" ) -    names (  ans ) [  idx ]  ans } ",
    "filename": "GENETIC_CODE.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_5 biostrings_release_3_6

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_5 biostrings_release_3_6",
    "desc_release_old": "2.44.2",
    "desc_release_new": "2.46.0",
    "old_release_number": 23,
    "new_release_number": 24,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_6 biostrings_release_3_7

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_6 biostrings_release_3_7",
    "desc_release_old": "2.46.0",
    "desc_release_new": "2.48.0",
    "old_release_number": 24,
    "new_release_number": 25,
    "function_removals": 2,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 2
}

##########
Functions Removed
##########

append
narrow


##########
Functions Added
##########

fastq.seqlengths
readQualityScaledDNAStringSet
writeQualityScaledXStringSet
alignedPattern
alignedSubject
windows


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_7 biostrings_release_3_8

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_7 biostrings_release_3_8",
    "desc_release_old": "2.48.0",
    "desc_release_new": "2.50.2",
    "old_release_number": 25,
    "new_release_number": 26,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 6,
    "total_count": 6
}

##########
Functions Removed
##########



##########
Functions Added
##########

replaceAmbiguities


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "DNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( DNAStringSet ( x ) , genetic.code = genetic.code , if.fuzzy.codon = if.fuzzy.codon ) [[ 1L ] ]",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "DNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( DNAStringSet ( x ) , genetic.code = genetic.code , no.init.codon = no.init.codon , if.fuzzy.codon = if.fuzzy.codon ) [[ 1L ] ]",
    "filename": "translate.txt"
  }
}

1.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "RNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( RNAStringSet ( x ) , genetic.code = genetic.code , if.fuzzy.codon = if.fuzzy.codon ) [[ 1L ] ]",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "RNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( RNAStringSet ( x ) , genetic.code = genetic.code , no.init.codon = no.init.codon , if.fuzzy.codon = if.fuzzy.codon ) [[ 1L ] ]",
    "filename": "translate.txt"
  }
}

2.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "MaskedDNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( injectHardMask ( x ) , genetic.code = genetic.code , if.fuzzy.codon = if.fuzzy.codon )",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "MaskedDNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( injectHardMask ( x ) , genetic.code = genetic.code , no.init.codon = no.init.codon , if.fuzzy.codon = if.fuzzy.codon )",
    "filename": "translate.txt"
  }
}

3.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "MaskedRNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( injectHardMask ( x ) , genetic.code = genetic.code , if.fuzzy.codon = if.fuzzy.codon )",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "MaskedRNAString",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "translate ( injectHardMask ( x ) , genetic.code = genetic.code , no.init.codon = no.init.codon , if.fuzzy.codon = if.fuzzy.codon )",
    "filename": "translate.txt"
  }
}

4.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "DNAStringSet",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "{   init_genetic_code -   genetic_code -   .normarg_genetic.code (  genetic.code )   alt_init_codons -   attr (  genetic_code ,  \"alt_init_codons\" )    init_genetic_code [  alt_init_codons ] -  \"M\"   if.fuzzy.codon -   .normarg_if.fuzzy.codon (  if.fuzzy.codon )   if.non.ambig -   if.fuzzy.codon [[  1L ] ]   if.ambig -   if.fuzzy.codon [[  2L ] ]  if (    if.non.ambig ==  \"error\" undefined   if.ambig ==  \"error\" )  {   codon_alphabet -  DNA_BASES } else  {   codon_alphabet -   names (  IUPAC_CODE_MAP )   genetic_code -   .make_fuzzy_genetic_code (  genetic_code , keep.ambig.codons =  TRUE )   init_genetic_code -   .make_fuzzy_genetic_code (  init_genetic_code , keep.ambig.codons =  TRUE ) }   lkup -   .make_translation_lkup (  codon_alphabet ,  genetic_code )   init_lkup -   .make_translation_lkup (  codon_alphabet ,  init_genetic_code )   dna_codes -   DNAcodes ( baseOnly =  FALSE )   skip_code -   dna_codes [[  \"+\" ] ]   ans -   .Call2 (  \"DNAStringSet_translate\" ,  x ,  skip_code ,   dna_codes [  codon_alphabet ] ,  lkup ,  init_lkup ,  if.non.ambig ,  if.ambig , PACKAGE =  \"Biostrings\" )    names (  ans ) -   names (  x )  ans } ",
    "replacementFunction": ".translate",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "DNAStringSet",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "{   genetic_code -   .normarg_genetic.code (  genetic.code )  if (  !   isTRUEorFALSE (  no.init.codon ) )   stop (   wmsg (  \"'no.init.codon' must be TRUE or FALSE\" ) )  if (  !  no.init.codon )  {   init_genetic_code -  genetic_code   alt_init_codons -   attr (  genetic_code ,  \"alt_init_codons\" )    init_genetic_code [  alt_init_codons ] -  \"M\" }   if.fuzzy.codon -   .normarg_if.fuzzy.codon (  if.fuzzy.codon )   if.non.ambig -   if.fuzzy.codon [[  1L ] ]   if.ambig -   if.fuzzy.codon [[  2L ] ]  if (    if.non.ambig ==  \"error\" undefined   if.ambig ==  \"error\" )  {   codon_alphabet -  DNA_BASES } else  {   codon_alphabet -   names (  IUPAC_CODE_MAP )   genetic_code -   .make_fuzzy_genetic_code (  genetic_code , keep.ambig.codons =  TRUE )  if (  !  no.init.codon )   init_genetic_code -   .make_fuzzy_genetic_code (  init_genetic_code , keep.ambig.codons =  TRUE ) }   lkup -   .make_translation_lkup (  codon_alphabet ,  genetic_code )  if (  no.init.codon )  {   init_lkup -  lkup } else  {   init_lkup -   .make_translation_lkup (  codon_alphabet ,  init_genetic_code ) }   dna_codes -   DNAcodes ( baseOnly =  FALSE )   skip_code -   dna_codes [[  \"+\" ] ]   ans -   .Call2 (  \"DNAStringSet_translate\" ,  x ,  skip_code ,   dna_codes [  codon_alphabet ] ,  lkup ,  init_lkup ,  if.non.ambig ,  if.ambig , PACKAGE =  \"Biostrings\" )    names (  ans ) -   names (  x )  ans } ",
    "replacementFunction": ".translate",
    "filename": "translate.txt"
  }
}

5.
{
  "old_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "RNAStringSet",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , if.fuzzy.codon = \"error\" )",
    "body": "{   init_genetic_code -   genetic_code -   .normarg_genetic.code (  genetic.code )   alt_init_codons -   attr (  genetic_code ,  \"alt_init_codons\" )    init_genetic_code [  alt_init_codons ] -  \"M\"   if.fuzzy.codon -   .normarg_if.fuzzy.codon (  if.fuzzy.codon )   if.non.ambig -   if.fuzzy.codon [[  1L ] ]   if.ambig -   if.fuzzy.codon [[  2L ] ]  if (    if.non.ambig ==  \"error\" undefined   if.ambig ==  \"error\" )  {   codon_alphabet -  DNA_BASES } else  {   codon_alphabet -   names (  IUPAC_CODE_MAP )   genetic_code -   .make_fuzzy_genetic_code (  genetic_code , keep.ambig.codons =  TRUE )   init_genetic_code -   .make_fuzzy_genetic_code (  init_genetic_code , keep.ambig.codons =  TRUE ) }   lkup -   .make_translation_lkup (  codon_alphabet ,  genetic_code )   init_lkup -   .make_translation_lkup (  codon_alphabet ,  init_genetic_code )   dna_codes -   DNAcodes ( baseOnly =  FALSE )   skip_code -   dna_codes [[  \"+\" ] ]   ans -   .Call2 (  \"DNAStringSet_translate\" ,  x ,  skip_code ,   dna_codes [  codon_alphabet ] ,  lkup ,  init_lkup ,  if.non.ambig ,  if.ambig , PACKAGE =  \"Biostrings\" )    names (  ans ) -   names (  x )  ans } ",
    "replacementFunction": ".translate",
    "filename": "translate.txt"
  },
  "new_function": {
    "name": "translate",
    "representation": "translate",
    "signature": "RNAStringSet",
    "parameters": "function ( x , genetic.code = GENETIC_CODE , no.init.codon = FALSE , if.fuzzy.codon = \"error\" )",
    "body": "{   genetic_code -   .normarg_genetic.code (  genetic.code )  if (  !   isTRUEorFALSE (  no.init.codon ) )   stop (   wmsg (  \"'no.init.codon' must be TRUE or FALSE\" ) )  if (  !  no.init.codon )  {   init_genetic_code -  genetic_code   alt_init_codons -   attr (  genetic_code ,  \"alt_init_codons\" )    init_genetic_code [  alt_init_codons ] -  \"M\" }   if.fuzzy.codon -   .normarg_if.fuzzy.codon (  if.fuzzy.codon )   if.non.ambig -   if.fuzzy.codon [[  1L ] ]   if.ambig -   if.fuzzy.codon [[  2L ] ]  if (    if.non.ambig ==  \"error\" undefined   if.ambig ==  \"error\" )  {   codon_alphabet -  DNA_BASES } else  {   codon_alphabet -   names (  IUPAC_CODE_MAP )   genetic_code -   .make_fuzzy_genetic_code (  genetic_code , keep.ambig.codons =  TRUE )  if (  !  no.init.codon )   init_genetic_code -   .make_fuzzy_genetic_code (  init_genetic_code , keep.ambig.codons =  TRUE ) }   lkup -   .make_translation_lkup (  codon_alphabet ,  genetic_code )  if (  no.init.codon )  {   init_lkup -  lkup } else  {   init_lkup -   .make_translation_lkup (  codon_alphabet ,  init_genetic_code ) }   dna_codes -   DNAcodes ( baseOnly =  FALSE )   skip_code -   dna_codes [[  \"+\" ] ]   ans -   .Call2 (  \"DNAStringSet_translate\" ,  x ,  skip_code ,   dna_codes [  codon_alphabet ] ,  lkup ,  init_lkup ,  if.non.ambig ,  if.ambig , PACKAGE =  \"Biostrings\" )    names (  ans ) -   names (  x )  ans } ",
    "replacementFunction": ".translate",
    "filename": "translate.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_8 biostrings_release_3_9

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_8 biostrings_release_3_9",
    "desc_release_old": "2.50.2",
    "desc_release_new": "2.52.0",
    "old_release_number": 26,
    "new_release_number": 27,
    "function_removals": 0,
    "function_additions": 5,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

xscodes
extract_character_from_XString_by_positions
extract_character_from_XString_by_ranges
make_XString_from_string
make_XStringSet_from_strings


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_9 biostrings_release_3_11

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_9 biostrings_release_3_11",
    "desc_release_old": "2.52.0",
    "desc_release_new": "2.56.0",
    "old_release_number": 27,
    "new_release_number": 28,
    "function_removals": 1,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 1
}

##########
Functions Removed
##########

parallelSlotNames


##########
Functions Added
##########

vertical_slot_names


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_11 biostrings_release_3_12

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_11 biostrings_release_3_12",
    "desc_release_old": "2.56.0",
    "desc_release_new": "2.58.0",
    "old_release_number": 28,
    "new_release_number": 29,
    "function_removals": 1,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 1
}

##########
Functions Removed
##########

vertical_slot_names


##########
Functions Added
##########

parallel_slot_names


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_12 biostrings_release_3_13

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_12 biostrings_release_3_13",
    "desc_release_old": "2.58.0",
    "desc_release_new": "2.60.2",
    "old_release_number": 29,
    "new_release_number": 30,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

seqinfo
seqinfo<-


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_13 biostrings_release_3_14

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_13 biostrings_release_3_14",
    "desc_release_old": "2.60.2",
    "desc_release_new": "2.62.0",
    "old_release_number": 30,
    "new_release_number": 31,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biostrings_release_3_14 biostrings_master

{
    "package": "Biostrings",
    "release_versions": "biostrings_release_3_14 biostrings_master",
    "desc_release_old": "2.62.0",
    "desc_release_new": "2.63.1",
    "old_release_number": 31,
    "new_release_number": 32,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

