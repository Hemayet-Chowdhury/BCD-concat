
###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_1_6 biomart_release_1_7

{
    "package": "biomaRt",
    "release_versions": "biomart_release_1_6 biomart_release_1_7",
    "desc_release_old": "1.0.4",
    "desc_release_new": "1.4.0",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 8,
    "parameter_removals": 0,
    "parameter_additions": 14,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 14,
    "total_count": 14
}

##########
Functions Removed
##########



##########
Functions Added
##########

getINTERPRO
exportFASTA
useMart
listDatasets
useDataset
listAttributes
listFilters
getBM


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( host = \"ensembldb.ensembl.org\" , user = \"anonymous\" , password = \"\" )",
    "body": "{          driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   connection -   dbConnect (  driv , user =  user , host =  host , password =  password ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ;   marts -   c (  \"ensembl_mart_\" ,  \"snp_mart_\" ,  \"sequence_mart_\" ,  \"vega_mart_\" ) ;   databases -   list ( ensembl =  \"\" , snp =  \"\" , sequence =  \"\" , vega =  \"\" ) ; #Search latest releases of marts   martConf -  NULL #one mart vs multiple marts  if (     dim (  res ) [  1 ] undefined  1 )  {  for  ( i in   1 :   length (  marts ) )  {    matches -   grep (   marts [  i ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {       version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;  if (   v undefined  version )  {     latest -  j ;   version -  v ; } }    databases [[  i ] ] -   res [   matches [  latest ] ,  1 ] ;   martConf -   c (  martConf ,  v ) ; } else  {       databases [[  i ] ] -   res [  matches ,  1 ] ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;   martConf -   c (  martConf ,  v ) ; } }  if (  !  (     sum (  martConf ) /  4 ==   martConf [[  1 ] ] ) )  { # mean there is only one new mart    databases $ snp -   databases $ ensembl    databases $ vega -   databases $ ensembl    databases $ sequence -   databases $ ensembl } } else  {  if (     dim (  res ) [  1 ] ==  1 )  {  if (    grep (  \"ensembl\" ,   res [  1 ,  1 ] ) ==  1 )  {    databases $ ensembl -   res [  1 ,  1 ]    databases $ snp -   databases $ ensembl    databases $ vega -   databases $ ensembl    databases $ sequence -   databases $ ensembl } else  {    stop (  \"No Ensembl database found, if you have a local installation, make sure your database follows trhe following naming convention: ensembl_mart_30 where 30 is the release number\" ) ; } } else  {    stop (  \"No biomaRt database found\" ) ; } }   dbDisconnect (  connection ) ;   return (  databases ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , includeHosts = FALSE )",
    "body": "{    if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ) }  if (   missing (  host ) )  {   host -   c (  \"ensembldb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;  if (   v undefined  version )  {     latest -  j ;   version -  v ; } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "martConnect",
    "representation": "martConnect",
    "parameters": "function ( host = \"ensembldb.ensembl.org\" , user = \"anonymous\" , password = \"\" )",
    "body": "{            databases -   listMarts ( host =  host , user =  user , password =  password ) ;   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   dummy -   data.frame (   cbind ( x =  1 , y =   1 :  2 ) )   mart -   new (  \"Mart\" , ensembl =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ ensembl , password =  password ) , vega =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ vega , password =  password ) , sequence =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ sequence , password =  password ) , snp =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ snp , password =  password ) , arrayToSpecies =  dummy ) ;   xref -   getPossibleXrefs (  mart ) ;   affySelect -   grep (  \"affy\" ,   xref [ ,  2 ] ) ;   affyTables -   xref [  affySelect , ] ;    affyTables [ ,  2 ] -   gsub (  \"affy_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;    colnames (  affyTables ) -   c (  'species' ,  'affy array' ) ;    mart @ arrayToSpecies -   as.data.frame (   cbind (   affyTables [ ,  2 ] ,   affyTables [ ,  1 ] ) )   writeLines (   paste (  \"-  Connected to: \" ,   as.character (   unique (   c (   databases $ ensembl ,   databases $ vega ,   databases $ snp ,   databases $ sequence ) ) ) ,  \" -\" , sep =  \"\" ) ) ;   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "martConnect",
    "representation": "martConnect",
    "parameters": "function ( biomarts = \"ensembl\" , host , user , password , mart , local = FALSE )",
    "body": "{  if (   missing (  mart ) )  {    driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , mysqldriver =  driver ) }   presentConnections -   length (   mart @ connections )  for  ( i in   1 :   length (  biomarts ) )  {  if (  local )  {  if (        biomarts [  i ] ==  \"ensembl\" ||    biomarts [  i ] ==  \"sequence\" ||    biomarts [  i ] ==  \"uniprot\" ||    biomarts [  i ] ==  \"snp\" ||    biomarts [  i ] ==  \"vega\" )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =   biomarts [  i ] , host =   host [  i ] , user =   user [  i ] , password =   password [  i ] ) ;     mart @ connections [[   i +  presentConnections ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =   user [  i ] , host =   host [  i ] , dbname =  database , password =   password [  i ] )   writeLines (   paste (  \"connected to: \" ,  database ) )     names (   mart @ connections ) [   i +  presentConnections ] -   biomarts [  i ] } else  {   stop (  \"you should provide host, user and password when using local databases\" ) } } else  {   stop (   paste (  \"mart \" ,   biomarts [  i ] ,  \" is not covered by biomaRt, please choose one of the following BioMarts to connect to: ensembl, vega, sequence, uniprot and snp\" ) ) } } else  {  if (        biomarts [  i ] ==  \"ensembl\" ||    biomarts [  i ] ==  \"sequence\" ||    biomarts [  i ] ==  \"uniprot\" ||    biomarts [  i ] ==  \"snp\" ||    biomarts [  i ] ==  \"vega\" )  {     database -   switch (   biomarts [  i ] , ensembl =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , sequence =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , uniprot =   listMarts ( mart =   biomarts [  i ] , host =  \"martdb.ebi.ac.uk\" , user =  \"anonymous\" , password =  \"\" ) , snp =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , vega =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) ) ; #should have a try and catch here ...     mart @ connections [[   i +  presentConnections ] ] -   switch (   biomarts [  i ] , ensembl =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , sequence =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , snp =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , vega =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , uniprot =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"martdb.ebi.ac.uk\" , dbname =  database , password =  \"\" ) ) ;   writeLines (   paste (  \"connected to: \" ,  database ) )     names (   mart @ connections ) [   i +  presentConnections ] -   biomarts [  i ] } else  {   stop (   paste (  \"mart \" ,   biomarts [  i ] ,  \" is not covered by biomaRt, please choose one of the following BioMarts to connect to: ensembl, vega, sequence, uniprot and snp\" ) ) } } }  if (    match (  \"ensembl\" ,  biomarts , nomatch =  0 ) undefined  0 )  {         xref -   getPossibleXrefs (  mart ) ;   affySelect -   grep (  \"affy\" ,   xref [ ,  2 ] ) ;   affyTables -   xref [  affySelect , ] ;    affyTables [ ,  2 ] -   gsub (  \"affy_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;   affyPackName -   gsub (  \"_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;    mart @ arrayToSpecies -   data.frame ( affyID =  affyPackName , EnsemblArrayID =   affyTables [ ,  2 ] , species =   affyTables [ ,  1 ] ) ; }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "martDisconnect",
    "representation": "martDisconnect",
    "parameters": "function ( mart = NULL )",
    "body": "{       dbDisconnect (   mart @ ensembl ) ;   dbDisconnect (   mart @ vega ) ;   dbDisconnect (   mart @ sequence ) ;   dbDisconnect (   mart @ snp ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "martDisconnect",
    "representation": "martDisconnect",
    "parameters": "function ( mart )",
    "body": "{   if (   missing (  mart ) )  {    stop (  \"no Mart object to disconnect\" ) ; }   openConnections -   names (   mart @ connections ) ;  if (    match (  \"ensembl\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ ensembl ) ; }  if (    match (  \"vega\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ vega ) ; }  if (    match (  \"sequence\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ sequence ) ; }  if (    match (  \"snp\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ snp ) ; }  if (    match (  \"uniprot\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ uniprot ) ; }  if (    match (  \"biomart\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ biomart ) ; } } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , species = NULL , db = \"ensembl\" , mart = NULL , output = \"martTable\" )",
    "body": "{    genes -  NULL   IDTable -  NULL  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   is.null (  mart ) )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {     if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; }   species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEntrezGene (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToHUGO (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToRefSeq (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {    speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEMBL (  species ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {   conn -  NULL  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct gene_stable_id, display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   slot (  mart ,  db ) , statement =  query ) ;  if (   output ==  \"martTable\" )  {  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) } else  {   foundID -  NULL   symbol -  NULL   description -  NULL   band -  NULL   chromosome -  NULL   start -  NULL   end -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {           foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   symbol -   c (  symbol ,  NA ) ;   description -   c (  description ,  NA ) ;   band -   c (  band ,  NA ) ;   chromosome -   c (  chromosome ,  NA ) ;   start -   c (  start ,  NA ) ;   end -   c (  end ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {  if (   type ==  \"ensembl\" )  {           foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   symbol -   c (  symbol ,   res [   m ==  1 ,  2 ] ) ;   description -   c (  description ,   res [   m ==  1 ,  3 ] ) ;   band -   c (  band ,   res [   m ==  1 ,  4 ] ) ;   chromosome -   c (  chromosome ,   res [   m ==  1 ,  5 ] ) ;   start -   c (  start ,   res [   m ==  1 ,  6 ] ) ;   end -   c (  end ,   res [   m ==  1 ,  7 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  1 ] ) ; } else  {           foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   symbol -   c (  symbol ,   res [   m ==  1 ,  3 ] ) ;   description -   c (  description ,   res [   m ==  1 ,  4 ] ) ;   band -   c (  band ,   res [   m ==  1 ,  5 ] ) ;   chromosome -   c (  chromosome ,   res [   m ==  1 ,  6 ] ) ;   start -   c (  start ,   res [   m ==  1 ,  7 ] ) ;   end -   c (  end ,   res [   m ==  1 ,  8 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( symbol =  symbol , description =  description , band =  band , chromosome =  chromosome , start =  start , end =  end , martID =  martID ) ) } } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , species , db = \"ensembl\" , mart )",
    "body": "{        IDTable -  NULL  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl or vega\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ;  if (   db !=  \"ensembl\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; } }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  db ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl, ensemblTrans or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  db ) , ensemblTrans =   paste (  species ,  \"_gene_ensembl__transcript__main\" , sep =  \"\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  db ) , hugo =   mapSpeciesToHUGO (  species , db =  db ) , refseq =   mapSpeciesToRefSeq (  species , db =  db ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ;   dbcolQID -   getTableColumn (  type ) ;  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }  if (   db ==  \"vega\" )  {   if (    match (  \"vega\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to vega for this query, use martConnect and include 'vega' in your biomarts vector\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ vega , statement =  query ) ; }  if (   db ==  \"ensembl\" )  {    res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ; }  if (     dim (  res ) [  1 ] ==  0 )  {    table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) ; } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"martID\" ) ;   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) ; } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

4.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol = NULL , array = NULL , type = NULL , mart = NULL )",
    "body": "{         table -  NULL  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (     !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {       species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }   query -   paste (  \"select distinct gene_stable_id, display_id, description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  affyBool ,  \" = 1\" , sep =  \"\" ) ;   martID -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;   features -  NULL ;   mID -  NULL ;   sym -  NULL ;   description -  NULL ;  if (     dim (  martID ) [  1 ] !=  0 )  {  for  ( j in   1 :    dim (  martID ) [  1 ] )  {      feature -  NULL ;   query -   paste (  \"select distinct display_id_list from \" ,  IDTable ,  \" where gene_stable_id = '\" ,   martID [  j ,  1 ] ,  \"'\" , sep =  \"\" ) ;   feature -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  feature ) [  1 ] !=  0 )  {      feature -   feature [ ,  1 ] ;   select -   is.na (  feature ) ;   features -   c (  features ,   feature [  !  select ] ) ;   mID -   c (  mID ,   rep (   martID [  j ,  1 ] ,   sum (  !  select ) ) )   sym -   c (  sym ,   rep (   martID [  j ,  2 ] ,   sum (  !  select ) ) )   description -   c (  description ,   rep (   martID [  j ,  3 ] ,   sum (  !  select ) ) ) } }   table -   new (  \"martTable\" , id =  features , table =   list ( symbol =  sym , description =  description , martID =  mID ) ) } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , species , chromosome , start , end , type , mart )",
    "body": "{       table -  NULL  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) ; }  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {     species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {   stop (  \"you must provide the species, valid species names can be found by using the function getSpecies()\" ) } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

5.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , species = NULL , mart = NULL )",
    "body": "{      table -  NULL ;   go -  NULL ;  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \" you must provide the identifier type using the type argument\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {      species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   GOTable -   mapESpeciesToGOTable (  species ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEMBL (  species ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  IDTable ,  \".gene_stable_id, \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {    foundID -  NULL   GOID -  NULL   description -  NULL   evidence -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {       foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   GOID -   c (  GOID ,  NA )   description -   c (  description ,  NA ) ;   evidence -   c (  evidence ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {       foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   GOID -   c (  GOID ,   res [   m ==  1 ,  3 ] )   description -   c (  description ,   res [   m ==  1 ,  4 ] ) ;   evidence -   c (  evidence ,   res [   m ==  1 ,  5 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( GOID =  GOID , description =  description , evidence =  evidence , martID =  martID ) ) ; } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{          table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   is.null (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   GOTable -   mapSpeciesToGOTable (  species ) ;  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

6.
{
  "old_function": {
    "name": "getOMIM",
    "representation": "getOMIM",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , mart = NULL )",
    "body": "{        OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   omim -  NULL ;   table -  NULL ;   species -  \"hsapiens\" ;  if (  !   is.null (  array ) )  {    type -  \"affy\" ; }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq. embl, hugo, ensembl or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {    IDTable -   mapArrayToEnsemblTable (  array , species =  \"hsapiens\" , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToEMBL (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id, \" ,  IDTable ,  \".gene_stable_id,\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( OMIMID =  NA , disease =  NA , martID =  NA ) ) } else  {   foundID -  NULL   OMIMID -  NULL   disease -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {      foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   OMIMID -   c (  OMIMID ,  NA )   disease -   c (  disease ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {      foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   OMIMID -   c (  OMIMID ,   res [   m ==  1 ,  3 ] )   disease -   c (  disease ,   res [   m ==  1 ,  4 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( OMIMID =  OMIMID , disease =  disease , martID =  martID ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getOMIM",
    "representation": "getOMIM",
    "parameters": "function ( id , type , array , mart )",
    "body": "{           OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   omim -  NULL ;   table -  NULL ;   species -  \"hsapiens\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq. embl, hugo, ensembl or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  \"hsapiens\" , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")  and \" ,  OMIMTable ,  \".omim_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  OMIMTable ,  \".omim_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( OMIMID =  NA , disease =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"OMIMID\" ,  \"disease\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

7.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species = NULL , chromosome = NULL , start = NULL , end = NULL , martTable = NULL , mart = NULL )",
    "body": "{     sequence -  NULL ;   speciesTable -   paste (  species ,  \"__dna_chunks__main\" , sep =  \"\" ) ;  if (      is.null (  martTable ) undefined  !   is.null (  chromosome ) undefined  !   is.null (  start ) undefined  !   is.null (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   is.null (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species , chromosome , start , end , martTable , mart )",
    "body": "{    if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"sequence\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to sequence BioMart for this query.  Add connection to a sequence BioMart to your Mart object via the function martConnect. Use the following command to do this:  martConnect(biomarts='sequence',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password=''). \" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ; #need to use this from Ensembl v32 on!! #speciesTable  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

8.
{
  "old_function": {
    "name": "getAffyArrays",
    "representation": "getAffyArrays",
    "parameters": "function ( mart = NULL )",
    "body": "{    print (   mart @ arrayToSpecies ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getAffyArrays",
    "representation": "getAffyArrays",
    "parameters": "function ( mart )",
    "body": "{   if (   missing (  mart ) )  {   stop (  \"no Mart object found, create this first using the function martConnect and then give as argument in the function\" ) }   print (   mart @ arrayToSpecies ) ; } ",
    "filename": "biomaRt.txt"
  }
}

9.
{
  "old_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species = NULL , chromosome = NULL , start = NULL , end = NULL , mart = NULL )",
    "body": "{      table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (   mart @ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species , chromosome , start , end , mart )",
    "body": "{     if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    match (  \"snp\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to snp for this query.  Add connection to snp a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='snp',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) }  if (      missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) ||   missing (  species ) )  {   stop (  \"you have to give chromosome, start and end positions and species as arguments, see ?getSNP for more information\" ) }   table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

10.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id = NULL , from.type = NULL , to.type = NULL , from.species = NULL , to.species = NULL , mart = NULL , output = \"martTable\" )",
    "body": "{ #all homology needs to go through ensembl_mart, not vega, etc.       db =  \"ensembl\" ;   id -   as.character (  id )  if (   is.null (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) }  if (   is.null (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) }  if (   is.null (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   is.null (  to.species ) )  {   stop (  \"You must provide the species to map TO using the to.species  argument\" ) }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , ensembl =   mapSpeiciesToGeneTable (  to.species , db =  db ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , ensembl =   mapSpeiciesToGeneTable (  to.species , db =  db ) ) ;   homolTable -   mapESpeciesToHomologTable (  from.species ,  to.species ) ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL   query -   paste (  \"select distinct a.display_id_list,b.display_id_list from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner  join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ;   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.species , to.species , mart , output = \"martTable\" )",
    "body": "{        db =  \"ensembl\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {     from.type -  \"affy\" ;   from.species -   mapArrayToSpecies ( array =  from.array , mart =  mart ) ; } else  {  if (   missing (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) } }  if (  !   missing (  to.array ) )  {     to.type -  \"affy\" ;   to.species -   mapArrayToSpecies ( array =  to.array , mart =  mart ) ; } else  {  if (   missing (  to.species ) )  {    stop (  \"You must provide the species to map TO using the to.species  argument\" ) ; }  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , affy =   mapArrayToEnsemblTable (  from.array , species =  from.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  from.species , db =  db ) , flybase =   mapSpeciesToFlybase (  from.species ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  to.species , db =  db ) , affy =   mapArrayToEnsemblTable (  to.array , species =  to.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  to.species , db =  db ) , flybase =   mapSpeciesToFlybase (  to.species ) ) ;   fromCol -   getTableColumn (  from.type ) ;   toCol -   getTableColumn (  to.type ) ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

11.
{
  "old_function": {
    "name": "getPossibleXrefs",
    "representation": "getPossibleXrefs",
    "parameters": "function ( mart = NULL )",
    "body": "{  if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }   res -   dbGetQuery (   mart @ ensembl ,  \"show tables like '%_gene_ensembl__xref%'\" )   xref -   strsplit (   res [ ,  1 ] ,  '_gene_ensembl__xref_' )   xref -   lapply (  xref ,  function ( s )  {    s [  2 ] -   gsub (  '__dm' ,  '' ,   s [  2 ] )   return (  s ) } )   xrefdf -   do.call (  'rbind' ,  xref )    colnames (  xrefdf ) -   c (  'species' ,  'xref' )   return (  xrefdf ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getPossibleXrefs",
    "representation": "getPossibleXrefs",
    "parameters": "function ( mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   res -   dbGetQuery (    mart @ connections $ ensembl ,  \"show tables like '%_gene_ensembl__xref%'\" )   xref -   strsplit (   res [ ,  1 ] ,  '_gene_ensembl__xref_' )   xref -   lapply (  xref ,  function ( s )  {    s [  2 ] -   gsub (  '__dm' ,  '' ,   s [  2 ] )   return (  s ) } )   xrefdf -   do.call (  'rbind' ,  xref )    colnames (  xrefdf ) -   c (  'species' ,  'xref' )   return (  xrefdf ) } ",
    "filename": "biomaRt.txt"
  }
}

12.
{
  "old_function": {
    "name": "getSpecies",
    "representation": "getSpecies",
    "parameters": "function ( mart = NULL , db = c ( 'ensembl' , 'vega' , 'snp' , 'sequence' ) )",
    "body": "{        if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }   db -   match.arg (  db )   query =  \"show tables like '%gene__main'\" ;   res -   switch (  db , ensembl =   dbGetQuery (   mart @ ensembl ,  query ) , vega =   dbGetQuery (   mart @ vega ,  query ) , snp =   dbGetQuery (   mart @ snp ,  query ) , sequence =   dbGetQuery (   mart @ sequence ,  query ) )   resvec -   as.vector (   as.character (   res [ ,  1 ] ) ) ;   speciessub -   grep (  'gene__main' ,  resvec ) ;   specieslist -   strsplit (   resvec [  speciessub ] ,  '_' ) ;   species -   sapply (  specieslist ,  function ( s )  {   s [  1 ] } , simplify =  T ) ;   return (   unique (  species ) ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSpecies",
    "representation": "getSpecies",
    "parameters": "function ( mart , db = c ( \"ensembl\" ) )",
    "body": "{         if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) } #db   query =  \"show tables like '%gene__main'\" ;  if (    match (  db ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (   paste (  \"You are missing a database connection to \" ,  db ,  \" for this query.  Add connection to \" ,  db ,  \" a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='\" ,  db ,  \"',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) , sep =  \"\" ) }   res -   switch (  db , ensembl =   dbGetQuery (    mart @ connections $ ensembl ,  query ) , vega =   dbGetQuery (    mart @ connections $ vega ,  query ) , snp =   dbGetQuery (    mart @ connections $ snp ,  query ) , sequence =   dbGetQuery (    mart @ connections $ sequence ,  query ) ) ;   resvec -   as.vector (   as.character (   res [ ,  1 ] ) ) ;   speciessub -   grep (  'gene__main' ,  resvec ) ;   specieslist -   strsplit (   resvec [  speciessub ] ,  '_' ) ;   species -   sapply (  specieslist ,  function ( s )  {   s [  1 ] } , simplify =  T ) ;   return (   unique (  species ) ) ; } ",
    "filename": "biomaRt.txt"
  }
}

13.
{
  "old_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id = NULL , from.species = NULL , to.species = NULL , from.xref = NULL , to.xref = NULL , db = c ( 'ensembl' ) , mart = NULL )",
    "body": "{   if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (   is.null (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   is.null (  from.species ) )  {      writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ;   print (   getPossibleSpecies ( mart =  mart ) ) ;   stop ( ) ; }  if (    is.null (  from.xref ) ||   is.null (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   is.null (  to.species ) )  {    query -   paste (  'SELECT distinct a.display_id_list as fromid,b.display_id_list as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.display_id_list in ('\" ,  xp ,  \"')\" , sep =  \"\" ) ; } else  {   if (   db ==  'vega' )  {   stop (  'VEGA supports only hsapiens' ) }   query -   paste (  'SELECT distinct a.display_id_list as fromid,b.display_id_list as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.display_id_list in ('\" ,  xp ,  \"')\" , sep =  \"\" ) ; }   res -   dbGetQuery ( con =   mart @ ensembl ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id , from.species , to.species , from.xref , to.xref , db = \"ensembl\" , mart )",
    "body": "{   if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (   missing (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   missing (  from.species ) )  {      writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ;   print (   getSpecies ( mart =  mart , db =  \"ensembl\" ) ) ;   stop ( ) ; }  if (    missing (  from.xref ) ||   missing (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   missing (  to.species ) )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   db ==  'vega' )  {   stop (  'VEGA supports only hsapiens' ) }  if (   from.species ==  to.species )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( con =    mart @ connections $ ensembl ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( host = \"ensembldb.ensembl.org\" , user = \"anonymous\" , password = \"\" )",
    "body": "{          driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   connection -   dbConnect (  driv , user =  user , host =  host , password =  password ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ;   marts -   c (  \"ensembl_mart_\" ,  \"snp_mart_\" ,  \"sequence_mart_\" ,  \"vega_mart_\" ) ;   databases -   list ( ensembl =  \"\" , snp =  \"\" , sequence =  \"\" , vega =  \"\" ) ; #Search latest releases of marts   martConf -  NULL #one mart vs multiple marts  if (     dim (  res ) [  1 ] undefined  1 )  {  for  ( i in   1 :   length (  marts ) )  {    matches -   grep (   marts [  i ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {       version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;  if (   v undefined  version )  {     latest -  j ;   version -  v ; } }    databases [[  i ] ] -   res [   matches [  latest ] ,  1 ] ;   martConf -   c (  martConf ,  v ) ; } else  {       databases [[  i ] ] -   res [  matches ,  1 ] ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;   martConf -   c (  martConf ,  v ) ; } }  if (  !  (     sum (  martConf ) /  4 ==   martConf [[  1 ] ] ) )  { # mean there is only one new mart    databases $ snp -   databases $ ensembl    databases $ vega -   databases $ ensembl    databases $ sequence -   databases $ ensembl } } else  {  if (     dim (  res ) [  1 ] ==  1 )  {  if (    grep (  \"ensembl\" ,   res [  1 ,  1 ] ) ==  1 )  {    databases $ ensembl -   res [  1 ,  1 ]    databases $ snp -   databases $ ensembl    databases $ vega -   databases $ ensembl    databases $ sequence -   databases $ ensembl } else  {    stop (  \"No Ensembl database found, if you have a local installation, make sure your database follows trhe following naming convention: ensembl_mart_30 where 30 is the release number\" ) ; } } else  {    stop (  \"No biomaRt database found\" ) ; } }   dbDisconnect (  connection ) ;   return (  databases ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , includeHosts = FALSE )",
    "body": "{    if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ) }  if (   missing (  host ) )  {   host -   c (  \"ensembldb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ;  if (   v undefined  version )  {     latest -  j ;   version -  v ; } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "martConnect",
    "representation": "martConnect",
    "parameters": "function ( host = \"ensembldb.ensembl.org\" , user = \"anonymous\" , password = \"\" )",
    "body": "{            databases -   listMarts ( host =  host , user =  user , password =  password ) ;   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   dummy -   data.frame (   cbind ( x =  1 , y =   1 :  2 ) )   mart -   new (  \"Mart\" , ensembl =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ ensembl , password =  password ) , vega =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ vega , password =  password ) , sequence =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ sequence , password =  password ) , snp =   dbConnect ( drv =  driver , user =  user , host =  host , dbname =   databases $ snp , password =  password ) , arrayToSpecies =  dummy ) ;   xref -   getPossibleXrefs (  mart ) ;   affySelect -   grep (  \"affy\" ,   xref [ ,  2 ] ) ;   affyTables -   xref [  affySelect , ] ;    affyTables [ ,  2 ] -   gsub (  \"affy_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;    colnames (  affyTables ) -   c (  'species' ,  'affy array' ) ;    mart @ arrayToSpecies -   as.data.frame (   cbind (   affyTables [ ,  2 ] ,   affyTables [ ,  1 ] ) )   writeLines (   paste (  \"-  Connected to: \" ,   as.character (   unique (   c (   databases $ ensembl ,   databases $ vega ,   databases $ snp ,   databases $ sequence ) ) ) ,  \" -\" , sep =  \"\" ) ) ;   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "martConnect",
    "representation": "martConnect",
    "parameters": "function ( biomarts = \"ensembl\" , host , user , password , mart , local = FALSE )",
    "body": "{  if (   missing (  mart ) )  {    driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , mysqldriver =  driver ) }   presentConnections -   length (   mart @ connections )  for  ( i in   1 :   length (  biomarts ) )  {  if (  local )  {  if (        biomarts [  i ] ==  \"ensembl\" ||    biomarts [  i ] ==  \"sequence\" ||    biomarts [  i ] ==  \"uniprot\" ||    biomarts [  i ] ==  \"snp\" ||    biomarts [  i ] ==  \"vega\" )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =   biomarts [  i ] , host =   host [  i ] , user =   user [  i ] , password =   password [  i ] ) ;     mart @ connections [[   i +  presentConnections ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =   user [  i ] , host =   host [  i ] , dbname =  database , password =   password [  i ] )   writeLines (   paste (  \"connected to: \" ,  database ) )     names (   mart @ connections ) [   i +  presentConnections ] -   biomarts [  i ] } else  {   stop (  \"you should provide host, user and password when using local databases\" ) } } else  {   stop (   paste (  \"mart \" ,   biomarts [  i ] ,  \" is not covered by biomaRt, please choose one of the following BioMarts to connect to: ensembl, vega, sequence, uniprot and snp\" ) ) } } else  {  if (        biomarts [  i ] ==  \"ensembl\" ||    biomarts [  i ] ==  \"sequence\" ||    biomarts [  i ] ==  \"uniprot\" ||    biomarts [  i ] ==  \"snp\" ||    biomarts [  i ] ==  \"vega\" )  {     database -   switch (   biomarts [  i ] , ensembl =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , sequence =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , uniprot =   listMarts ( mart =   biomarts [  i ] , host =  \"martdb.ebi.ac.uk\" , user =  \"anonymous\" , password =  \"\" ) , snp =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) , vega =   listMarts ( mart =   biomarts [  i ] , host =  \"ensembldb.ensembl.org\" , user =  \"anonymous\" , password =  \"\" ) ) ; #should have a try and catch here ...     mart @ connections [[   i +  presentConnections ] ] -   switch (   biomarts [  i ] , ensembl =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , sequence =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , snp =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , vega =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  database , password =  \"\" ) , uniprot =   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =  \"martdb.ebi.ac.uk\" , dbname =  database , password =  \"\" ) ) ;   writeLines (   paste (  \"connected to: \" ,  database ) )     names (   mart @ connections ) [   i +  presentConnections ] -   biomarts [  i ] } else  {   stop (   paste (  \"mart \" ,   biomarts [  i ] ,  \" is not covered by biomaRt, please choose one of the following BioMarts to connect to: ensembl, vega, sequence, uniprot and snp\" ) ) } } }  if (    match (  \"ensembl\" ,  biomarts , nomatch =  0 ) undefined  0 )  {         xref -   getPossibleXrefs (  mart ) ;   affySelect -   grep (  \"affy\" ,   xref [ ,  2 ] ) ;   affyTables -   xref [  affySelect , ] ;    affyTables [ ,  2 ] -   gsub (  \"affy_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;   affyPackName -   gsub (  \"_\" ,  \"\" ,   affyTables [ ,  2 ] ) ;    mart @ arrayToSpecies -   data.frame ( affyID =  affyPackName , EnsemblArrayID =   affyTables [ ,  2 ] , species =   affyTables [ ,  1 ] ) ; }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "martDisconnect",
    "representation": "martDisconnect",
    "parameters": "function ( mart = NULL )",
    "body": "{       dbDisconnect (   mart @ ensembl ) ;   dbDisconnect (   mart @ vega ) ;   dbDisconnect (   mart @ sequence ) ;   dbDisconnect (   mart @ snp ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "martDisconnect",
    "representation": "martDisconnect",
    "parameters": "function ( mart )",
    "body": "{   if (   missing (  mart ) )  {    stop (  \"no Mart object to disconnect\" ) ; }   openConnections -   names (   mart @ connections ) ;  if (    match (  \"ensembl\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ ensembl ) ; }  if (    match (  \"vega\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ vega ) ; }  if (    match (  \"sequence\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ sequence ) ; }  if (    match (  \"snp\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ snp ) ; }  if (    match (  \"uniprot\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ uniprot ) ; }  if (    match (  \"biomart\" ,  openConnections , nomatch =  0 ) !=  0 )  {    dbDisconnect (    mart @ connections $ biomart ) ; } } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , species = NULL , db = \"ensembl\" , mart = NULL , output = \"martTable\" )",
    "body": "{    genes -  NULL   IDTable -  NULL  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   is.null (  mart ) )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {     if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; }   species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEntrezGene (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToHUGO (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToRefSeq (  species , db =  db ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {    speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEMBL (  species ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  db ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {   conn -  NULL  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct gene_stable_id, display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   slot (  mart ,  db ) , statement =  query ) ;  if (   output ==  \"martTable\" )  {  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) } else  {   foundID -  NULL   symbol -  NULL   description -  NULL   band -  NULL   chromosome -  NULL   start -  NULL   end -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {           foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   symbol -   c (  symbol ,  NA ) ;   description -   c (  description ,  NA ) ;   band -   c (  band ,  NA ) ;   chromosome -   c (  chromosome ,  NA ) ;   start -   c (  start ,  NA ) ;   end -   c (  end ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {  if (   type ==  \"ensembl\" )  {           foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   symbol -   c (  symbol ,   res [   m ==  1 ,  2 ] ) ;   description -   c (  description ,   res [   m ==  1 ,  3 ] ) ;   band -   c (  band ,   res [   m ==  1 ,  4 ] ) ;   chromosome -   c (  chromosome ,   res [   m ==  1 ,  5 ] ) ;   start -   c (  start ,   res [   m ==  1 ,  6 ] ) ;   end -   c (  end ,   res [   m ==  1 ,  7 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  1 ] ) ; } else  {           foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   symbol -   c (  symbol ,   res [   m ==  1 ,  3 ] ) ;   description -   c (  description ,   res [   m ==  1 ,  4 ] ) ;   band -   c (  band ,   res [   m ==  1 ,  5 ] ) ;   chromosome -   c (  chromosome ,   res [   m ==  1 ,  6 ] ) ;   start -   c (  start ,   res [   m ==  1 ,  7 ] ) ;   end -   c (  end ,   res [   m ==  1 ,  8 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( symbol =  symbol , description =  description , band =  band , chromosome =  chromosome , start =  start , end =  end , martID =  martID ) ) } } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , species , db = \"ensembl\" , mart )",
    "body": "{        IDTable -  NULL  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl or vega\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ;  if (   db !=  \"ensembl\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; } }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  db ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl, ensemblTrans or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  db ) , ensemblTrans =   paste (  species ,  \"_gene_ensembl__transcript__main\" , sep =  \"\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  db ) , hugo =   mapSpeciesToHUGO (  species , db =  db ) , refseq =   mapSpeciesToRefSeq (  species , db =  db ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ;   dbcolQID -   getTableColumn (  type ) ;  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }  if (   db ==  \"vega\" )  {   if (    match (  \"vega\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to vega for this query, use martConnect and include 'vega' in your biomarts vector\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ vega , statement =  query ) ; }  if (   db ==  \"ensembl\" )  {    res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ; }  if (     dim (  res ) [  1 ] ==  0 )  {    table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) ; } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"martID\" ) ;   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) ; } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

4.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol = NULL , array = NULL , type = NULL , mart = NULL )",
    "body": "{         table -  NULL  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (     !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {       species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   speciesTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }   query -   paste (  \"select distinct gene_stable_id, display_id, description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  affyBool ,  \" = 1\" , sep =  \"\" ) ;   martID -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;   features -  NULL ;   mID -  NULL ;   sym -  NULL ;   description -  NULL ;  if (     dim (  martID ) [  1 ] !=  0 )  {  for  ( j in   1 :    dim (  martID ) [  1 ] )  {      feature -  NULL ;   query -   paste (  \"select distinct display_id_list from \" ,  IDTable ,  \" where gene_stable_id = '\" ,   martID [  j ,  1 ] ,  \"'\" , sep =  \"\" ) ;   feature -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  feature ) [  1 ] !=  0 )  {      feature -   feature [ ,  1 ] ;   select -   is.na (  feature ) ;   features -   c (  features ,   feature [  !  select ] ) ;   mID -   c (  mID ,   rep (   martID [  j ,  1 ] ,   sum (  !  select ) ) )   sym -   c (  sym ,   rep (   martID [  j ,  2 ] ,   sum (  !  select ) ) )   description -   c (  description ,   rep (   martID [  j ,  3 ] ,   sum (  !  select ) ) ) } }   table -   new (  \"martTable\" , id =  features , table =   list ( symbol =  sym , description =  description , martID =  mID ) ) } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , species , chromosome , start , end , type , mart )",
    "body": "{       table -  NULL  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) ; }  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {     species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {   stop (  \"you must provide the species, valid species names can be found by using the function getSpecies()\" ) } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

5.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , species = NULL , mart = NULL )",
    "body": "{      table -  NULL ;   go -  NULL ;  if (  !   is.null (  array ) )  {   type -  \"affy\" }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \" you must provide the identifier type using the type argument\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {      species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   GOTable -   mapESpeciesToGOTable (  species ) ;   IDTable -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {     IDTable -   mapSpeciesToEMBL (  species ) ;   GOTable -   mapESpeciesToGOTable (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  IDTable ,  \".gene_stable_id, \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {    foundID -  NULL   GOID -  NULL   description -  NULL   evidence -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {       foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   GOID -   c (  GOID ,  NA )   description -   c (  description ,  NA ) ;   evidence -   c (  evidence ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {       foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   GOID -   c (  GOID ,   res [   m ==  1 ,  3 ] )   description -   c (  description ,   res [   m ==  1 ,  4 ] ) ;   evidence -   c (  evidence ,   res [   m ==  1 ,  5 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( GOID =  GOID , description =  description , evidence =  evidence , martID =  martID ) ) ; } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{          table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   is.null (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   GOTable -   mapSpeciesToGOTable (  species ) ;  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

6.
{
  "old_function": {
    "name": "getOMIM",
    "representation": "getOMIM",
    "parameters": "function ( id = NULL , type = NULL , array = NULL , mart = NULL )",
    "body": "{        OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   omim -  NULL ;   table -  NULL ;   species -  \"hsapiens\" ;  if (  !   is.null (  array ) )  {    type -  \"affy\" ; }  if (   type ==  \"locuslink\" )  {    writeLines (  \"LocusLink has been superseded by Entrez-Gene, the type argument is now set to entrezgene\" )   type -  \"entrezgene\" ; }  if (   is.null (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq. embl, hugo, ensembl or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   is.null (  array ) )  {    IDTable -   mapArrayToEnsemblTable (  array , species =  \"hsapiens\" , mart =  mart , dbtable =  \"xrefdm\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } }  if (   type ==  \"ensembl\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapESpeciesToGeneTable (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (   type ==  \"entrezgene\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for entrezgene identifiers\" ) ; } }  if (   type ==  \"hugo\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for HUGO identifiers\" ) ; } }  if (   type ==  \"refseq\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for RefSeq identifiers\" ) ; } }  if (   type ==  \"embl\" )  {  if (  !   is.null (  species ) )  {    IDTable -   mapSpeciesToEMBL (  species ) ; } else  {    stop (  \"you must provide the species via the species argument when using this function for EMBL identifiers\" ) ; } }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id, \" ,  IDTable ,  \".gene_stable_id,\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".display_id_list, \" ,  IDTable ,  \".gene_stable_id,\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( OMIMID =  NA , disease =  NA , martID =  NA ) ) } else  {   foundID -  NULL   OMIMID -  NULL   disease -  NULL   martID -  NULL  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {      foundID -   c (  foundID ,   as.character (   id [  j ] ) ) ;   OMIMID -   c (  OMIMID ,  NA )   disease -   c (  disease ,  NA ) ;   martID -   c (  martID ,  NA ) ; } else  {      foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] ) ;   OMIMID -   c (  OMIMID ,   res [   m ==  1 ,  3 ] )   disease -   c (  disease ,   res [   m ==  1 ,  4 ] ) ;   martID -   c (  martID ,   res [   m ==  1 ,  2 ] ) ; } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( OMIMID =  OMIMID , disease =  disease , martID =  martID ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getOMIM",
    "representation": "getOMIM",
    "parameters": "function ( id , type , array , mart )",
    "body": "{           OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   omim -  NULL ;   table -  NULL ;   species -  \"hsapiens\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }  if (       !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) )  {    stop (  \"invalid type choose either affy, refseq. embl, hugo, ensembl or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  \"hsapiens\" , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")  and \" ,  OMIMTable ,  \".omim_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  OMIMTable ,  \".omim_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( OMIMID =  NA , disease =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"OMIMID\" ,  \"disease\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

7.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species = NULL , chromosome = NULL , start = NULL , end = NULL , martTable = NULL , mart = NULL )",
    "body": "{     sequence -  NULL ;   speciesTable -   paste (  species ,  \"__dna_chunks__main\" , sep =  \"\" ) ;  if (      is.null (  martTable ) undefined  !   is.null (  chromosome ) undefined  !   is.null (  start ) undefined  !   is.null (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   is.null (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =   mart @ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species , chromosome , start , end , martTable , mart )",
    "body": "{    if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"sequence\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to sequence BioMart for this query.  Add connection to a sequence BioMart to your Mart object via the function martConnect. Use the following command to do this:  martConnect(biomarts='sequence',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password=''). \" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ; #need to use this from Ensembl v32 on!! #speciesTable  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

8.
{
  "old_function": {
    "name": "getAffyArrays",
    "representation": "getAffyArrays",
    "parameters": "function ( mart = NULL )",
    "body": "{    print (   mart @ arrayToSpecies ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getAffyArrays",
    "representation": "getAffyArrays",
    "parameters": "function ( mart )",
    "body": "{   if (   missing (  mart ) )  {   stop (  \"no Mart object found, create this first using the function martConnect and then give as argument in the function\" ) }   print (   mart @ arrayToSpecies ) ; } ",
    "filename": "biomaRt.txt"
  }
}

9.
{
  "old_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species = NULL , chromosome = NULL , start = NULL , end = NULL , mart = NULL )",
    "body": "{      table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (   mart @ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species , chromosome , start , end , mart )",
    "body": "{     if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    match (  \"snp\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to snp for this query.  Add connection to snp a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='snp',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) }  if (      missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) ||   missing (  species ) )  {   stop (  \"you have to give chromosome, start and end positions and species as arguments, see ?getSNP for more information\" ) }   table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  }
}

10.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id = NULL , from.type = NULL , to.type = NULL , from.species = NULL , to.species = NULL , mart = NULL , output = \"martTable\" )",
    "body": "{ #all homology needs to go through ensembl_mart, not vega, etc.       db =  \"ensembl\" ;   id -   as.character (  id )  if (   is.null (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) }  if (   is.null (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) }  if (   is.null (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   is.null (  to.species ) )  {   stop (  \"You must provide the species to map TO using the to.species  argument\" ) }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , ensembl =   mapSpeiciesToGeneTable (  to.species , db =  db ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , ensembl =   mapSpeiciesToGeneTable (  to.species , db =  db ) ) ;   homolTable -   mapESpeciesToHomologTable (  from.species ,  to.species ) ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,   id [  1 ] ,  \"'\" , sep =  \"\" )  if (    length (  id ) =  2 )  {  for  ( i in   2 :   length (  id ) )  {   ids -   paste (  ids ,  \",'\" ,   id [  i ] ,  \"'\" , sep =  \"\" ) } }   res -  NULL   query -   paste (  \"select distinct a.display_id_list,b.display_id_list from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner  join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.display_id_list in (\" ,  ids ,  \")\" , sep =  \"\" ) ;   res -   dbGetQuery ( conn =   mart @ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.species , to.species , mart , output = \"martTable\" )",
    "body": "{        db =  \"ensembl\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {     from.type -  \"affy\" ;   from.species -   mapArrayToSpecies ( array =  from.array , mart =  mart ) ; } else  {  if (   missing (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) } }  if (  !   missing (  to.array ) )  {     to.type -  \"affy\" ;   to.species -   mapArrayToSpecies ( array =  to.array , mart =  mart ) ; } else  {  if (   missing (  to.species ) )  {    stop (  \"You must provide the species to map TO using the to.species  argument\" ) ; }  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , affy =   mapArrayToEnsemblTable (  from.array , species =  from.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  from.species , db =  db ) , flybase =   mapSpeciesToFlybase (  from.species ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  to.species , db =  db ) , affy =   mapArrayToEnsemblTable (  to.array , species =  to.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  to.species , db =  db ) , flybase =   mapSpeciesToFlybase (  to.species ) ) ;   fromCol -   getTableColumn (  from.type ) ;   toCol -   getTableColumn (  to.type ) ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

11.
{
  "old_function": {
    "name": "getPossibleXrefs",
    "representation": "getPossibleXrefs",
    "parameters": "function ( mart = NULL )",
    "body": "{  if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }   res -   dbGetQuery (   mart @ ensembl ,  \"show tables like '%_gene_ensembl__xref%'\" )   xref -   strsplit (   res [ ,  1 ] ,  '_gene_ensembl__xref_' )   xref -   lapply (  xref ,  function ( s )  {    s [  2 ] -   gsub (  '__dm' ,  '' ,   s [  2 ] )   return (  s ) } )   xrefdf -   do.call (  'rbind' ,  xref )    colnames (  xrefdf ) -   c (  'species' ,  'xref' )   return (  xrefdf ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getPossibleXrefs",
    "representation": "getPossibleXrefs",
    "parameters": "function ( mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   res -   dbGetQuery (    mart @ connections $ ensembl ,  \"show tables like '%_gene_ensembl__xref%'\" )   xref -   strsplit (   res [ ,  1 ] ,  '_gene_ensembl__xref_' )   xref -   lapply (  xref ,  function ( s )  {    s [  2 ] -   gsub (  '__dm' ,  '' ,   s [  2 ] )   return (  s ) } )   xrefdf -   do.call (  'rbind' ,  xref )    colnames (  xrefdf ) -   c (  'species' ,  'xref' )   return (  xrefdf ) } ",
    "filename": "biomaRt.txt"
  }
}

12.
{
  "old_function": {
    "name": "getSpecies",
    "representation": "getSpecies",
    "parameters": "function ( mart = NULL , db = c ( 'ensembl' , 'vega' , 'snp' , 'sequence' ) )",
    "body": "{        if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }   db -   match.arg (  db )   query =  \"show tables like '%gene__main'\" ;   res -   switch (  db , ensembl =   dbGetQuery (   mart @ ensembl ,  query ) , vega =   dbGetQuery (   mart @ vega ,  query ) , snp =   dbGetQuery (   mart @ snp ,  query ) , sequence =   dbGetQuery (   mart @ sequence ,  query ) )   resvec -   as.vector (   as.character (   res [ ,  1 ] ) ) ;   speciessub -   grep (  'gene__main' ,  resvec ) ;   specieslist -   strsplit (   resvec [  speciessub ] ,  '_' ) ;   species -   sapply (  specieslist ,  function ( s )  {   s [  1 ] } , simplify =  T ) ;   return (   unique (  species ) ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSpecies",
    "representation": "getSpecies",
    "parameters": "function ( mart , db = c ( \"ensembl\" ) )",
    "body": "{         if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  'You must supply a valid mart object.  You can use martConnect to produce one' ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) } #db   query =  \"show tables like '%gene__main'\" ;  if (    match (  db ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (   paste (  \"You are missing a database connection to \" ,  db ,  \" for this query.  Add connection to \" ,  db ,  \" a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='\" ,  db ,  \"',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) , sep =  \"\" ) }   res -   switch (  db , ensembl =   dbGetQuery (    mart @ connections $ ensembl ,  query ) , vega =   dbGetQuery (    mart @ connections $ vega ,  query ) , snp =   dbGetQuery (    mart @ connections $ snp ,  query ) , sequence =   dbGetQuery (    mart @ connections $ sequence ,  query ) ) ;   resvec -   as.vector (   as.character (   res [ ,  1 ] ) ) ;   speciessub -   grep (  'gene__main' ,  resvec ) ;   specieslist -   strsplit (   resvec [  speciessub ] ,  '_' ) ;   species -   sapply (  specieslist ,  function ( s )  {   s [  1 ] } , simplify =  T ) ;   return (   unique (  species ) ) ; } ",
    "filename": "biomaRt.txt"
  }
}

13.
{
  "old_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id = NULL , from.species = NULL , to.species = NULL , from.xref = NULL , to.xref = NULL , db = c ( 'ensembl' ) , mart = NULL )",
    "body": "{   if (    is.null (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (   is.null (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   is.null (  from.species ) )  {      writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ;   print (   getPossibleSpecies ( mart =  mart ) ) ;   stop ( ) ; }  if (    is.null (  from.xref ) ||   is.null (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   is.null (  to.species ) )  {    query -   paste (  'SELECT distinct a.display_id_list as fromid,b.display_id_list as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.display_id_list in ('\" ,  xp ,  \"')\" , sep =  \"\" ) ; } else  {   if (   db ==  'vega' )  {   stop (  'VEGA supports only hsapiens' ) }   query -   paste (  'SELECT distinct a.display_id_list as fromid,b.display_id_list as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.display_id_list in ('\" ,  xp ,  \"')\" , sep =  \"\" ) ; }   res -   dbGetQuery ( con =   mart @ ensembl ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id , from.species , to.species , from.xref , to.xref , db = \"ensembl\" , mart )",
    "body": "{   if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (   missing (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   missing (  from.species ) )  {      writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ;   print (   getSpecies ( mart =  mart , db =  \"ensembl\" ) ) ;   stop ( ) ; }  if (    missing (  from.xref ) ||   missing (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   missing (  to.species ) )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   db ==  'vega' )  {   stop (  'VEGA supports only hsapiens' ) }  if (   from.species ==  to.species )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( con =    mart @ connections $ ensembl ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_1_7 biomart_release_1_8

{
    "package": "biomaRt",
    "release_versions": "biomart_release_1_7 biomart_release_1_8",
    "desc_release_old": "1.4.0",
    "desc_release_new": "1.6.3",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 1,
    "function_additions": 2,
    "parameter_removals": 6,
    "parameter_additions": 2,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 10,
    "total_count": 11
}

##########
Functions Removed
##########

getSpecies


##########
Functions Added
##########

parseAttributes
parseFilters


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , species , db = \"ensembl\" , mart )",
    "body": "{        IDTable -  NULL  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl or vega\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ;  if (   db !=  \"ensembl\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; } }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  db ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl, ensemblTrans or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  db ) , ensemblTrans =   paste (  species ,  \"_gene_ensembl__transcript__main\" , sep =  \"\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  db ) , hugo =   mapSpeciesToHUGO (  species , db =  db ) , refseq =   mapSpeciesToRefSeq (  species , db =  db ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ;   dbcolQID -   getTableColumn (  type ) ;  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }  if (   db ==  \"vega\" )  {   if (    match (  \"vega\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to vega for this query, use martConnect and include 'vega' in your biomarts vector\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ vega , statement =  query ) ; }  if (   db ==  \"ensembl\" )  {    res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ; }  if (     dim (  res ) [  1 ] ==  0 )  {    table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) ; } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"martID\" ) ;   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) ; } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    mart @ biomart !=  \"ensembl\" )  {    stop (  \"you can only use ensembl for this query.  Please do: useMart('ensembl').  To access VEGA you have to use the more advanced biomaRt function:  useMart. listDatasets, useDataset, listFilters, listAttributes and getBM.\" ) ; }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ; }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } #MySQL-----------------------------------------------------------  if (   mart @ mysql )  {    if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end, chrom_strand  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end,\" ,  speciesTable ,  \".chrom_strand  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   writeLines (  \"Query retrieved no results\" )   return (  NULL ) } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"strand\" ,  \"martID\" ) ;   table -   as.data.frame (  res )   return (  table ) ; } } } #Webservice----------------------------------------------------- else  {   startpos =  \"start_position\"   endpos =  \"end_position\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   symbol =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"symbol\" ,  \"description\" ,  \"chromosome\" ,  \"band\" ,  \"strand\" ,  \"chromosome_start\" ,  \"chromosome_end\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , species , chromosome , start , end , type , mart )",
    "body": "{       table -  NULL  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) ; }  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {     species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {   stop (  \"you must provide the species, valid species names can be found by using the function getSpecies()\" ) } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , chromosome , start , end , type , mart )",
    "body": "{  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {    if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {    affyBool -   paste (  array ,  \"_bool\" , sep =  \"\" ) ; } }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  array ) ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } #-----webservice------------------------------------ else  {   filter =  NULL   attribute =  NULL   values =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   attribute =   switch (  type , hugo =  \"hgnc_symbol\" , agilentcgh =  \"agilent_cgh\" , agilentprobe =  \"agilent_probe\" , entrezgene =  \"entrezgene\" , locuslink =  \"entrezgene\" , embl =  \"embl\" , refseq =  \"refseq_dna\" , unigene =  \"unigene\" , affy =  array , ensembl =  \"ensembl_gene_id\" )  if (  !   missing (  symbol ) )  {   filter =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" )   attribute =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIM ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  OMIMID ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GO ) )  {   stop (  \"getFeature currently can only query for go descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GOID ) )  {   filter =  \"go\"   attribute =   c (  \"go\" ,  attribute )   values =  GOID }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {   filter =  \"chromosome_name\"   attribute =   c (  transid ,  chrname ,  attribute )   values =  chromosome } else  {   filter =   c (  chrname ,  startpos ,  endpos )   attribute =   c (  transid ,  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute )   values =   list (  chromosome ,  start ,  end ) } }   table =   getBM ( attributes =  attribute , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{          table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   is.null (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   GOTable -   mapSpeciesToGOTable (  species ) ;  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{     table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {     if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }   GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID -    get (  array ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   as.data.frame (  res ) } }   return (  table ) ; } #--webservice---------------------- else  {   goid =  \"go\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  goid ,  \"go_description\" ,  \"evidence_code\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  goid ,  \"go_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {  if (  !   missing (  array ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } else  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species , chromosome , start , end , mart )",
    "body": "{     if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    match (  \"snp\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to snp for this query.  Add connection to snp a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='snp',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) }  if (      missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) ||   missing (  species ) )  {   stop (  \"you have to give chromosome, start and end positions and species as arguments, see ?getSNP for more information\" ) }   table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( chromosome , start , end , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (   \"snp\" !=   mart @ biomart )  {   stop (  \"This function only works when using to snp. To use this function use: mart =  useMart('snp')\" ) }  if (     missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) )  {   stop (  \"you have to give chromosome, start and end positions as arguments, see ?getSNP for more information\" ) }  if (   mart @ mysql )  {      ensemblTable -   unique (    mart @ mainTables $ tables ) ;   query -   paste (  \"select external_id,  tscid, snp_chrom_start,chrom_strand ,allele, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ biomart ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) }   return (  res )   table -   as.data.frame (  res )    colnames (  res ) =   c (  \"refsnp_id\" ,  \"tscid\" ,  \"chromosome_start\" ,  \"strand\" ,  \"allele\" ,  \"coding\" ,  \"intronic\" ,  \"5utr\" ,  \"3utr\" ,  \"syn\" )   return (  table ) ; } else  {   tscid =  \"tscid\"   snpstart =  \"chrom_start\"   snpend =  \"chrom_end\"   attributes =   c (  tscid ,  \"refsnp_id\" ,  \"allele\" ,  \"chrom_start\" ,  \"chrom_strand\" )   table =   getBM ( attributes =  attributes , filters =   c (  \"chr_name\" ,  snpstart ,  snpend ) , values =   list (  chromosome ,  start ,  end ) , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

4.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.species , to.species , mart , output = \"martTable\" )",
    "body": "{        db =  \"ensembl\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {     from.type -  \"affy\" ;   from.species -   mapArrayToSpecies ( array =  from.array , mart =  mart ) ; } else  {  if (   missing (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) } }  if (  !   missing (  to.array ) )  {     to.type -  \"affy\" ;   to.species -   mapArrayToSpecies ( array =  to.array , mart =  mart ) ; } else  {  if (   missing (  to.species ) )  {    stop (  \"You must provide the species to map TO using the to.species  argument\" ) ; }  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , affy =   mapArrayToEnsemblTable (  from.array , species =  from.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  from.species , db =  db ) , flybase =   mapSpeciesToFlybase (  from.species ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  to.species , db =  db ) , affy =   mapArrayToEnsemblTable (  to.array , species =  to.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  to.species , db =  db ) , flybase =   mapSpeciesToFlybase (  to.species ) ) ;   fromCol -   getTableColumn (  from.type ) ;   toCol -   getTableColumn (  to.type ) ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.mart , to.mart )",
    "body": "{  if (      missing (  to.mart ) ||    class (  to.mart ) !=  'Mart' ||   missing (  from.mart ) ||    class (  from.mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    \"ensembl\" !=   to.mart @ biomart ||   \"ensembl\" !=   from.mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (   from.mart @ mysql )  {  if (  !   to.mart @ mysql )   stop (  \"Both mart object should both be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {    from.type -  \"affy\" ; } else  {  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type argument\" ) } }  if (  !   missing (  to.array ) )  {    to.type -  \"affy\" ; } else  {  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromCol =  NULL   toCol =  NULL   fromIDTable =  NULL   toIDTable =  NULL  if (   missing (  from.array ) )  {    fromIDTable -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ table   fromCol -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ field ; } else  {    fromIDTable -    get (  from.array ,   from.mart @ filters ) $ table   fromCol -    get (  from.array ,   from.mart @ filters ) $ field ; }  if (   missing (  to.array ) )  {    toIDTable -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ table   toCol -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ field ; } else  {    toIDTable -    get (  to.array ,   to.mart @ filters ) $ table   toCol -    get (  to.array ,   to.mart @ filters ) $ field ; }  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    from.mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   to.mart @ mysql )   stop (  \"The mart objects should either use both mysql or not. Here your from.mart does not use mysql but you to.mart does.\" )  if (   is.na (   match (  \"ensembl_gene_id\" ,   listAttributes (  to.mart ) ) ) )  {   to.attributes =   c (  \"gene_stable_id\" ,  \"transcript_stable_id\" )   geneid =  \"gene_stable_id\" } else  {   to.attributes =   c (  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" )   geneid =  \"ensembl_gene_id\" }   from.attributes =  NULL   filter =  NULL  if (  !   missing (  to.array ) )  {   to.attributes =   c (  to.attributes ,  to.array ) } else  {  if (   to.type ==  \"ensembl\" )  {   to.attributes =   c (  to.attributes ,  geneid ) } else  {   to.attributes =   c (  to.attributes ,   mapFilter (  to.type ) ) } }  if (  !   missing (  from.array ) )  {   from.attributes =   c (  from.attributes ,  from.array )   filter =  from.array } else  {  if (   from.type ==  \"ensembl\" )  {   from.attributes =   c (  from.attributes ,  geneid ) } else  {   from.attributes =   c (  from.attributes ,   mapFilter (  from.type ) ) }   filter =   mapFilter (  from.type ) }   xmlQuery =   paste (  \" ,   from.mart @ dataset ,  \"' , sep =  \"\" )   attributeXML =  \"\" #  paste(\"   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  \" ,  filter ,  \"' value = '\" ,  valuesString ,  \"' / , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  attributeXML ,  filterXML ,  \" ,   to.mart @ dataset ,  \"' , sep =  \"\" )   to.attributeXML =   paste (  \" ,  to.attributes ,  \"'/ , collapse =  \"\" , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  to.attributeXML ,  \" , sep =  \"\" )   species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   xmlQuery =   paste (  xmlQuery ,  \" ,   from.mart @ dataset ,  \"' target = '\" ,   to.mart @ dataset ,  \"' defaultLink = '\" ,  species ,  \"_internal_gene_id'/ , sep =  \"\" )   postRes =   postForm (   paste (   to.mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}

5.
{
  "old_function": {
    "name": "getINTERPRO",
    "representation": "getINTERPRO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{        genes -  NULL   speciesTable -  NULL #if(match(\"uniprot\",names(mart@connections),nomatch=0) == 0){ # stop(\"You are missing a database connection to uniprot for this query.  Add connection to uniprot a BioMart to your Mart object via the function martConnect.  Use the following command to do this:  martConnect(biomarts='uniprot',mart=mart,host='martdb.ebi.ac.uk',user='anonymous',password='')\") #}   db -  \"ensembl\" ;   results -  FALSE ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) } # if(match(\"uniprot\",names(mart@connections), nomatch=0) == 0){ #   stop(\"You need a connection to uniprot for this query, use martConnect and include 'uniprot' in your biomarts vector\") # }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   uniprotTable -   mapSpeciesToUNIPROTTable (  species ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , ensemblTrans =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   type ==  \"ensemblTrans\" )  {    query -   paste (  \"select distinct \" ,  uniprotTable ,  \".transcript_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  uniprotTable ,  \" where \" ,  uniprotTable ,  \".transcript_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  uniprotTable ,  \".interpro_list, short_description,\" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolID ,  \" in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( INTERPROID =  NA , shortdescription =  NA , description =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) , ] ; } else  {    res =   res [   order (  mt ) , ] ; }    names (  res ) =   c (  \"id\" ,  \"INTEPROID\" ,  \"short description\" ,  \"description\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getINTERPRO",
    "representation": "getINTERPRO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }   uniprotTable =    get (  \"interpro_ids\" ,   mart @ filters ) $ table   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   type ==  \"ensemblTrans\" )  {    query -   paste (  \"select distinct \" ,  uniprotTable ,  \".transcript_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  uniprotTable ,  \" where \" ,  uniprotTable ,  \".transcript_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  uniprotTable ,  \".interpro_list, short_description,\" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolID ,  \" in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) , ] ; } else  {    res =   res [   order (  mt ) , ] ; }    names (  res ) =   c (  \"id\" ,  \"INTEPROID\" ,  \"short description\" ,  \"description\" )   table -   as.data.frame (  res ) } }   return (  table ) } #--webservice-------------------------------- else  {   interproid =  \"interpro\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  interproid ,  \"interpro_description\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  interproid ,  \"interpro_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"interpro_id\" ,  \"description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species , chromosome , start , end , martTable , mart )",
    "body": "{    if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"sequence\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to sequence BioMart for this query.  Add connection to a sequence BioMart to your Mart object via the function martConnect. Use the following command to do this:  martConnect(biomarts='sequence',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password=''). \" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ; #need to use this from Ensembl v32 on!! #speciesTable  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {      martdb =  \"\" ;  if (    mart @ biomart !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    mart @ biomart =  \"sequence\" }     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } else  {   geneid =  \"gene_stable_id\"   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]  if (  !   missing (  chromosome ) )  {  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,  chromosome ,  \"'/ ,  start ,  \"'/ ,  end ,  \"'/ ,  species ,  \"_gene_ensembl' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }  if (  !   missing (  id ) )  {   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,   mapFilter (  type ) ,  \"' value = '\" ,  valuesString ,  \"'/ ,   mart @ dataset ,  \"' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  query )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , host , user , password , local = FALSE )",
    "body": "{    driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , mysqldriver =  driver )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (  \"you should provide host, user and password when using local databases\" ) } } else  {   database -   listMarts ( includeHosts =  TRUE )   m -   match (  biomart ,   database [ ,  1 ] , nomatch =  0 )  if (   m ==  0 )  {   stop (   paste (  \"BioMart \" ,  biomart ,  \" does not exist or can not be found\" , sep =  \"\" ) ) } else  {     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =   database [  m ,  2 ] , dbname =   database [  m ,  1 ] , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) } }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect biomart name\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , species , db = \"ensembl\" , mart )",
    "body": "{        IDTable -  NULL  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    db !=  \"ensembl\" undefined   db !=  \"vega\" )  {    stop (  \"you can only use ensembl or vega\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ;  if (   db !=  \"ensembl\" )  {    stop (  \"you can only use ensembl when working with affy id's\" ) ; } }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  db ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl, ensemblTrans or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  db ) , ensemblTrans =   paste (  species ,  \"_gene_ensembl__transcript__main\" , sep =  \"\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  db ) , hugo =   mapSpeciesToHUGO (  species , db =  db ) , refseq =   mapSpeciesToRefSeq (  species , db =  db ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ;   dbcolQID -   getTableColumn (  type ) ;  if (    db ==  \"ensembl\" ||   db ==  \"vega\" )  {  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }  if (   db ==  \"vega\" )  {   if (    match (  \"vega\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to vega for this query, use martConnect and include 'vega' in your biomarts vector\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ vega , statement =  query ) ; }  if (   db ==  \"ensembl\" )  {    res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ; }  if (     dim (  res ) [  1 ] ==  0 )  {    table -   new (  \"martTable\" , id =  id , table =   list ( symbol =  NA , description =  NA , band =  NA , chromosome =  NA , start =  NA , end =  NA , martID =  NA ) ) ; } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"martID\" ) ;   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) ; } } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    mart @ biomart !=  \"ensembl\" )  {    stop (  \"you can only use ensembl for this query.  Please do: useMart('ensembl').  To access VEGA you have to use the more advanced biomaRt function:  useMart. listDatasets, useDataset, listFilters, listAttributes and getBM.\" ) ; }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ; }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } #MySQL-----------------------------------------------------------  if (   mart @ mysql )  {    if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end, chrom_strand  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end,\" ,  speciesTable ,  \".chrom_strand  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   writeLines (  \"Query retrieved no results\" )   return (  NULL ) } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"strand\" ,  \"martID\" ) ;   table -   as.data.frame (  res )   return (  table ) ; } } } #Webservice----------------------------------------------------- else  {   startpos =  \"start_position\"   endpos =  \"end_position\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   symbol =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"symbol\" ,  \"description\" ,  \"chromosome\" ,  \"band\" ,  \"strand\" ,  \"chromosome_start\" ,  \"chromosome_end\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , species , chromosome , start , end , type , mart )",
    "body": "{       table -  NULL  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {    stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) ; }  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {     species -   mapArrayToSpecies ( array =  array , mart =  mart ) ;   affyBool -   mapArrayToEnsemblTable ( array =  array , species =  species , mart =  mart , dbtable =  \"affybool\" ) ; } else  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } } else  {  if (   missing (  species ) )  {   stop (  \"you must provide the species, valid species names can be found by using the function getSpecies()\" ) } }   speciesTable -   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) ;   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -   mapSpeciesToGOTable (  species ) ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , chromosome , start , end , type , mart )",
    "body": "{  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function martConnect\" ) ; }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {    if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {    affyBool -   paste (  array ,  \"_bool\" , sep =  \"\" ) ; } }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  array ) ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } #-----webservice------------------------------------ else  {   filter =  NULL   attribute =  NULL   values =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   attribute =   switch (  type , hugo =  \"hgnc_symbol\" , agilentcgh =  \"agilent_cgh\" , agilentprobe =  \"agilent_probe\" , entrezgene =  \"entrezgene\" , locuslink =  \"entrezgene\" , embl =  \"embl\" , refseq =  \"refseq_dna\" , unigene =  \"unigene\" , affy =  array , ensembl =  \"ensembl_gene_id\" )  if (  !   missing (  symbol ) )  {   filter =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" )   attribute =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIM ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  OMIMID ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GO ) )  {   stop (  \"getFeature currently can only query for go descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GOID ) )  {   filter =  \"go\"   attribute =   c (  \"go\" ,  attribute )   values =  GOID }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {   filter =  \"chromosome_name\"   attribute =   c (  transid ,  chrname ,  attribute )   values =  chromosome } else  {   filter =   c (  chrname ,  startpos ,  endpos )   attribute =   c (  transid ,  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute )   values =   list (  chromosome ,  start ,  end ) } }   table =   getBM ( attributes =  attribute , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{          table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }  if (   type ==  \"affy\" )  {  if (   is.null (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   GOTable -   mapSpeciesToGOTable (  species ) ;  if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy,  entrezgene, hugo, ensembl, refseq or embl\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  \"ensembl\" ) ; #get database id col   dbcolQID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{     table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {     if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }   GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID -    get (  array ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   as.data.frame (  res ) } }   return (  table ) ; } #--webservice---------------------- else  {   goid =  \"go\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  goid ,  \"go_description\" ,  \"evidence_code\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  goid ,  \"go_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {  if (  !   missing (  array ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } else  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( species , chromosome , start , end , martTable , mart )",
    "body": "{    if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"sequence\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to sequence BioMart for this query.  Add connection to a sequence BioMart to your Mart object via the function martConnect. Use the following command to do this:  martConnect(biomarts='sequence',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password=''). \" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ; #need to use this from Ensembl v32 on!! #speciesTable  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ sequence , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {      martdb =  \"\" ;  if (    mart @ biomart !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    mart @ biomart =  \"sequence\" }     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (      missing (  martTable ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } else  {  if (  !   missing (  martTable ) )  { #check class!!      chromosome =    martTable @ table $ chromosome ;   start =    martTable @ table $ start ;   end =    martTable @ table $ end ;  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } } }   table -   new (  \"martTable\" , id =   paste (  chromosome ,  start ,  end , sep =  \"_\" ) , table =   list ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence ) )   return (  table ) } else  {   geneid =  \"gene_stable_id\"   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]  if (  !   missing (  chromosome ) )  {  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,  chromosome ,  \"'/ ,  start ,  \"'/ ,  end ,  \"'/ ,  species ,  \"_gene_ensembl' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }  if (  !   missing (  id ) )  {   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,   mapFilter (  type ) ,  \"' value = '\" ,  valuesString ,  \"'/ ,   mart @ dataset ,  \"' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  query )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}

4.
{
  "old_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( species , chromosome , start , end , mart )",
    "body": "{     if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (    match (  \"snp\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You are missing a database connection to snp for this query.  Add connection to snp a BioMart to your Mart object via the function martConnect.   Use the following command to do this:  martConnect(biomarts='snp',mart=mart,host='ensembldb.ensembl.org',user='anonymous',password='')\" ) }  if (      missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) ||   missing (  species ) )  {   stop (  \"you have to give chromosome, start and end positions and species as arguments, see ?getSNP for more information\" ) }   table -  NULL   ensemblTable -   paste (  species ,  \"_snp__snp__main\" , sep =  \"\" ) ;   query -   paste (  \"select snp_id_key,snp_chrom_start, allele, tscid, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ snp ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) } else  {   table -   new (  \"martTable\" , id =   res $ tscid , table =   list ( snpStart =   res [ ,  2 ] , allele =   res $ allele , coding =   res [ ,  5 ] , intronic =   res [ ,  6 ] , syn =   res [ ,  9 ] , utr5 =   res [ ,  7 ] , utr3 =   res [ ,  8 ] ) ) }   return (  table ) ; } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSNP",
    "representation": "getSNP",
    "parameters": "function ( chromosome , start , end , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (   \"snp\" !=   mart @ biomart )  {   stop (  \"This function only works when using to snp. To use this function use: mart =  useMart('snp')\" ) }  if (     missing (  chromosome ) ||   missing (  start ) ||   missing (  end ) )  {   stop (  \"you have to give chromosome, start and end positions as arguments, see ?getSNP for more information\" ) }  if (   mart @ mysql )  {      ensemblTable -   unique (    mart @ mainTables $ tables ) ;   query -   paste (  \"select external_id,  tscid, snp_chrom_start,chrom_strand ,allele, ensemblcoding_bool, ensemblintronic_bool, ensembl5utr_bool, ensembl3utr_bool, ensemblsyn_bool from \" ,  ensemblTable ,  \" where chr_name = '\" ,  chromosome ,  \"' and snp_chrom_start ,  start ,  \" and snp_chrom_start ,  end , sep =  \"\" )   res -   dbGetQuery (    mart @ connections $ biomart ,  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   stop (  \"No SNP's found in selected region, check if the input you entered is correct\" ) }   return (  res )   table -   as.data.frame (  res )    colnames (  res ) =   c (  \"refsnp_id\" ,  \"tscid\" ,  \"chromosome_start\" ,  \"strand\" ,  \"allele\" ,  \"coding\" ,  \"intronic\" ,  \"5utr\" ,  \"3utr\" ,  \"syn\" )   return (  table ) ; } else  {   tscid =  \"tscid\"   snpstart =  \"chrom_start\"   snpend =  \"chrom_end\"   attributes =   c (  tscid ,  \"refsnp_id\" ,  \"allele\" ,  \"chrom_start\" ,  \"chrom_strand\" )   table =   getBM ( attributes =  attributes , filters =   c (  \"chr_name\" ,  snpstart ,  snpend ) , values =   list (  chromosome ,  start ,  end ) , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

5.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.species , to.species , mart , output = \"martTable\" )",
    "body": "{        db =  \"ensembl\" ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {     from.type -  \"affy\" ;   from.species -   mapArrayToSpecies ( array =  from.array , mart =  mart ) ; } else  {  if (   missing (  from.species ) )  {   stop (  \"You must provide the species to map FROM using the  from.species argument\" ) }  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type  argument\" ) } }  if (  !   missing (  to.array ) )  {     to.type -  \"affy\" ;   to.species -   mapArrayToSpecies ( array =  to.array , mart =  mart ) ; } else  {  if (   missing (  to.species ) )  {    stop (  \"You must provide the species to map TO using the to.species  argument\" ) ; }  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromIDTable -   switch (  from.type , entrezgene =   mapSpeciesToEntrezGene (  from.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  from.species , db =  db ) , embl =   mapSpeciesToEMBL (  from.species ) , hugo =   mapSpeciesToHUGO (  from.species , db =  db ) , affy =   mapArrayToEnsemblTable (  from.array , species =  from.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  from.species , db =  db ) , flybase =   mapSpeciesToFlybase (  from.species ) ) ;   toIDTable -   switch (  to.type , entrezgene =   mapSpeciesToEntrezGene (  to.species , db =  db ) , refseq =   mapSpeciesToRefSeq (  to.species , db =  db ) , embl =   mapSpeciesToEMBL (  to.species ) , hugo =   mapSpeciesToHUGO (  to.species , db =  db ) , affy =   mapArrayToEnsemblTable (  to.array , species =  to.species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  to.species , db =  db ) , flybase =   mapSpeciesToFlybase (  to.species ) ) ;   fromCol -   getTableColumn (  from.type ) ;   toCol -   getTableColumn (  to.type ) ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( MappedID =   rep (  NA ,   length (  id ) ) ) ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   new (  \"martTable\" , id =  foundID , table =   list ( MappedID =  MappedID ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.mart , to.mart )",
    "body": "{  if (      missing (  to.mart ) ||    class (  to.mart ) !=  'Mart' ||   missing (  from.mart ) ||    class (  from.mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function martConnect\" ) }  if (    \"ensembl\" !=   to.mart @ biomart ||   \"ensembl\" !=   from.mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (   from.mart @ mysql )  {  if (  !   to.mart @ mysql )   stop (  \"Both mart object should both be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {    from.type -  \"affy\" ; } else  {  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type argument\" ) } }  if (  !   missing (  to.array ) )  {    to.type -  \"affy\" ; } else  {  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromCol =  NULL   toCol =  NULL   fromIDTable =  NULL   toIDTable =  NULL  if (   missing (  from.array ) )  {    fromIDTable -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ table   fromCol -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ field ; } else  {    fromIDTable -    get (  from.array ,   from.mart @ filters ) $ table   fromCol -    get (  from.array ,   from.mart @ filters ) $ field ; }  if (   missing (  to.array ) )  {    toIDTable -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ table   toCol -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ field ; } else  {    toIDTable -    get (  to.array ,   to.mart @ filters ) $ table   toCol -    get (  to.array ,   to.mart @ filters ) $ field ; }  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    from.mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   to.mart @ mysql )   stop (  \"The mart objects should either use both mysql or not. Here your from.mart does not use mysql but you to.mart does.\" )  if (   is.na (   match (  \"ensembl_gene_id\" ,   listAttributes (  to.mart ) ) ) )  {   to.attributes =   c (  \"gene_stable_id\" ,  \"transcript_stable_id\" )   geneid =  \"gene_stable_id\" } else  {   to.attributes =   c (  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" )   geneid =  \"ensembl_gene_id\" }   from.attributes =  NULL   filter =  NULL  if (  !   missing (  to.array ) )  {   to.attributes =   c (  to.attributes ,  to.array ) } else  {  if (   to.type ==  \"ensembl\" )  {   to.attributes =   c (  to.attributes ,  geneid ) } else  {   to.attributes =   c (  to.attributes ,   mapFilter (  to.type ) ) } }  if (  !   missing (  from.array ) )  {   from.attributes =   c (  from.attributes ,  from.array )   filter =  from.array } else  {  if (   from.type ==  \"ensembl\" )  {   from.attributes =   c (  from.attributes ,  geneid ) } else  {   from.attributes =   c (  from.attributes ,   mapFilter (  from.type ) ) }   filter =   mapFilter (  from.type ) }   xmlQuery =   paste (  \" ,   from.mart @ dataset ,  \"' , sep =  \"\" )   attributeXML =  \"\" #  paste(\"   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  \" ,  filter ,  \"' value = '\" ,  valuesString ,  \"' / , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  attributeXML ,  filterXML ,  \" ,   to.mart @ dataset ,  \"' , sep =  \"\" )   to.attributeXML =   paste (  \" ,  to.attributes ,  \"'/ , collapse =  \"\" , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  to.attributeXML ,  \" , sep =  \"\" )   species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   xmlQuery =   paste (  xmlQuery ,  \" ,   from.mart @ dataset ,  \"' target = '\" ,   to.mart @ dataset ,  \"' defaultLink = '\" ,  species ,  \"_internal_gene_id'/ , sep =  \"\" )   postRes =   postForm (   paste (   to.mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}

6.
{
  "old_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id , from.species , to.species , from.xref , to.xref , db = \"ensembl\" , mart )",
    "body": "{   if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) }  if (   missing (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   missing (  from.species ) )  {      writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ;   print (   getSpecies ( mart =  mart , db =  \"ensembl\" ) ) ;   stop ( ) ; }  if (    missing (  from.xref ) ||   missing (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   missing (  to.species ) )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   db ==  'vega' )  {   stop (  'VEGA supports only hsapiens' ) }  if (   from.species ==  to.species )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( con =    mart @ connections $ ensembl ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getXref",
    "representation": "getXref",
    "parameters": "function ( id , from.species , to.species , from.xref , to.xref , mart )",
    "body": "{   if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  'You must specify a valid Mart object which can be created using martConnect().' ) ; }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (  !   mart @ mysql )   stop (  \"This function only works via MySQL access to the BioMart.  Create a new Mart object using the function useMart('ensembl',mysql=TRUE)\" )  if (   missing (  id ) )  {    stop (  'You need to give ID(s) to map from' ) ; }  if (   missing (  from.species ) )  {     writeLines (  'fromspecies is a necessary argument\\nValid species for this mart are:' ) ; #print( getSpecies(mart = mart, db = \"ensembl\" ));   stop ( ) ; }  if (    missing (  from.xref ) ||   missing (  to.xref ) )  {      writeLines (  'Both fromxref and toxref are required.\\nPossible crossreferences are:' ) ;   print (   getPossibleXrefs ( mart =  mart ) ) ;   stop ( ) ; }   xp -   paste (  id , collapse =  \"','\" )  if (   missing (  to.species ) )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   from.species ==  to.species )  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,' ,  'a.gene_stable_id as ensemblgene ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on a.gene_id_key=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  'SELECT distinct a.dbprimary_id as fromid,b.dbprimary_id as toid,c.* ' ,  'from ' ,  from.species ,  '_gene_ensembl__xref_' ,  from.xref ,  '__dm as a ' ,  'left join ' ,  from.species ,  '_gene_ensembl__homologs_' ,  to.species ,  '__dm as c ' ,  'on a.gene_id_key=c.gene_id_key ' ,  'left join ' ,  to.species ,  '_gene_ensembl__xref_' ,  to.xref ,  '__dm as b ' ,  \"on c.homol_id=b.gene_id_key where a.dbprimary_id in ('\" ,  xp ,  \"') and b.dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( con =    mart @ connections $ biomart ,  query ) ;  if (     dim (  res ) [  1 ] undefined  0 )  {    table -   new (  \"martTable\" , id =   res [ ,  1 ] , table =   list ( from.id =   res [ ,  1 ] , to.id =   res [ ,  2 ] , martID =   res [ ,  3 ] ) ) ; } else  {    table -   new (  \"martTable\" , id =  id , table =   list ( from.id =  NA , to.id =  NA , martID =  NA ) ) ; }   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

7.
{
  "old_function": {
    "name": "getINTERPRO",
    "representation": "getINTERPRO",
    "parameters": "function ( id , type , array , species , mart )",
    "body": "{        genes -  NULL   speciesTable -  NULL #if(match(\"uniprot\",names(mart@connections),nomatch=0) == 0){ # stop(\"You are missing a database connection to uniprot for this query.  Add connection to uniprot a BioMart to your Mart object via the function martConnect.  Use the following command to do this:  martConnect(biomarts='uniprot',mart=mart,host='martdb.ebi.ac.uk',user='anonymous',password='')\") #}   db -  \"ensembl\" ;   results -  FALSE ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (    match (  \"ensembl\" ,   names (   mart @ connections ) , nomatch =  0 ) ==  0 )  {   stop (  \"You need a connection to ensembl for this query, use martConnect and include 'ensembl' in your biomarts vector\" ) } # if(match(\"uniprot\",names(mart@connections), nomatch=0) == 0){ #   stop(\"You need a connection to uniprot for this query, use martConnect and include 'uniprot' in your biomarts vector\") # }  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (   type ==  \"affy\" )  {  if (   missing (  array ) )  {    stop (  \"you must provide the affymetrix array identifier via the array argument when using this function for affy identifiers\" ) ; } else  {    species -   mapArrayToSpecies ( array =  array , mart =  mart ) ; } } else  {  if (   missing (  species ) )  {    stop (  \"you must provide the species via the species argument when using this function for Ensembl identifiers\" ) ; } }   uniprotTable -   mapSpeciesToUNIPROTTable (  species ) ;  if (         !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"ensemblTrans\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo, ensembl or entrezgene\" ) ; }   IDTable -   switch (  type , affy =   mapArrayToEnsemblTable (  array , species =  species , mart =  mart , dbtable =  \"xrefdm\" ) , ensembl =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , ensemblTrans =   mapSpeciesToGeneTable (  species , db =  \"ensembl\" ) , entrezgene =   mapSpeciesToEntrezGene (  species , db =  \"ensembl\" ) , hugo =   mapSpeciesToHUGO (  species , db =  \"ensembl\" ) , refseq =   mapSpeciesToRefSeq (  species , db =  \"ensembl\" ) , embl =   mapSpeciesToEMBL (  species ) , flybase =   mapSpeciesToFlybase (  species ) ) ;   dbcolID -   getTableColumn (  type ) ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   type ==  \"ensemblTrans\" )  {    query -   paste (  \"select distinct \" ,  uniprotTable ,  \".transcript_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  uniprotTable ,  \" where \" ,  uniprotTable ,  \".transcript_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  uniprotTable ,  \".interpro_list, short_description,\" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolID ,  \" in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ ensembl , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( INTERPROID =  NA , shortdescription =  NA , description =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) , ] ; } else  {    res =   res [   order (  mt ) , ] ; }    names (  res ) =   c (  \"id\" ,  \"INTEPROID\" ,  \"short description\" ,  \"description\" )   table -   new (  \"martTable\" , id =   as.vector (   res [ ,  1 ] ) , table =   as.list (   res [ ,  -  1 ] ) ) } }   return (  table ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getINTERPRO",
    "representation": "getINTERPRO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function martConnect\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {  if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }   uniprotTable =    get (  \"interpro_ids\" ,   mart @ filters ) $ table   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".gene_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".gene_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {  if (   type ==  \"ensemblTrans\" )  {    query -   paste (  \"select distinct \" ,  uniprotTable ,  \".transcript_stable_id,\" ,  uniprotTable ,  \".interpro_list, short_description, \" ,  uniprotTable ,  \".description from \" ,  uniprotTable ,  \" where \" ,  uniprotTable ,  \".transcript_stable_id in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  uniprotTable ,  \".interpro_list, short_description,\" ,  uniprotTable ,  \".description from \" ,  IDTable ,  \" inner join \" ,  uniprotTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  uniprotTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolID ,  \" in (\" ,  ids ,  \") and \" ,  uniprotTable ,  \".interpro_list != 'NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) , ] ; } else  {    res =   res [   order (  mt ) , ] ; }    names (  res ) =   c (  \"id\" ,  \"INTEPROID\" ,  \"short description\" ,  \"description\" )   table -   as.data.frame (  res ) } }   return (  table ) } #--webservice-------------------------------- else  {   interproid =  \"interpro\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  interproid ,  \"interpro_description\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  interproid ,  \"interpro_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"interpro_id\" ,  \"description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

8.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , host , user , password , local = FALSE )",
    "body": "{    driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , mysqldriver =  driver )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (  \"you should provide host, user and password when using local databases\" ) } } else  {   database -   listMarts ( includeHosts =  TRUE )   m -   match (  biomart ,   database [ ,  1 ] , nomatch =  0 )  if (   m ==  0 )  {   stop (   paste (  \"BioMart \" ,  biomart ,  \" does not exist or can not be found\" , sep =  \"\" ) ) } else  {     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =   mart @ mysqldriver , user =  \"anonymous\" , host =   database [  m ,  2 ] , dbname =   database [  m ,  1 ] , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) } }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect biomart name\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  }
}

9.
{
  "old_function": {
    "name": "getBM",
    "representation": "getBM",
    "parameters": "function ( attributes , filter , values , mart )",
    "body": "{   query -   queryGenerator ( attributes =  attributes , filters =  filter , values =  values , mart =  mart )   res -   dbGetQuery (    mart @ connections $ biomart ,  query )  if (     dim (  res ) [  1 ] ==  0 )  {   res -   data.frame ( ) } else  {       mt =   match (   res [ ,  1 ] ,  values ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;   res =   res [   order (  mt ) , ] ;    names (  res ) =   c (  filter ,  attributes ) ; }   return (   as.data.frame (  res ) ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getBM",
    "representation": "getBM",
    "parameters": "function ( attributes , filters , values , mart , curl = NULL , output = \"data.frame\" , list.names = NULL , na.value = NA )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )   stop (  \"Argument 'mart' must be specified and be of class 'Mart'.\" )  if (   missing (  attributes ) )   stop (  \"Argument 'attributes' must be specified.\" )  if (   missing (  filters ) )   stop (  \"Argument 'filters' must be specified.\" )  if (   missing (  values ) )   stop (  \"Argument 'values' must be specified.\" )  if (    output !=  \"data.frame\" undefined   output !=  \"list\" )   stop (  \"Only data.frame and list are valid output formats for this function\" )  for  ( i in   1 :   length (  attributes ) )  {  if (  !   exists (   attributes [  i ] ,   mart @ attributes ) )   stop (   paste (  \"attribute: \" ,   attributes [  i ] ,  \" not found, please use the function 'listAttributes' to get valid attribute names\" , sep =  \"\" ) ) }  for  ( i in   1 :   length (  filters ) )  {  if (  !   exists (   filters [  i ] ,   mart @ filters ) )   stop (   paste (  \"filter: \" ,   filters [  i ] ,  \" not found, please use the function 'listFilters' to get valid filter names\" , sep =  \"\" ) ) } ## use the mySQL interface  if (   mart @ mysql )  {  if (   output ==  \"data.frame\" )  {  if (    length (  filters ) undefined  1 )   stop (  \"biomaRt currently allows only one filter per query, reduce the number of filters to one\" )   query -   queryGenerator ( attributes =  attributes , filter =  filters , values =  values , mart =  mart )   res -   dbGetQuery (    mart @ connections $ biomart ,  query )  if (     dim (  res ) [  1 ] ==  0 )  {   res -   data.frame ( ) } else  {       mt =   match (   res [ ,  1 ] ,  values ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;   res =   res [   order (  mt ) , ] ;    names (  res ) =   c (  filters ,  attributes ) ; }   return (   as.data.frame (  res ) ) } else  {   out -   vector (  \"list\" ,   length (  attributes ) )  if (   is.null (  list.names ) )    names (  out ) -  attributes else    names (  out ) -  list.names  for  ( j in   seq ( along =  attributes ) )  {   tmp -   getBM (   attributes [  j ] ,  filters ,  values ,  mart )   tmp2 -   vector (  \"list\" ,   length (  values ) )    names (  tmp2 ) -  values  for  ( i in   seq ( along =  tmp2 ) )  {   tst -   tmp [    tmp [ ,  1 ] %in%   values [  i ] ,  2 ]   tst -   tst [  !   is.na (  tst ) ]  if (    length (  tst ) ==  0 )   tst -  na.value    tmp2 [[  i ] ] -  tst }    out [[  j ] ] -  tmp2 }   return (  out ) } } else  {  if (   output ==  \"data.frame\" )  { ## use the http/XML interface   xmlQuery =   paste (  \" ,   mart @ dataset ,  \"' , sep =  \"\" )   attributeXML =   paste (  \" ,  attributes ,  \"'/ , collapse =  \"\" , sep =  \"\" )  if (    length (  filters ) undefined  1 )  {   if (    class (  values ) !=  \"list\" )   stop (  \"If using multiple filters, the 'value' has to be a list.\\nFor example, a valid list for 'value' could be: list(affyid=c('1939_at','1000_at'), chromosome= '16')\\nHere we select on affyid and chromosome, only results that pass both filters will be returned\" ) ;   filterXML =  NULL  for  ( i in   1 :   length (  filters ) )  {   valuesString =   paste (   values [[  i ] ] ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  filterXML ,   paste (  \" ,   filters [  i ] ,  \"' value = '\" ,  valuesString ,  \"' / , collapse =  \"\" , sep =  \"\" ) , sep =  \"\" ) } } else  {   valuesString =   paste (  values ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  \" ,  filters ,  \"' value = '\" ,  valuesString ,  \"' / , collapse =  \"\" , sep =  \"\" ) }   xmlQuery =   paste (  xmlQuery ,  attributeXML ,  filterXML ,  \" , sep =  \"\" )  if (   is.null (  curl ) )  {   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery ) } else  {   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery , curl =  curl ) }  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con )  if (    substr (   as.character (   result [  1 ] ) ,  1 ,  5 ) ==  \"ERROR\" )  { #Will forward the webservice error   stop (   paste (  \"\\n\" ,  result ,  \"The following query was attempted, use this to report this error\\n\" ,  xmlQuery , sep =  \"\\n\" ) ) } ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ]   stopifnot (    ncol (  result ) ==   length (  attributes ) )  if (    class (  result ) ==  \"data.frame\" )  {    colnames (  result ) =  attributes } } else  { #stop(\"The getBM query to BioMart webservice returned no result.  The webservice could be temporarily down, please try query again.\")   result =  NULL }   return (  result ) } else  {   out -   vector (  \"list\" ,   length (  attributes ) )  if (   is.null (  list.names ) )    names (  out ) -  attributes else    names (  out ) -  list.names #curl  for  ( j in   seq ( along =  attributes ) )  {   tmp2 -   vector (  \"list\" ,   length (  values ) )    names (  tmp2 ) -  values  for  ( k in   seq ( along =  tmp2 ) )  { #   tst   tst -   getBM ( attributes =   attributes [  j ] , filters =  filters , values =   values [  k ] , mart =  mart )  if (  !   is.null (  tst ) )  {   tmp -   unlist (   unique (   tst [  !   is.na (  tst ) ] ) , use.names =  FALSE )  if (    length (  tmp ) undefined  0 )    tmp2 [[  k ] ] -  tmp else    tmp2 [[  k ] ] -  na.value } else  {    tmp2 [[  k ] ] -  na.value }    out [[  j ] ] -  tmp2 } }   return (  out ) } } } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_1_8 biomart_release_1_9

{
    "package": "biomaRt",
    "release_versions": "biomart_release_1_8 biomart_release_1_9",
    "desc_release_old": "1.6.3",
    "desc_release_new": "1.8.2",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 1,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 2,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 3
}

##########
Functions Removed
##########

martConnect


##########
Functions Added
##########

cleanBM


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , includeHosts = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     require (  RMySQL )  if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ,  \"sequence\" ,  \"wormbase\" ) }  if (   missing (  host ) )  {   host -   c (  \"ensembldb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest -  j ;   version -  v ; } } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   registry =   getURL (   paste (  host ,  \"?type=registry\" , sep =  \"\" ) )   registry =   xmlTreeParse (  registry )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL )   index =  1  for  ( i in   1 :   xmlSize (  registry ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   1 :   xmlSize (   registry [[  i ] ] ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )   index =   index +  1 } } }   return (  marts ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , port , includeHosts = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     require (  RMySQL )  if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ,  \"sequence\" ,  \"wormbase\" ) }  if (   missing (  host ) )  {   host -   c (  \"martdb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" )   port =   c (  3316 ,  3306 ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] , port =   port [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest -  j ;   version -  v ; } } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   registry =   getURL (   paste (  host ,  \"?type=registry\" , sep =  \"\" ) )   registry =   xmlTreeParse (  registry )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL )   index =  1  for  ( i in   1 :   xmlSize (  registry ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   1 :   xmlSize (   registry [[  i ] ] ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) } else  {     marts $ vschema [  index ] =  vschema }   index =   index +  1 } } }  if (  includeHosts )  {   return (  marts ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version )    colnames (  ret ) =   c (  \"name\" ,  \"version\" )   return (  ret ) } } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect biomart name\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , port , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (     !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) undefined  !   missing (  port ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password , port =  port ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password , port =  port )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , dbname =  martdb , password =  \"\" , port =  3316 )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host , includeHosts =  TRUE )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , includeHosts = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     require (  RMySQL )  if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ,  \"sequence\" ,  \"wormbase\" ) }  if (   missing (  host ) )  {   host -   c (  \"ensembldb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest -  j ;   version -  v ; } } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   registry =   getURL (   paste (  host ,  \"?type=registry\" , sep =  \"\" ) )   registry =   xmlTreeParse (  registry )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL )   index =  1  for  ( i in   1 :   xmlSize (  registry ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   1 :   xmlSize (   registry [[  i ] ] ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )   index =   index +  1 } } }   return (  marts ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , port , includeHosts = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     require (  RMySQL )  if (   missing (  mart ) )  {   mart -   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"msd\" ,  \"uniprot\" ,  \"sequence\" ,  \"wormbase\" ) }  if (   missing (  host ) )  {   host -   c (  \"martdb.ensembl.org\" ,  \"martdb.ebi.ac.uk\" )   user -   c (  \"anonymous\" ,  \"anonymous\" )   password -   c (  \"\" ,  \"\" )   port =   c (  3316 ,  3306 ) }   database -  NULL   driv -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   1 :   length (  host ) )  {     connection -   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] , port =   port [  i ] ) ;   res -   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  for  ( j in   1 :   length (  mart ) )  {     matches -   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version -  1 ;   latest -  1 ;  for  ( j in   1 :   length (  matches ) )  {    v -   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  j ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest -  j ;   version -  v ; } } }  if (  !  includeHosts )  {   database -   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database -   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {     database -   c (  database ,   res [  matches ,  1 ] ) ;   v -   as.numeric (     strsplit (   res [  matches ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ; } else  {    database -   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   registry =   getURL (   paste (  host ,  \"?type=registry\" , sep =  \"\" ) )   registry =   xmlTreeParse (  registry )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL )   index =  1  for  ( i in   1 :   xmlSize (  registry ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   1 :   xmlSize (   registry [[  i ] ] ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) } else  {     marts $ vschema [  index ] =  vschema }   index =   index +  1 } } }  if (  includeHosts )  {   return (  marts ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version )    colnames (  ret ) =   c (  \"name\" ,  \"version\" )   return (  ret ) } } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (    !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect biomart name\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , port , local = FALSE , mysql = FALSE )",
    "body": "{  if (  mysql )  {    require (  RMySQL )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE )  if (  !  (    is.character (  biomart ) undefined  (    length (  biomart ) ==  1 ) ) )   stop (  \"'biomart' should be a single character string.\" )  if (  local )  {  if (     !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) undefined  !   missing (  port ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password , port =  port ) ;     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  user , host =  host , dbname =  database , password =  password , port =  port )   writeLines (   paste (  \"connected to: \" ,   database [  1 ,  1 ] ) ) } else  {   stop (   sprintf (  \"Please provide host, user and password for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , dbname =  martdb , password =  \"\" , port =  3316 )   writeLines (   paste (  \"connected to: \" ,  biomart ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host , includeHosts =  TRUE )   mindex =   match (  biomart ,   marts $ biomart )  if (   is.na (  mindex ) )  {   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" ) }  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_1_9 biomart_release_2_1

{
    "package": "biomaRt",
    "release_versions": "biomart_release_1_9 biomart_release_2_1",
    "desc_release_old": "1.8.2",
    "desc_release_new": "1.12.2",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 5,
    "function_additions": 6,
    "parameter_removals": 4,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 6,
    "total_count": 11
}

##########
Functions Removed
##########

getOMIM
getPossibleXrefs
getXref
getINTERPRO
cleanBM


##########
Functions Added
##########

getLDS
attributeSummary
filterSummary
filterOptions
filterType
show


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function useMart\" ) }  if (    mart @ biomart !=  \"ensembl\" )  {    stop (  \"you can only use ensembl for this query.  Please do: useMart('ensembl').  To access VEGA you have to use the more advanced biomaRt function:  useMart. listDatasets, useDataset, listFilters, listAttributes and getBM.\" ) ; }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ; }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } #MySQL-----------------------------------------------------------  if (   mart @ mysql )  {    if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end, chrom_strand  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end,\" ,  speciesTable ,  \".chrom_strand  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   writeLines (  \"Query retrieved no results\" )   return (  NULL ) } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"strand\" ,  \"martID\" ) ;   table -   as.data.frame (  res )   return (  table ) ; } } } #Webservice----------------------------------------------------- else  {   startpos =  \"start_position\"   endpos =  \"end_position\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   symbol =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"symbol\" ,  \"description\" ,  \"chromosome\" ,  \"band\" ,  \"strand\" ,  \"chromosome_start\" ,  \"chromosome_end\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , mart )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  type ,  mart )   symbolAttrib =   switch (     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ] , hsapiens =  \"hgnc_symbol\" , mmusculus =  \"mgi_symbol\" ,  \"external_gene_id\" )   typeAttrib =   switch (  type , affy_hg_u133a_2 =  \"affy_hg_u133a_v2\" ,  type )   attrib =   c (  typeAttrib ,  symbolAttrib ,  \"description\" ,  \"chromosome_name\" ,  \"band\" ,  \"strand\" ,  \"start_position\" ,  \"end_position\" ,  \"ensembl_gene_id\" )   table =   getBM ( attributes =  attrib , filters =  type , values =  id , mart =  mart )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , chromosome , start , end , type , mart )",
    "body": "{  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function useMart\" ) ; }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {    if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {    affyBool -   paste (  array ,  \"_bool\" , sep =  \"\" ) ; } }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  array ) ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } #-----webservice------------------------------------ else  {   filter =  NULL   attribute =  NULL   values =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   attribute =   switch (  type , hugo =  \"hgnc_symbol\" , agilentcgh =  \"agilent_cgh\" , ensemblTrans =  \"ensembl_transcript_id\" , agilentprobe =  \"agilent_probe\" , entrezgene =  \"entrezgene\" , locuslink =  \"entrezgene\" , embl =  \"embl\" , refseq =  \"refseq_dna\" , unigene =  \"unigene\" , affy =  array , ensembl =  \"ensembl_gene_id\" )  if (  !   missing (  symbol ) )  {   filter =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )   attribute =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIM ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  OMIMID ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GO ) )  {   stop (  \"getFeature currently can only query for go descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GOID ) )  {   filter =  \"go\"   attribute =   c (  \"go\" ,  attribute )   values =  GOID }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {   filter =  \"chromosome_name\"   attribute =   c (  transid ,  chrname ,  attribute )   values =  chromosome } else  {   filter =   c (  chrname ,  startpos ,  endpos )   attribute =   c (  transid ,  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute )   values =   list (  chromosome ,  start ,  end ) } }   table =   getBM ( attributes =  attribute , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIMID , GOID , chromosome , start , end , type , mart )",
    "body": "{   .Deprecated (  \"getBM\" , package =  \"biomaRt\" , msg =  \"The functionality of getFeature is completely incorporated in getBM and many more getFeature type of queries are possible with getBM. For example to retrieve a set of affymetrix u133plus2 array probes for genes that are located on chromosome 2 between basepair 14000 and 30000 do:  getBM('affy_hg_u133_plus_2', filters=c('chromosome_name', 'start','end'), values=list(2,300000,1000000), mart=yourmartobject)\" )   martCheck (  mart ,  \"ensembl\" )  if (   missing (  type ) )   stop (  \"You must provide the identifier type using the type argument.  Values for the type argument are given by the listAttributes function, see ?listAttributes for more information.\" )  if (  !   type %in%   ls (   martAttributes (  mart ) ) )   stop (  \"Invalid identifier type see ?getGene for details. Use listAttributes function to get the valid values for the type argument\" )  if (     martMySQL (  mart ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) )  {       speciesTable -   unique (     martMainT (  mart ) $ tables [     martMainT (  mart ) $ keys ==  \"gene_id_key\" ] ) ;   IDTable -    get (  type ,   martFilters (  mart ) ) $ table  if (   IDTable ==  \"main\" )   IDTable =  speciesTable   dbcolID -    get (  type ,   martFilters (  mart ) ) $ field ;   query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ;   res -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {     names (  res ) =   c (  \"id\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ) ;   table -   as.data.frame (  res ) } else  {   writeLines (  \"No match found\" ) }   return (  table ) } else  {   filter =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   attribute =  type  if (  !   missing (  symbol ) )  {   filter =   switch (     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ] , hsapiens =  \"hgnc_symbol\" , mmusculus =  \"mgi_symbol\" ,  \"external_gene_id\" )   attributes =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIMID ) )  {   filter =  \"mim_gene_ac\"   attributes =   c (  filter ,  attribute )   values =  OMIMID }  if (   !   missing (  GOID ) undefined   martMySQL (  mart ) )  {   filter =   c (  \"go\" )   attributes =   c (  \"go\" ,  attribute )   values =  GOID }  if (   !   missing (  GOID ) undefined  !   martMySQL (  mart ) )  {   filter =   c (  \"go\" ,   paste (  \"with_\" ,  type , sep =  \"\" ) )   attributes =   c (  \"go\" ,  attribute )   values =   list (  GOID ,  TRUE ) }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {  if (    attribute ==  \"ensembl_gene_id\" ||   attribute ==  \"ensembl_transcript_id\" )  {   filter =  \"chromosome_name\"   values =  chromosome } else  {  if (  !   martMySQL (  mart ) )  {   filter =   c (  \"chromosome_name\" ,   paste (  \"with_\" ,  attribute , sep =  \"\" ) ) } else  {   filter =  \"chromosome_name\" }   values =   list (  chromosome ,  TRUE ) }   attributes =   c (  chrname ,  attribute ) } else  {  if (    attribute ==  \"ensembl_gene_id\" ||   attribute ==  \"ensembl_transcript_id\" )  {   filter =   c (  chrname ,  startpos ,  endpos )   values =   list (  chromosome ,  start ,  end ) } else  {   filter =   c (  chrname ,  startpos ,  endpos ,   paste (  \"with_\" ,  attribute , sep =  \"\" ) )   values =   list (  chromosome ,  start ,  end ,  TRUE ) }   attributes =   c (  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute ) } }   table =   getBM ( attributes =  attributes , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{     table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function useMart\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {     if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }   GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID -    get (  array ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   as.data.frame (  res ) } }   return (  table ) ; } #--webservice---------------------- else  {   goid =  \"go\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  goid ,  \"go_description\" ,  \"evidence_code\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  goid ,  \"go_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {  if (  !   missing (  array ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } else  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , mart )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  type ,  mart )   typeAttrib =   switch (  type , affy_hg_u133a_2 =  \"affy_hg_u133a_v2\" ,  type )   attrib =   c (  typeAttrib ,  \"go\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" )   table =   getBM ( attributes =  attrib , filters =  type , values =  id , mart =  mart )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.mart , to.mart )",
    "body": "{  if (      missing (  to.mart ) ||    class (  to.mart ) !=  'Mart' ||   missing (  from.mart ) ||    class (  from.mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function useMart\" ) }  if (    \"ensembl\" !=   to.mart @ biomart ||   \"ensembl\" !=   from.mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (   from.mart @ mysql )  {  if (  !   to.mart @ mysql )   stop (  \"Both mart object should both be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {    from.type -  \"affy\" ; } else  {  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type argument\" ) } }  if (  !   missing (  to.array ) )  {    to.type -  \"affy\" ; } else  {  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromCol =  NULL   toCol =  NULL   fromIDTable =  NULL   toIDTable =  NULL  if (   missing (  from.array ) )  {    fromIDTable -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ table   fromCol -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ field ; } else  {    fromIDTable -    get (  from.array ,   from.mart @ filters ) $ table   fromCol -    get (  from.array ,   from.mart @ filters ) $ field ; }  if (   missing (  to.array ) )  {    toIDTable -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ table   toCol -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ field ; } else  {    toIDTable -    get (  to.array ,   to.mart @ filters ) $ table   toCol -    get (  to.array ,   to.mart @ filters ) $ field ; }  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    from.mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   to.mart @ mysql )   stop (  \"The mart objects should either use both mysql or not. Here your from.mart does not use mysql but you to.mart does.\" ) # to.attributes=c(\"ensembl_gene_id\",\"ensembl_transcript_id\")   to.attributes =  NULL   from.attributes =  NULL   filter =  NULL  if (  !   missing (  to.array ) )  {   to.attributes =   c (  to.attributes ,  to.array ) } else  {   to.attributes =   c (  to.attributes ,   mapFilter (  to.type ) ) }  if (  !   missing (  from.array ) )  {   from.attributes =   c (  from.attributes ,  from.array )   filter =  from.array } else  {   from.attributes =  \"ensembl_gene_id\" #from.attributes = c(from.attributes,mapFilter(from.type))   filter =   mapFilter (  from.type ) }   xmlQuery =   paste (  \" ,   from.mart @ dataset ,  \"' , sep =  \"\" )   attributeXML =  \"\" #paste(\"   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  \" ,  filter ,  \"' value = '\" ,  valuesString ,  \"' / , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  attributeXML ,  filterXML ,  \" , sep =  \"\" )   species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   xmlQuery =   paste (  xmlQuery ,  \" ,   from.mart @ dataset ,  \"' target = '\" ,   to.mart @ dataset ,  \"' defaultLink = '\" ,  species ,  \"_internal_gene_id'/ ,   to.mart @ dataset ,  \"' , sep =  \"\" )   to.attributeXML =   paste (  \" ,  to.attributes ,  \"'/ , collapse =  \"\" , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  to.attributeXML ,  \" , sep =  \"\" )   postRes =   postForm (   paste (   to.mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.mart , to.mart )",
    "body": "{   martCheck (  to.mart ,  \"ensembl\" )   martCheck (  from.mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  from.type ,  from.mart )  if (   missing (  to.type ) )   stop (  \"You must provide the identifier type using the to.type  argument\" )  if (  !   to.type %in%   ls (   martAttributes (  to.mart ) ) )   stop (  \"Invalid to.type, use the listAttributes function on the to.mart to get valid to.type values\" )  if (   martMySQL (  from.mart ) )  {     if (  !   martMySQL (  to.mart ) )   stop (  \"Both Mart objects should be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No identifiers given to search for homologs\" ) ; }   fromIDTable -    get (  from.type ,   martFilters (  from.mart ) ) $ table   fromSpeciesTable -   unique (     martMainT (  from.mart ) $ tables [     martMainT (  from.mart ) $ keys ==  \"gene_id_key\" ] ) ;  if (   fromIDTable ==  \"main\" )   fromIDTable =  fromSpeciesTable   fromCol -    get (  from.type ,   martFilters (  from.mart ) ) $ field   toIDTable -    get (  to.type ,   martFilters (  to.mart ) ) $ table   toSpeciesTable -   unique (     martMainT (  to.mart ) $ tables [     martMainT (  to.mart ) $ keys ==  \"gene_id_key\" ] ) ;  if (   toIDTable ==  \"main\" )   toIDTable =  toSpeciesTable   toCol -    get (  to.type ,   martFilters (  to.mart ) ) $ field ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   martDataset (  to.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   martDataset (  from.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   martDataset (  to.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   martDataset (  from.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    martConnection (  from.mart ) $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   seq ( along =  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   martMySQL (  to.mart ) )   stop (  \"The Mart objects should either use both mysql or not. Here your from.mart does not use mysql but your to.mart does.\" )   result =   getLDS ( attributes =  from.type , filters =  from.type , values =  id , mart =  from.mart , attributesL =  to.type , martL =  to.mart )   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function useMart\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {      martdb =  \"\" ;  if (    mart @ biomart !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    mart @ biomart =  \"sequence\" }     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (    !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } }   table -   data.frame ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence )   return (  table ) } else  {   geneid =  \"gene_stable_id\"   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]  if (  !   missing (  chromosome ) )  {  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,  chromosome ,  \"'/ ,  start ,  \"'/ ,  end ,  \"'/ ,  species ,  \"_gene_ensembl' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }  if (  !   missing (  id ) )  {   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,   mapFilter (  type ) ,  \"' value = '\" ,  valuesString ,  \"'/ ,   mart @ dataset ,  \"' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  query )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , upstream , downstream , mart , verbose = FALSE )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )  if (   martMySQL (  mart ) )  {      martdb =  \"\" ;  if (  !   missing (  upstream ) )  {   stop (  \"Use of the upstream argument only works when using biomaRt in webservice mode\" ) }  if (  !   missing (  downstream ) )  {   stop (  \"Use of the downstream argument only works when using biomaRt in webservice mode\" ) }  if (  !   missing (  seqType ) )  {   stop (  \"seqType only has to be specified when using biomaRt in webservice mode.  In MySQL mode biomaRt will retrieve genomic sequences only\" ) }  if (  !   missing (  type ) )  {   stop (  \"Use of the type argument to specify gene identifiers only works when using biomaRt in webservice mode\" ) }  if (    martBM (  mart ) !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   seq ( along =  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    martBM (  mart ) =  \"sequence\" }     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , port =  3316 , dbname =  martdb , password =  \"\" )   species =     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (    !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   seq ( along =  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } }   table -   data.frame ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence )   return (  table ) } else  {  if (    missing (  seqType ) ||  !   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ,  \"gene_exon\" ,  \"transcript_exon\" ,  \"transcript_exon_intron\" ,  \"gene_exon_intron\" ,  \"coding\" ,  \"coding_transcript_flank\" ,  \"coding_gene_flank\" ,  \"transcript_flank\" ,  \"gene_flank\" ) )  {   stop (  \"Please specify the type of sequence that needs to be retrieved when using biomaRt in web service mode.  Choose either gene_exon, transcript_exon,transcript_exon_intron, gene_exon_intron, cdna, coding,coding_transcript_flank,coding_gene_flank,transcript_flank,gene_flank,peptide, 3utr or 5utr\" ) }  if (   missing (  type ) )   stop (  \"Please specify the type argument.  If you use chromosomal coordinates to retrieve sequences, then the type argument will specify the type of gene indentifiers that you will retrieve with the sequences.  If you use a vector of identifiers to retrieve the sequences, the type argument specifies the type of identifiers you are using.\" )  if (     missing (  id ) undefined   missing (  chromosome ) undefined  !   missing (  type ) )   stop (  \"No vector of identifiers given. Please use the id argument to give a vector of identifiers for which you want to retrieve the sequences.\" )  if (   !   missing (  chromosome ) undefined  !   missing (  id ) )   stop (  \"The getSequence function retrieves sequences given a vector of identifiers specified with the id argument of a type specified by the type argument.  Or alternatively getSequence retrieves sequences given a chromosome, a start and a stop position on the chromosome.  As you specified both a vector of identifiers and chromsomal coordinates. Your query won't be processed.\" )  if (  !   missing (  chromosome ) )  {  if (   !   missing (  start ) undefined   missing (  end ) )   stop (  \"You specified a chromosomal start position but no end position.  Please also specify a chromosomal end position.\" )  if (   !   missing (  end ) undefined   missing (  start ) )   stop (  \"You specified a chromosomal end position but no start position.  Please also specify a chromosomal start position.\" )  if (  !   missing (  start ) )  {   start =   as.integer (  start )   end =   as.integer (  end ) }  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ) , values =   list (  chromosome ,  start ,  end ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"upstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"downstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }  if (  !   missing (  id ) )  {  if (   missing (  type ) )   stop (  \"Type argument is missing.  This will be used to retrieve an identifier along with the sequence so one knows which gene it is from.  Use the listFilters function to select a valid type argument.\" )  if (  !   type %in%   ls (   martFilters (  mart ) ) )   stop (  \"Invalid type argument.  Use the listFilters function to select a valid type argument.\" )   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =  type , values =  id , mart =  mart , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"upstream_flank\" ) , values =   list (  id ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"downstream_flank\" ) , values =   list (  id ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }   return (  sequence ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , array , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function useMart\" ) }  if (    mart @ biomart !=  \"ensembl\" )  {    stop (  \"you can only use ensembl for this query.  Please do: useMart('ensembl').  To access VEGA you have to use the more advanced biomaRt function:  useMart. listDatasets, useDataset, listFilters, listAttributes and getBM.\" ) ; }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (  !   missing (  array ) )  {    type -  \"affy\" ; }  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } #MySQL-----------------------------------------------------------  if (   mart @ mysql )  {    if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {   IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID =    get (  array ,   mart @ filters ) $ field } else  {   IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID =    get (   mapFilter (  type ) ,   mart @ filters ) $ field }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ;  if (    length (  id ) =  1 )  {     ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" ) ;  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  dbcolID ,  \", display_id, description, band,chr_name, gene_chrom_start, gene_chrom_end, chrom_strand  from \" ,  speciesTable ,  \" where \" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".gene_stable_id,\" ,  speciesTable ,  \".display_id,\" ,  speciesTable ,  \".description, \" ,  speciesTable ,  \".band,\" ,  speciesTable ,  \".chr_name,\" ,  speciesTable ,  \".gene_chrom_start,\" ,  speciesTable ,  \".gene_chrom_end,\" ,  speciesTable ,  \".chrom_strand  from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \")\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   writeLines (  \"Query retrieved no results\" )   return (  NULL ) } else  {       mt =   match (   res [ ,  1 ] ,  id ) ;  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" ) ;  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"symbol\" ,  \"description\" ,  \"band\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ,  \"strand\" ,  \"martID\" ) ;   table -   as.data.frame (  res )   return (  table ) ; } } } #Webservice----------------------------------------------------- else  {   startpos =  \"start_position\"   endpos =  \"end_position\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   symbol =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  symbol ,  \"description\" ,  chrname ,  \"band\" ,  strand ,  startpos ,  endpos ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"symbol\" ,  \"description\" ,  \"chromosome\" ,  \"band\" ,  \"strand\" ,  \"chromosome_start\" ,  \"chromosome_end\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGene",
    "representation": "getGene",
    "parameters": "function ( id , type , mart )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  type ,  mart )   symbolAttrib =   switch (     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ] , hsapiens =  \"hgnc_symbol\" , mmusculus =  \"mgi_symbol\" ,  \"external_gene_id\" )   typeAttrib =   switch (  type , affy_hg_u133a_2 =  \"affy_hg_u133a_v2\" ,  type )   attrib =   c (  typeAttrib ,  symbolAttrib ,  \"description\" ,  \"chromosome_name\" ,  \"band\" ,  \"strand\" ,  \"start_position\" ,  \"end_position\" ,  \"ensembl_gene_id\" )   table =   getBM ( attributes =  attrib , filters =  type , values =  id , mart =  mart )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIM , OMIMID , GO , GOID , array , chromosome , start , end , type , mart )",
    "body": "{  if (  !   missing (  array ) )  {   type -  \"affy\" } else  {  if (   missing (  type ) )  {    stop (  \"you must provide the identifier type using the type argument\" ) ; } }  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {    stop (  \"you must provide a valid Mart object, create with function useMart\" ) ; }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {    if (        !  (   type ==  \"affy\" ) undefined  !  (   type ==  \"entrezgene\" ) undefined  !  (   type ==  \"refseq\" ) undefined  !  (   type ==  \"embl\" ) undefined  !  (   type ==  \"hugo\" ) undefined  !  (   type ==  \"ensembl\" ) undefined  !  (   type ==  \"flybase\" ) )  {    stop (  \"invalid type choose either affy, refseq, embl, hugo or entrezgene\" ) ; }  if (   type ==  \"affy\" )  {  if (  !   missing (  array ) )  {    affyBool -   paste (  array ,  \"_bool\" , sep =  \"\" ) ; } }   speciesTable -   unique (     mart @ mainTables $ tables [     mart @ mainTables $ keys ==  \"gene_id_key\" ] ) ;   IDTable =  NULL   dbcolID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  array ) ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }  if (  !   missing (  symbol ) )  {  if (   type !=  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  speciesTable ,  \".display_id, \" ,  IDTable ,  \".\" ,  dbcolID ,  \", description from \" ,  IDTable ,  \" inner join \" ,  speciesTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  speciesTable ,  \".gene_stable_id where \" ,  speciesTable ,  \".display_id like '%\" ,  symbol ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct display_id,\" ,  dbcolID ,  \", description from \" ,  speciesTable ,  \" where display_id like '%\" ,  symbol ,  \"%' and \" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }  if (  !   missing (  OMIM ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".disease like '%\" ,  OMIM ,  \"%'  and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  OMIMID ) )  {     OMIMTable -  \"hsapiens_gene_ensembl__disease__dm\" ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  OMIMTable ,  \".omim_id, disease from \" ,  IDTable ,  \" inner join \" ,  OMIMTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  OMIMTable ,  \".gene_id_key where \" ,  OMIMTable ,  \".omim_id in ('\" ,  OMIMID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GO ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".description like '%\" ,  GO ,  \"%' and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  GOID ) )  {     GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_id_key = \" ,  GOTable ,  \".gene_id_key where \" ,  GOTable ,  \".dbprimary_id in ('\" ,  GOID ,  \"') and \" ,  IDTable ,  \".\" ,  dbcolID ,  \" != 'NULL'\" , sep =  \"\" ) ; }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \", b.chr_name, b.gene_chrom_start, b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name = '\" ,  chromosome ,  \"' and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ; } }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {  if (  !   missing (  symbol ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  2 ] ) ) , table =   list ( symbol =   as.vector (   res [ ,  1 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  OMIM ) ||  !   missing (  OMIMID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( OMIMID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) ) ) }  if (   !   missing (  GO ) ||  !   missing (  GOID ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( GOID =   as.vector (   res [ ,  2 ] ) , description =   as.vector (   res [ ,  3 ] ) , evidence =   as.vector (   res [ ,  4 ] ) ) ) }  if (  !   missing (  chromosome ) )  {   table -   new (  \"martTable\" , id =   as.vector (   as.character (   res [ ,  1 ] ) ) , table =   list ( chromosome =   as.vector (   res [ ,  2 ] ) , start =   as.vector (   res [ ,  3 ] ) , end =   as.vector (   res [ ,  4 ] ) ) ) } } else  {   writeLines (  \"No match found\" ) }   return (  table ) } #-----webservice------------------------------------ else  {   filter =  NULL   attribute =  NULL   values =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"   strand =  \"strand\"   attribute =   switch (  type , hugo =  \"hgnc_symbol\" , agilentcgh =  \"agilent_cgh\" , ensemblTrans =  \"ensembl_transcript_id\" , agilentprobe =  \"agilent_probe\" , entrezgene =  \"entrezgene\" , locuslink =  \"entrezgene\" , embl =  \"embl\" , refseq =  \"refseq_dna\" , unigene =  \"unigene\" , affy =  array , ensembl =  \"ensembl_gene_id\" )  if (  !   missing (  symbol ) )  {   filter =   switch (   mart @ dataset , hsapiens_gene_ensembl =  \"hgnc_symbol\" , mmusculus_gene_ensembl =  \"mgi_symbol\" , rnorvegicus_gene_ensembl =  \"mgi_symbol\" , scerevisiae_gene_ensembl =  \"sgd\" , celegans_gene_ensembl =  \"external_gene_id\" , cintestinalis_gene_ensembl =  \"external_gene_id\" , ptroglodytes_gene_ensembl =  \"external_gene_id\" , frubripes_gene_ensembl =  \"external_gene_id\" , agambiae_gene_ensembl =  \"external_gene_id\" , ggallus_gene_ensembl =  \"external_gene_id\" , xtropicalis_gene_ensembl =  \"external_gene_id\" , drerio_gene_ensembl =  \"external_gene_id\" , tnigroviridis_gene_ensembl =  \"external_gene_id\" , mmulatta_gene_ensembl =  \"external_gene_id\" , mdomesticus_gene_ensembl =  \"external_gene_id\" , amellifera_gene_ensembl =  \"external_gene_id\" , dmelanogaster_gene_ensembl =  \"external_gene_id\" , btaurus_gene_ensembl =  \"external_gene_id\" , cfamiliaris_gene_ensembl =  \"external_gene_id\" , )   attribute =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIM ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  OMIMID ) )  {   stop (  \"getFeature currently can only query for omim descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GO ) )  {   stop (  \"getFeature currently can only query for go descriptions using mysql access.  create a mart object using useMart('ensembl',mysql=TRUE)\" ) }  if (  !   missing (  GOID ) )  {   filter =  \"go\"   attribute =   c (  \"go\" ,  attribute )   values =  GOID }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {   filter =  \"chromosome_name\"   attribute =   c (  transid ,  chrname ,  attribute )   values =  chromosome } else  {   filter =   c (  chrname ,  startpos ,  endpos )   attribute =   c (  transid ,  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute )   values =   list (  chromosome ,  start ,  end ) } }   table =   getBM ( attributes =  attribute , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getFeature",
    "representation": "getFeature",
    "parameters": "function ( symbol , OMIMID , GOID , chromosome , start , end , type , mart )",
    "body": "{   .Deprecated (  \"getBM\" , package =  \"biomaRt\" , msg =  \"The functionality of getFeature is completely incorporated in getBM and many more getFeature type of queries are possible with getBM. For example to retrieve a set of affymetrix u133plus2 array probes for genes that are located on chromosome 2 between basepair 14000 and 30000 do:  getBM('affy_hg_u133_plus_2', filters=c('chromosome_name', 'start','end'), values=list(2,300000,1000000), mart=yourmartobject)\" )   martCheck (  mart ,  \"ensembl\" )  if (   missing (  type ) )   stop (  \"You must provide the identifier type using the type argument.  Values for the type argument are given by the listAttributes function, see ?listAttributes for more information.\" )  if (  !   type %in%   ls (   martAttributes (  mart ) ) )   stop (  \"Invalid identifier type see ?getGene for details. Use listAttributes function to get the valid values for the type argument\" )  if (     martMySQL (  mart ) undefined  !   missing (  chromosome ) undefined  !   missing (  start ) )  {       speciesTable -   unique (     martMainT (  mart ) $ tables [     martMainT (  mart ) $ keys ==  \"gene_id_key\" ] ) ;   IDTable -    get (  type ,   martFilters (  mart ) ) $ table  if (   IDTable ==  \"main\" )   IDTable =  speciesTable   dbcolID -    get (  type ,   martFilters (  mart ) ) $ field ;   query -   paste (  \"select distinct a.\" ,  dbcolID ,  \",b.chr_name,b.gene_chrom_start,b.gene_chrom_end from \" ,  IDTable ,  \" as a inner join \" ,  speciesTable ,  \" as b on a.gene_stable_id = b.gene_stable_id where b.chr_name ='\" ,  chromosome ,  \"' and b.gene_chrom_start ,  start ,  \" and b.gene_chrom_end ,  end ,  \" and a.\" ,  dbcolID ,  \" !='NULL'\" , sep =  \"\" ) ;   res -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] !=  0 )  {     names (  res ) =   c (  \"id\" ,  \"chromosome\" ,  \"start\" ,  \"end\" ) ;   table -   as.data.frame (  res ) } else  {   writeLines (  \"No match found\" ) }   return (  table ) } else  {   filter =  NULL   startpos =  \"start\"   endpos =  \"end\"   chrname =  \"chromosome_name\"   attribute =  type  if (  !   missing (  symbol ) )  {   filter =   switch (     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ] , hsapiens =  \"hgnc_symbol\" , mmusculus =  \"mgi_symbol\" ,  \"external_gene_id\" )   attributes =   c (  filter ,  attribute )   values =  symbol }  if (  !   missing (  OMIMID ) )  {   filter =  \"mim_gene_ac\"   attributes =   c (  filter ,  attribute )   values =  OMIMID }  if (   !   missing (  GOID ) undefined   martMySQL (  mart ) )  {   filter =   c (  \"go\" )   attributes =   c (  \"go\" ,  attribute )   values =  GOID }  if (   !   missing (  GOID ) undefined  !   martMySQL (  mart ) )  {   filter =   c (  \"go\" ,   paste (  \"with_\" ,  type , sep =  \"\" ) )   attributes =   c (  \"go\" ,  attribute )   values =   list (  GOID ,  TRUE ) }  if (  !   missing (  chromosome ) )  {  if (    missing (  start ) undefined   missing (  end ) )  {  if (    attribute ==  \"ensembl_gene_id\" ||   attribute ==  \"ensembl_transcript_id\" )  {   filter =  \"chromosome_name\"   values =  chromosome } else  {  if (  !   martMySQL (  mart ) )  {   filter =   c (  \"chromosome_name\" ,   paste (  \"with_\" ,  attribute , sep =  \"\" ) ) } else  {   filter =  \"chromosome_name\" }   values =   list (  chromosome ,  TRUE ) }   attributes =   c (  chrname ,  attribute ) } else  {  if (    attribute ==  \"ensembl_gene_id\" ||   attribute ==  \"ensembl_transcript_id\" )  {   filter =   c (  chrname ,  startpos ,  endpos )   values =   list (  chromosome ,  start ,  end ) } else  {   filter =   c (  chrname ,  startpos ,  endpos ,   paste (  \"with_\" ,  attribute , sep =  \"\" ) )   values =   list (  chromosome ,  start ,  end ,  TRUE ) }   attributes =   c (  chrname ,  \"start_position\" ,  \"end_position\" ,  attribute ) } }   table =   getBM ( attributes =  attributes , filters =  filter , values =  values , mart =  mart )   return (  table ) } } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , array , mart )",
    "body": "{     table -  NULL ;   go -  NULL ;  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a valid Mart object, create with function useMart\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {     if (  !   missing (  array ) )  {    type -  \"affy\" ; } else  {  if (   missing (  type ) )  {   stop (  \"you must provide the identifier type using the type argument\" ) } }   GOTable -    get (  \"go\" ,   mart @ filters ) $ table ;   IDTable =  NULL   dbcolQID =  NULL  if (  !   missing (  array ) )  {    IDTable =    get (  array ,   mart @ filters ) $ table   dbcolQID -    get (  array ,   mart @ filters ) $ field ; } else  {    IDTable -    get (   mapFilter (  type ) ,   mart @ filters ) $ table   dbcolQID -    get (   mapFilter (  type ) ,   mart @ filters ) $ field ; }   dbcolID -    get (   mapFilter (  \"ensembl\" ) ,   mart @ filters ) $ field ; #get database id col  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (   type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \",\" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  GOTable ,  \".dbprimary_id,\" ,  GOTable ,  \".description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct \" ,  IDTable ,  \".\" ,  dbcolQID ,  \", \" ,  IDTable ,  \".\" ,  dbcolID ,  \",\" ,  GOTable ,  \".dbprimary_id, description, evidence_code from \" ,  IDTable ,  \" inner join \" ,  GOTable ,  \" on \" ,  IDTable ,  \".gene_stable_id = \" ,  GOTable ,  \".gene_stable_id where \" ,  IDTable ,  \".\" ,  dbcolQID ,  \" in (\" ,  ids ,  \") and \" ,  GOTable ,  \".dbprimary_id != 'NULL'\" , sep =  \"\" ) ; }   res -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   table -   new (  \"martTable\" , id =  id , table =   list ( GOID =  NA , description =  NA , evidence =  NA , martID =  NA ) ) } else  {   mt =   match (   res [ ,  1 ] ,  id )  if (   any (   is.na (  mt ) ) )   stop (  \"Internal error!\" )  if (   type ==  \"ensembl\" )  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  1 ) ] ; } else  {    res =   res [   order (  mt ) ,   c (  1 ,  3 ,  4 ,  5 ,  2 ) ] ; }    names (  res ) =   c (  \"id\" ,  \"GOID\" ,  \"description\" ,  \"evidence\" ,  \"martID\" )   table -   as.data.frame (  res ) } }   return (  table ) ; } #--webservice---------------------- else  {   goid =  \"go\"   geneid =  \"ensembl_gene_id\"   transid =  \"ensembl_transcript_id\"  if (  !   missing (  array ) )  {  if (   array ==  \"affy_hg_u133a_2\" )  {   attrib =  \"affy_hg_u133a_v2\" } else  {   attrib =  array }   table =   getBM ( attributes =   c (  attrib ,  goid ,  \"go_description\" ,  \"evidence_code\" ,  geneid ,  transid ) , filters =  array , values =  id , mart =  mart ) } else  {  if (   missing (  type ) )   stop (  \"Specify the type of identifier you are using, see ?getGene for details\" )   filter =   mapFilter (  type )   table =   getBM ( attributes =   c (  filter ,  goid ,  \"go_description\" ,  geneid ,  transid ) , filters =  filter , values =  id , mart =  mart ) }  if (  !   is.null (  table ) )  {  if (  !   missing (  array ) )  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } else  {    colnames (  table ) =   c (  \"ID\" ,  \"go_id\" ,  \"go_description\" ,  \"ensembl_gene_id\" ,  \"ensembl_transcript_id\" ) } }   return (  table ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getGO",
    "representation": "getGO",
    "parameters": "function ( id , type , mart )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  type ,  mart )   typeAttrib =   switch (  type , affy_hg_u133a_2 =  \"affy_hg_u133a_v2\" ,  type )   attrib =   c (  typeAttrib ,  \"go\" ,  \"go_description\" ,  \"evidence_code\" ,  \"ensembl_gene_id\" )   table =   getBM ( attributes =  attrib , filters =  type , values =  id , mart =  mart )   return (  table ) } ",
    "filename": "biomaRt.txt"
  }
}

3.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , mart )",
    "body": "{  if (    missing (  mart ) ||    class (  mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function useMart\" ) }  if (   \"ensembl\" !=   mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (    mart @ dataset ==  \"\" )  {    stop (  \"Please select a dataset first.  You an see the available datasets by:  listDatasets('ensembl').  Then you should create the mart object with e.g.: mart = useMart(biomart='ensembl',dataset='hsapiens_gene_ensembl')\" ) ; }  if (   mart @ mysql )  {      martdb =  \"\" ;  if (    mart @ biomart !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   1 :   length (  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    mart @ biomart =  \"sequence\" }     mart @ connections [[  \"biomart\" ] ] -   dbConnect ( drv =    mart @ mysqldriver $ driver , user =  \"anonymous\" , host =  \"ensembldb.ensembl.org\" , dbname =  martdb , password =  \"\" )   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (    !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   1 :   length (  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    mart @ connections $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } }   table -   data.frame ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence )   return (  table ) } else  {   geneid =  \"gene_stable_id\"   species =     strsplit (   mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]  if (  !   missing (  chromosome ) )  {  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,  chromosome ,  \"'/ ,  start ,  \"'/ ,  end ,  \"'/ ,  species ,  \"_gene_ensembl' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }  if (  !   missing (  id ) )  {   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ) )  {   query =   paste (  \" ,  species ,  \"_gene_ensembl' ,   mapFilter (  type ) ,  \"' value = '\" ,  valuesString ,  \"'/ ,   mart @ dataset ,  \"' target = '\" ,  species ,  \"_gene_ensembl_structure' defaultLink = '\" ,  species ,  \"_internal_transcript_id' / ,  species ,  \"_gene_ensembl_structure' ,  geneid ,  \"'/ ,  species ,  \"_gene_ensembl_structure' target = '\" ,  species ,  \"_genomic_sequence' defaultLink = '\" ,  seqType ,  \"' / ,  species ,  \"_genomic_sequence' ,  seqType ,  \"'/ , sep =  \"\" ) } else  {   stop (  \"The type of sequence specified with seqType is not available. Please select from: cdna, peptide, 3utr, 5utr\" ) } }   postRes =   postForm (   paste (   mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  query )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , upstream , downstream , mart , verbose = FALSE )",
    "body": "{   martCheck (  mart ,  \"ensembl\" )  if (   martMySQL (  mart ) )  {      martdb =  \"\" ;  if (  !   missing (  upstream ) )  {   stop (  \"Use of the upstream argument only works when using biomaRt in webservice mode\" ) }  if (  !   missing (  downstream ) )  {   stop (  \"Use of the downstream argument only works when using biomaRt in webservice mode\" ) }  if (  !   missing (  seqType ) )  {   stop (  \"seqType only has to be specified when using biomaRt in webservice mode.  In MySQL mode biomaRt will retrieve genomic sequences only\" ) }  if (  !   missing (  type ) )  {   stop (  \"Use of the type argument to specify gene identifiers only works when using biomaRt in webservice mode\" ) }  if (    martBM (  mart ) !=  \"sequence\" )  {   version =  \"0\"   marts =   listMarts ( mysql =  TRUE )  for  ( i in   seq ( along =  marts ) )  {  if (   \"sequence\" ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =   paste (  \"sequence_mart_\" ,  version , sep =  \"\" )    martBM (  mart ) =  \"sequence\" }     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , port =  3316 , dbname =  martdb , password =  \"\" )   species =     strsplit (   martDataset (  mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   sequence -  NULL ;   speciesTable -   paste (  species ,  \"_genomic_sequence__dna_chunks__main\" , sep =  \"\" ) ;  if (    !   missing (  chromosome ) undefined  !   missing (  start ) undefined  !   missing (  end ) )  {  for  ( i in   seq ( along =  chromosome ) )  {    if (     end [  i ] -   start [  i ] undefined  100000 )  {   stop (  \"maximum sequence length is 100000 nucleotides, change start and end arguments to make the sequence size smaller\" ) }   chunkStart -   (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;   chunkEnd -   (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 ) +  1 ;  if (   chunkStart ==  chunkEnd )  { #we only need to get one sequence chunck of 100000 nucleotides      query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 )   newend -    end [  i ] -  (    floor (   (    end [  i ] -  1 ) /  100000 ) *  100000 )   sequence -   c (  sequence ,   substr (   as.character (  chunkseq ) ,  newstart ,  newend ) ) ; } else  { #query sequence is on 2 sequence chuncks           query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkStart ,  \"'\" , sep =  \"\" ) ;   chunkseq1 -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   query -   paste (  \"select sequence from \" ,  speciesTable ,  \" where chr_name = '\" ,   chromosome [  i ] ,  \"' and chr_start = '\" ,  chunkEnd ,  \"'\" , sep =  \"\" ) ;   chunkseq2 -   dbGetQuery ( conn =    martConnection (  mart ) $ biomart , statement =  query ) ;   chunkseq -   paste (   as.character (  chunkseq1 ) ,   as.character (  chunkseq2 ) , sep =  \"\" ) ;   newstart -    start [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   newend -    end [  i ] -  (    floor (   (    start [  i ] -  1 ) /  100000 ) *  100000 ) ;   sequence -   c (  sequence ,   substr (  chunkseq , start =  newstart , stop =  newend ) ) ; } } }   table -   data.frame ( chromosome =  chromosome , start =  start , end =  end , sequence =  sequence )   return (  table ) } else  {  if (    missing (  seqType ) ||  !   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ,  \"gene_exon\" ,  \"transcript_exon\" ,  \"transcript_exon_intron\" ,  \"gene_exon_intron\" ,  \"coding\" ,  \"coding_transcript_flank\" ,  \"coding_gene_flank\" ,  \"transcript_flank\" ,  \"gene_flank\" ) )  {   stop (  \"Please specify the type of sequence that needs to be retrieved when using biomaRt in web service mode.  Choose either gene_exon, transcript_exon,transcript_exon_intron, gene_exon_intron, cdna, coding,coding_transcript_flank,coding_gene_flank,transcript_flank,gene_flank,peptide, 3utr or 5utr\" ) }  if (   missing (  type ) )   stop (  \"Please specify the type argument.  If you use chromosomal coordinates to retrieve sequences, then the type argument will specify the type of gene indentifiers that you will retrieve with the sequences.  If you use a vector of identifiers to retrieve the sequences, the type argument specifies the type of identifiers you are using.\" )  if (     missing (  id ) undefined   missing (  chromosome ) undefined  !   missing (  type ) )   stop (  \"No vector of identifiers given. Please use the id argument to give a vector of identifiers for which you want to retrieve the sequences.\" )  if (   !   missing (  chromosome ) undefined  !   missing (  id ) )   stop (  \"The getSequence function retrieves sequences given a vector of identifiers specified with the id argument of a type specified by the type argument.  Or alternatively getSequence retrieves sequences given a chromosome, a start and a stop position on the chromosome.  As you specified both a vector of identifiers and chromsomal coordinates. Your query won't be processed.\" )  if (  !   missing (  chromosome ) )  {  if (   !   missing (  start ) undefined   missing (  end ) )   stop (  \"You specified a chromosomal start position but no end position.  Please also specify a chromosomal end position.\" )  if (   !   missing (  end ) undefined   missing (  start ) )   stop (  \"You specified a chromosomal end position but no start position.  Please also specify a chromosomal start position.\" )  if (  !   missing (  start ) )  {   start =   as.integer (  start )   end =   as.integer (  end ) }  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ) , values =   list (  chromosome ,  start ,  end ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"upstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"downstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }  if (  !   missing (  id ) )  {  if (   missing (  type ) )   stop (  \"Type argument is missing.  This will be used to retrieve an identifier along with the sequence so one knows which gene it is from.  Use the listFilters function to select a valid type argument.\" )  if (  !   type %in%   ls (   martFilters (  mart ) ) )   stop (  \"Invalid type argument.  Use the listFilters function to select a valid type argument.\" )   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =  type , values =  id , mart =  mart , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"upstream_flank\" ) , values =   list (  id ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"downstream_flank\" ) , values =   list (  id ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }   return (  sequence ) } } ",
    "filename": "biomaRt.txt"
  }
}

4.
{
  "old_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.array , to.array , from.mart , to.mart )",
    "body": "{  if (      missing (  to.mart ) ||    class (  to.mart ) !=  'Mart' ||   missing (  from.mart ) ||    class (  from.mart ) !=  'Mart' )  {   stop (  \"you must provide a mart connection object, create with function useMart\" ) }  if (    \"ensembl\" !=   to.mart @ biomart ||   \"ensembl\" !=   from.mart @ biomart )  {   stop (  \"This function only works when using to ensembl. To use this function use: mart =  useMart('ensembl')\" ) }  if (   from.mart @ mysql )  {  if (  !   to.mart @ mysql )   stop (  \"Both mart object should both be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No id's to search for homologs given\" ) ; }  if (  !   missing (  from.array ) )  {    from.type -  \"affy\" ; } else  {  if (   missing (  from.type ) )  {   stop (  \"You must provide the identifier type using the from.type argument\" ) } }  if (  !   missing (  to.array ) )  {    to.type -  \"affy\" ; } else  {  if (   missing (  to.type ) )  {   stop (  \"You must provide the identifier type using the to.type  argument\" ) } }   fromCol =  NULL   toCol =  NULL   fromIDTable =  NULL   toIDTable =  NULL  if (   missing (  from.array ) )  {    fromIDTable -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ table   fromCol -    get (   mapFilter (  from.type ) ,   from.mart @ filters ) $ field ; } else  {    fromIDTable -    get (  from.array ,   from.mart @ filters ) $ table   fromCol -    get (  from.array ,   from.mart @ filters ) $ field ; }  if (   missing (  to.array ) )  {    toIDTable -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ table   toCol -    get (   mapFilter (  to.type ) ,   to.mart @ filters ) $ field ; } else  {    toIDTable -    get (  to.array ,   to.mart @ filters ) $ table   toCol -    get (  to.array ,   to.mart @ filters ) $ field ; }  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   from.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    from.mart @ connections $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   1 :   length (  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   to.mart @ mysql )   stop (  \"The mart objects should either use both mysql or not. Here your from.mart does not use mysql but you to.mart does.\" ) # to.attributes=c(\"ensembl_gene_id\",\"ensembl_transcript_id\")   to.attributes =  NULL   from.attributes =  NULL   filter =  NULL  if (  !   missing (  to.array ) )  {   to.attributes =   c (  to.attributes ,  to.array ) } else  {   to.attributes =   c (  to.attributes ,   mapFilter (  to.type ) ) }  if (  !   missing (  from.array ) )  {   from.attributes =   c (  from.attributes ,  from.array )   filter =  from.array } else  {   from.attributes =  \"ensembl_gene_id\" #from.attributes = c(from.attributes,mapFilter(from.type))   filter =   mapFilter (  from.type ) }   xmlQuery =   paste (  \" ,   from.mart @ dataset ,  \"' , sep =  \"\" )   attributeXML =  \"\" #paste(\"   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )   filterXML =   paste (  \" ,  filter ,  \"' value = '\" ,  valuesString ,  \"' / , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  attributeXML ,  filterXML ,  \" , sep =  \"\" )   species =     strsplit (   to.mart @ dataset ,  \"_\" ) [[  1 ] ] [  1 ]   xmlQuery =   paste (  xmlQuery ,  \" ,   from.mart @ dataset ,  \"' target = '\" ,   to.mart @ dataset ,  \"' defaultLink = '\" ,  species ,  \"_internal_gene_id'/ ,   to.mart @ dataset ,  \"' , sep =  \"\" )   to.attributeXML =   paste (  \" ,  to.attributes ,  \"'/ , collapse =  \"\" , sep =  \"\" )   xmlQuery =   paste (  xmlQuery ,  to.attributeXML ,  \" , sep =  \"\" )   postRes =   postForm (   paste (   to.mart @ host ,  \"?\" , sep =  \"\" ) , \"query\" =  xmlQuery )  if (   postRes !=  \"\" )  { ## convert the serialized table into a dataframe   con =   textConnection (  postRes )   result =   read.table (  con , sep =  \"\\t\" , header =  FALSE , quote =  \"\" , comment.char =  \"\" , as.is =  TRUE )   close (  con ) ## check and postprocess  if (   all (   is.na (   result [ ,   ncol (  result ) ] ) ) )   result =   result [ ,  -   ncol (  result ) , drop =  FALSE ] #stopifnot(ncol(result)==length(attributes)) #if(class(result) == \"data.frame\"){ #  colnames(result) = attributes #} } else  {   warning (  \"getBM returns NULL.\" )   result =  NULL }   return (  result ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getHomolog",
    "representation": "getHomolog",
    "parameters": "function ( id , from.type , to.type , from.mart , to.mart )",
    "body": "{   martCheck (  to.mart ,  \"ensembl\" )   martCheck (  from.mart ,  \"ensembl\" )   checkWrapperArgs (  id ,  from.type ,  from.mart )  if (   missing (  to.type ) )   stop (  \"You must provide the identifier type using the to.type  argument\" )  if (  !   to.type %in%   ls (   martAttributes (  to.mart ) ) )   stop (  \"Invalid to.type, use the listAttributes function on the to.mart to get valid to.type values\" )  if (   martMySQL (  from.mart ) )  {     if (  !   martMySQL (  to.mart ) )   stop (  \"Both Mart objects should be using mysql or not.  Your from.mart uses mysql but your to.mart not.\" )  if (  !   missing (  id ) )  {    id -   as.character (  id ) ; } else  {    stop (  \"No identifiers given to search for homologs\" ) ; }   fromIDTable -    get (  from.type ,   martFilters (  from.mart ) ) $ table   fromSpeciesTable -   unique (     martMainT (  from.mart ) $ tables [     martMainT (  from.mart ) $ keys ==  \"gene_id_key\" ] ) ;  if (   fromIDTable ==  \"main\" )   fromIDTable =  fromSpeciesTable   fromCol -    get (  from.type ,   martFilters (  from.mart ) ) $ field   toIDTable -    get (  to.type ,   martFilters (  to.mart ) ) $ table   toSpeciesTable -   unique (     martMainT (  to.mart ) $ tables [     martMainT (  to.mart ) $ keys ==  \"gene_id_key\" ] ) ;  if (   toIDTable ==  \"main\" )   toIDTable =  toSpeciesTable   toCol -    get (  to.type ,   martFilters (  to.mart ) ) $ field ;  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    to.species =     strsplit (   martDataset (  to.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   martDataset (  from.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  to.species ,  from.species ) ; } else  {    to.species =     strsplit (   martDataset (  to.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   from.species =     strsplit (   martDataset (  from.mart ) ,  \"_\" ) [[  1 ] ] [  1 ]   homolTable -   mapSpeciesToHomologTable (  from.species ,  to.species ) ; }  if (    length (  id ) =  1 )  {    ids -   paste (  \"'\" ,  id ,  \"'\" , sep =  \"\" , collapse =  \",\" )   res -  NULL  if (    from.type ==  \"ensembl\" undefined   to.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct c.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where c.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type !=  \"ensembl\" )  {    query -   paste (  \"select distinct b.\" ,  fromCol ,  \",c.\" ,  toCol ,  \" from \" ,  homolTable ,  \" as c inner join \" ,  fromIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where b.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and c.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } else  {  if (    to.type ==  \"ensembl\" undefined   from.type ==  \"ensembl\" )  {    query -   paste (  \"select distinct \" ,  fromCol ,  \", homol_stable_id from \" ,  homolTable ,  \" where \" ,  fromCol ,  \" in (\" ,  ids ,  \") and homol_stable_id != 'NULL'\" , sep =  \"\" ) ; } else  {    query -   paste (  \"select distinct a.\" ,  fromCol ,  \",b.\" ,  toCol ,  \" from  \" ,  fromIDTable ,  \" as a inner join \" ,  homolTable ,  \" as c on a.gene_id_key=c.gene_id_key inner join \" ,  toIDTable ,  \" as b on b.gene_id_key=c.homol_id \" ,  \"where a.\" ,  fromCol ,  \" in (\" ,  ids ,  \") and b.\" ,  toCol ,  \" != 'NULL'\" , sep =  \"\" ) ; } } }   res -   dbGetQuery ( conn =    martConnection (  from.mart ) $ biomart , statement =  query ) ;  if (     dim (  res ) [  1 ] ==  0 )  {   return (  NULL ) } else  {   foundID -  NULL   MappedID -  NULL   isNA -   is.na (   res [ ,  2 ] )   res -   res [  !  isNA , ]  for  ( j in   seq ( along =  id ) )  {   m -   match (   res [ ,  1 ] ,   id [  j ] , nomatch =  0 )  if (    sum (  m ) ==  0 )  {   foundID -   c (  foundID ,   as.character (   id [  j ] ) )   MappedID -   c (  MappedID ,  NA ) } else  {   foundID -   c (  foundID ,   res [   m ==  1 ,  1 ] )   MappedID -   c (  MappedID ,   res [   m ==  1 ,  2 ] ) } }   table -   data.frame ( id =  foundID , MappedID =  MappedID )   ind =   is.na (  MappedID )   table =   table [  !  ind , ] } }   return (  table ) } else  {  if (   martMySQL (  to.mart ) )   stop (  \"The Mart objects should either use both mysql or not. Here your from.mart does not use mysql but your to.mart does.\" )   result =   getLDS ( attributes =  from.type , filters =  from.type , values =  id , mart =  from.mart , attributesL =  to.type , martL =  to.mart )   return (  result ) } } ",
    "filename": "biomaRt.txt"
  }
}

5.
{
  "old_function": {
    "name": "exportFASTA",
    "representation": "exportFASTA",
    "parameters": "function ( martTable , file )",
    "body": "{  if (    missing (  martTable ) ||    class (  martTable ) !=  \"martTable\" )  {    stop (  \"No martTable given to write\" ) ; }  if (   missing (  file ) )  {    stop (  \"Please provide filename to write to\" ) ; }  for  ( i in   1 :   length (   martTable @ id ) )  {      cat (   paste (  \" ,    martTable @ id [  i ] ,  \"\\n\" , sep =  \"\" ) , file =  file , append =  TRUE ) ;   cat (     martTable @ table $ sequence [  i ] , file =  file , append =  TRUE ) ;   cat (  \"\\n\\n\" , file =  file , append =  TRUE ) ; } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "exportFASTA",
    "representation": "exportFASTA",
    "parameters": "function ( sequences , file )",
    "body": "{  if (    missing (  sequences ) ||    class (  sequences ) !=  \"data.frame\" )  {    stop (  \"No data.frame given to write FASTA.  The data.frame should be the output of the getSequence function.\" ) ; }  if (   missing (  file ) )  {    stop (  \"Please provide filename to write to\" ) ; }  if (    length (   sequences [  1 , ] ) ==  2 )  {  for  ( i in   seq ( along =   sequences [ ,  2 ] ) )  {      cat (   paste (  \" ,   sequences [  i ,  2 ] ,  \"\\n\" , sep =  \"\" ) , file =  file , append =  TRUE ) ;   cat (   as.character (   sequences [  i ,  1 ] ) , file =  file , append =  TRUE ) ;   cat (  \"\\n\\n\" , file =  file , append =  TRUE ) ; } } else  {  for  ( i in   seq ( along =   sequences [ ,  2 ] ) )  {      cat (   paste (  \" ,   sequences [  i ,  1 ] ,  \"_start_\" ,   sequences [  i ,  2 ] ,  \"_end_\" ,   sequences [  i ,  3 ] ,  \"\\n\" , sep =  \"\" ) , file =  file , append =  TRUE ) ;   cat (   as.character (   sequences [  i ,  4 ] ) , file =  file , append =  TRUE ) ;   cat (  \"\\n\\n\" , file =  file , append =  TRUE ) ; } } } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_1 biomart_release_2_2

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_1 biomart_release_2_2",
    "desc_release_old": "1.12.2",
    "desc_release_new": "1.14.1",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 1,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 1
}

##########
Functions Removed
##########

getFeature


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_2 biomart_release_2_3

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_2 biomart_release_2_3",
    "desc_release_old": "1.14.1",
    "desc_release_new": "1.16.0",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_3 biomart_release_2_4

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_3 biomart_release_2_4",
    "desc_release_old": "1.16.0",
    "desc_release_new": "2.0.0",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 6,
    "function_additions": 3,
    "parameter_removals": 2,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 8
}

##########
Functions Removed
##########

getAffyArrays
getSNP
getHomolog
parseAttributes
parseFilters
filterSummary


##########
Functions Added
##########

attributePages
getBMlist
NP2009code


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , port , includeHosts = FALSE , mysql = FALSE , archive = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     do.call (  \"require\" , args =   list ( package =  \"RMySQL\" ) )  if (   missing (  mart ) )  {   mart =   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"sequence\" ) }  if (   missing (  host ) )  {   host =  \"martdb.ensembl.org\"   user =  \"anonymous\"   password =  \"\"   port =  5316 }   database =  NULL   driv =   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   seq ( along =  host ) )  {     connection =   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] , port =   port [  i ] ) ;   res =   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  if (  !  archive )  {  for  ( j in   seq ( along =  mart ) )  {     matches =   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version =  1 ;   latest =  1 ;  for  ( k in   seq ( along =  matches ) )  {    v =   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  k ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest =  k ;   version =  v ; } } }  if (  !  includeHosts )  {   database =   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database =   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {    database =   c (  database ,   res [  matches ,  1 ] ) ; } else  {    database =   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } else  {   database =   rbind (  database ,  res ) } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }  if (  archive )  {   registry =   getURL (   paste (  host ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   getURL (   paste (  host ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   seq ( len =   xmlSize (   registry [[  i ] ] ) ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ port [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"port\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) } else  {     marts $ vschema [  index ] =  vschema }   index =   index +  1 } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , user , password , mysql = FALSE )",
    "body": "{  if (    mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , port , local = FALSE , mysql = FALSE , archive = FALSE )",
    "body": "{  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )  if (  mysql )  {    do.call (  \"require\" , args =   list ( package =  \"RMySQL\" ) )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  if (   missing (  port ) )  {  if (  archive )  {   port =  3316 } else  {   port =  5316 } }   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE , port =  port )  if (  local )  {  if (     !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) undefined  !   missing (  port ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password , port =  port , mysql =  TRUE ) ;    martBM (  mart ) -     strsplit (  biomart ,  \"_\" ) [[  1 ] ] [  1 ]     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  user , host =  host , dbname =  database , password =  password ) } else  {   stop (   sprintf (  \"Please provide host, user, password and port for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =  NULL  if (  !  archive )  {   marts =   listMarts ( mysql =  TRUE )  for  ( i in   seq ( along =  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart } } else  {   marts =   listMarts ( mysql =  TRUE , archive =  archive )   marts =   marts [ ,  1 ]   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , dbname =  martdb , password =  \"\" , port =  port )   messageToUser (   paste (  \"connected to: \" ,  biomart ,  \"\\n\" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )   mindex2 =   match (  biomart ,   marts $ database )  if (    is.na (  mindex ) undefined   is.na (  mindex2 ) )  {   stop (  \"Incorrect BioMart database, use the listMarts function to see which BioMart databases are available\" ) }  if (   is.na (  mindex ) )   mindex =  mindex2  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , local = FALSE , mysql = FALSE , user , password )",
    "body": "{  if (     local ||  mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host , user , password , port , includeHosts = FALSE , mysql = FALSE , archive = FALSE )",
    "body": "{  if (  mysql )  { #MySQL-----------------------------------------------------------     do.call (  \"require\" , args =   list ( package =  \"RMySQL\" ) )  if (   missing (  mart ) )  {   mart =   c (  \"ensembl\" ,  \"vega\" ,  \"snp\" ,  \"sequence\" ) }  if (   missing (  host ) )  {   host =  \"martdb.ensembl.org\"   user =  \"anonymous\"   password =  \"\"   port =  5316 }   database =  NULL   driv =   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  for  ( i in   seq ( along =  host ) )  {     connection =   dbConnect (  driv , user =   user [  i ] , host =   host [  i ] , password =   password [  i ] , port =   port [  i ] ) ;   res =   dbGetQuery (  connection ,  \"show databases like '%mart%'\" ) ; #Search latest releases of marts  if (     dim (  res ) [  1 ] =  1 )  {  if (  !  archive )  {  for  ( j in   seq ( along =  mart ) )  {     matches =   grep (   mart [  j ] ,   res [ ,  1 ] ) ;  if (    length (  matches ) undefined  1 )  {     version =  1 ;   latest =  1 ;  for  ( k in   seq ( along =  matches ) )  {    v =   suppressWarnings (   as.numeric (     strsplit (   res [   matches [  k ] ,  1 ] ,  \"_\" ) [[  1 ] ] [  3 ] ) ) ;  if (  !   is.na (  v ) )  {  if (   v undefined  version )  {     latest =  k ;   version =  v ; } } }  if (  !  includeHosts )  {   database =   c (  database ,   res [   matches [  latest ] ,  1 ] ) } else  {   database =   rbind (  database ,   cbind (   res [   matches [  latest ] ,  1 ] ,   host [  i ] ) ) } } else  {  if (    sum (  matches ) undefined  0 )  {  if (  !  includeHosts )  {    database =   c (  database ,   res [  matches ,  1 ] ) ; } else  {    database =   rbind (  database ,   cbind (   res [  matches ,  1 ] ,   host [  i ] ) ) ; } } }   dbDisconnect (  connection ) ; } } else  {   database =   rbind (  database ,  res ) } } }   return (  database ) ; } #Webservice----------------------------------------------------- else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }  if (  archive )  {   registry =   getURL (   paste (  host ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   getURL (   paste (  host ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"virtualSchema\" )  {   vschema =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  for  ( j in   seq ( len =   xmlSize (   registry [[  i ] ] ) ) )  {  if (    xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"visible\" ) ==  1 )  {     marts $ biomart [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"name\" )     marts $ version [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"displayName\" )     marts $ host [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"host\" )     marts $ path [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"path\" )     marts $ port [  index ] =   xmlGetAttr (    registry [[  i ] ] [[  j ] ] ,  \"port\" )     marts $ vschema [  index ] =  vschema   index =   index +  1 } } }  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) } else  {     marts $ vschema [  index ] =  vschema }   index =   index +  1 } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , user , password , mysql = FALSE )",
    "body": "{  if (    mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host , user , password , port , local = FALSE , mysql = FALSE , archive = FALSE )",
    "body": "{  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )  if (  mysql )  {    do.call (  \"require\" , args =   list ( package =  \"RMySQL\" ) )   driver -   dbDriver (  \"MySQL\" , force.reload =  FALSE ) ;  if (   missing (  port ) )  {  if (  archive )  {   port =  3316 } else  {   port =  5316 } }   mart -   new (  \"Mart\" , biomart =  biomart , mysqldriver =   list ( driver =  driver ) , mysql =  TRUE , port =  port )  if (  local )  {  if (     !   missing (  host ) undefined  !   missing (  user ) undefined  !   missing (  password ) undefined  !   missing (  port ) )  {    database -   listMarts ( mart =  biomart , host =  host , user =  user , password =  password , port =  port , mysql =  TRUE ) ;    martBM (  mart ) -     strsplit (  biomart ,  \"_\" ) [[  1 ] ] [  1 ]     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  user , host =  host , dbname =  database , password =  password ) } else  {   stop (   sprintf (  \"Please provide host, user, password and port for using local database '%s'.\" ,  biomart ) ) } } else  {   version =  \"0\"   marts =  NULL  if (  !  archive )  {   marts =   listMarts ( mysql =  TRUE )  for  ( i in   seq ( along =  marts ) )  {  if (   biomart ==     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  1 ] )  {   version =     strsplit (   marts [  i ] ,  \"_\" ) [[  1 ] ] [  3 ] } }   martdb =  \"\"  if (   version undefined  0 )  {   martdb =   paste (  biomart ,  \"_mart_\" ,  version , sep =  \"\" ) } else  {   martdb =  biomart } } else  {   marts =   listMarts ( mysql =  TRUE , archive =  archive )   marts =   marts [ ,  1 ]   martdb =  biomart }  if (  !   martdb %in%  marts )   stop (  \"Requested BioMart database is not available please use the function listMarts(mysql=TRUE) to see the valid biomart names you can query using mysql access\" )     martConnection (  mart ) [[  \"biomart\" ] ] -   dbConnect ( drv =    martMySQLDriver (  mart ) $ driver , user =  \"anonymous\" , host =  \"martdb.ensembl.org\" , dbname =  martdb , password =  \"\" , port =  port )   messageToUser (   paste (  \"connected to: \" ,  biomart ,  \"\\n\" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } else  {  if (   missing (  host ) )  {   host =  \"http://www.biomart.org/biomart/martservice\" }   marts =   listMarts ( host =  host , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )   mindex2 =   match (  biomart ,   marts $ database )  if (    is.na (  mindex ) undefined   is.na (  mindex2 ) )  {   stop (  \"Incorrect BioMart database, use the listMarts function to see which BioMart databases are available\" ) }  if (   is.na (  mindex ) )   mindex =  mindex2  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , mysql =  FALSE , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , local = FALSE , mysql = FALSE , user , password )",
    "body": "{  if (     local ||  mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_4 biomart_release_2_5

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_4 biomart_release_2_5",
    "desc_release_old": "2.0.0",
    "desc_release_new": "2.2.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_5 biomart_release_2_6

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_5 biomart_release_2_6",
    "desc_release_old": "2.2.0",
    "desc_release_new": "2.4.0",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 2,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########

getXML


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , user , password , mysql = FALSE )",
    "body": "{  if (    mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE )",
    "body": "{  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) , ssl.verifypeer =  ssl.verifypeer ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) , ssl.verifypeer =  ssl.verifypeer ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , local = FALSE , mysql = FALSE , user , password )",
    "body": "{  if (     local ||  mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , version )",
    "body": "{  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" ) }   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , user , password , mysql = FALSE )",
    "body": "{  if (    mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE )",
    "body": "{  if (  archive )  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) , ssl.verifypeer =  ssl.verifypeer ) } else  {   registry =   bmRequest (   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) , ssl.verifypeer =  ssl.verifypeer ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , local = FALSE , mysql = FALSE , user , password )",
    "body": "{  if (     local ||  mysql ||  !   missing (  user ) ||  !   missing (  password ) )  {   .Defunct ( msg =  \"mysql access to Ensembl is no longer available through this package the web service mode supports all queries.  If mysql is needed a separate package will become available with limited mysql query support.\" ) }  if (   missing (  biomart ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart argument\" )  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" )   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive )   mindex =   match (  biomart ,   marts $ biomart )  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , version )",
    "body": "{  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" ) }   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_6 biomart_release_2_7

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_6 biomart_release_2_7",
    "desc_release_old": "2.4.0",
    "desc_release_new": "2.6.0",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_7 biomart_release_2_8

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_7 biomart_release_2_8",
    "desc_release_old": "2.6.0",
    "desc_release_new": "2.8.1",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_8 biomart_release_2_9

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_8 biomart_release_2_9",
    "desc_release_old": "2.8.1",
    "desc_release_new": "2.10.0",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 3,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 3
}

##########
Functions Removed
##########

getGO
attributeSummary
martDisconnect


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_9 biomart_release_2_11

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_9 biomart_release_2_11",
    "desc_release_old": "2.10.0",
    "desc_release_new": "2.14.0",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_11 biomart_release_2_12

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_11 biomart_release_2_12",
    "desc_release_old": "2.14.0",
    "desc_release_new": "2.16.0",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_12 biomart_release_2_13

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_12 biomart_release_2_13",
    "desc_release_old": "2.16.0",
    "desc_release_new": "2.18.0",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listAttributes",
    "representation": "listAttributes",
    "parameters": "function ( mart , page , what = c ( \"name\" , \"description\" ) , group , category , showGroups = FALSE )",
    "body": "{   martCheck (  mart )  if (  !   missing (  group ) )  {   .Defunct ( msg =  \"Currently the group argument is defunct.  Pending on availability from the BioMart web service group will become activated again or not.\" ) }  if (  showGroups )  {   .Defunct ( msg =  \"Currently the showGroups argument is defunct.  Pending on availability from the BioMart web service showGroups will become activated again or not.\" ) }  if (  !   missing (  category ) )  {   page =  category   warning (  \"To better comply with the BioMart suite (http://www.biomart.org) attribute categories are now known as attribute pages and can be specified with the page parameter\" ) }  if (   !   missing (  page ) undefined  !   page %in%   attributePages (  mart ) )   stop (   paste (  \"The chosen page: \" ,  page ,  \" is not valid, please use the correct page name using the attributePages function\" , sep =  \"\" ) )   attrib =  NULL  if (  !   missing (  page ) )  {   sel =   which (     martAttributes (  mart ) [ ,  \"page\" ] ==  page )   attrib =    martAttributes (  mart ) [  sel ,  what ] } else  {   attrib =    martAttributes (  mart ) [ ,  what ] }   return (  attrib ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listAttributes",
    "representation": "listAttributes",
    "parameters": "function ( mart , page , what = c ( \"name\" , \"description\" ) )",
    "body": "{   martCheck (  mart )  if (   !   missing (  page ) undefined  !   page %in%   attributePages (  mart ) )   stop (   paste (  \"The chosen page: \" ,  page ,  \" is not valid, please use the correct page name using the attributePages function\" , sep =  \"\" ) )   attrib =  NULL  if (  !   missing (  page ) )  {   sel =   which (     martAttributes (  mart ) [ ,  \"page\" ] ==  page )   attrib =    martAttributes (  mart ) [  sel ,  what ] } else  {   attrib =    martAttributes (  mart ) [ ,  what ] }   return (  attrib ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listAttributes",
    "representation": "listAttributes",
    "parameters": "function ( mart , page , what = c ( \"name\" , \"description\" ) , group , category , showGroups = FALSE )",
    "body": "{   martCheck (  mart )  if (  !   missing (  group ) )  {   .Defunct ( msg =  \"Currently the group argument is defunct.  Pending on availability from the BioMart web service group will become activated again or not.\" ) }  if (  showGroups )  {   .Defunct ( msg =  \"Currently the showGroups argument is defunct.  Pending on availability from the BioMart web service showGroups will become activated again or not.\" ) }  if (  !   missing (  category ) )  {   page =  category   warning (  \"To better comply with the BioMart suite (http://www.biomart.org) attribute categories are now known as attribute pages and can be specified with the page parameter\" ) }  if (   !   missing (  page ) undefined  !   page %in%   attributePages (  mart ) )   stop (   paste (  \"The chosen page: \" ,  page ,  \" is not valid, please use the correct page name using the attributePages function\" , sep =  \"\" ) )   attrib =  NULL  if (  !   missing (  page ) )  {   sel =   which (     martAttributes (  mart ) [ ,  \"page\" ] ==  page )   attrib =    martAttributes (  mart ) [  sel ,  what ] } else  {   attrib =    martAttributes (  mart ) [ ,  what ] }   return (  attrib ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listAttributes",
    "representation": "listAttributes",
    "parameters": "function ( mart , page , what = c ( \"name\" , \"description\" ) )",
    "body": "{   martCheck (  mart )  if (   !   missing (  page ) undefined  !   page %in%   attributePages (  mart ) )   stop (   paste (  \"The chosen page: \" ,  page ,  \" is not valid, please use the correct page name using the attributePages function\" , sep =  \"\" ) )   attrib =  NULL  if (  !   missing (  page ) )  {   sel =   which (     martAttributes (  mart ) [ ,  \"page\" ] ==  page )   attrib =    martAttributes (  mart ) [  sel ,  what ] } else  {   attrib =    martAttributes (  mart ) [ ,  what ] }   return (  attrib ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "listFilters",
    "representation": "listFilters",
    "parameters": "function ( mart , what = c ( \"name\" , \"description\" ) , group = \"DEFUNCT\" )",
    "body": "{  if (  !   missing (  group ) )   .Defunct ( msg =  \"The argument 'group' is defunct. If you need advice how to replace that functionality, please contact the package maintainer for advice.\" )   martCheck (  mart )   filters =   martFilters (  mart )   badwhat =  !  (   what %in%   colnames (  filters ) )  if (   any (  badwhat ) )   stop (   sprintf (  \"The function argument 'what' contains %s: %s\\nValid are: %s\\n\" ,  if (    sum (  badwhat ) undefined  1 )  \"invalid values\" else  \"an invalid value\" ,   paste (   what [  badwhat ] , collapse =  \", \" ) ,   paste (   colnames (  filters ) , collapse =  \", \" ) ) )   return (   filters [ ,  what ] ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listFilters",
    "representation": "listFilters",
    "parameters": "function ( mart , what = c ( \"name\" , \"description\" ) )",
    "body": "{   martCheck (  mart )   filters =   martFilters (  mart )   badwhat =  !  (   what %in%   colnames (  filters ) )  if (   any (  badwhat ) )   stop (   sprintf (  \"The function argument 'what' contains %s: %s\\nValid are: %s\\n\" ,  if (    sum (  badwhat ) undefined  1 )  \"invalid values\" else  \"an invalid value\" ,   paste (   what [  badwhat ] , collapse =  \", \" ) ,   paste (   colnames (  filters ) , collapse =  \", \" ) ) )   return (   filters [ ,  what ] ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_13 biomart_release_2_14

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_13 biomart_release_2_14",
    "desc_release_old": "2.18.0",
    "desc_release_new": "2.20.0",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

keys
columns
keytypes
select


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_2_14 biomart_release_3_1

{
    "package": "biomaRt",
    "release_versions": "biomart_release_2_14 biomart_release_3_1",
    "desc_release_old": "2.20.0",
    "desc_release_new": "2.24.1",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

listEnsembl
useEnsembl


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , verbose = FALSE )",
    "body": "{  if (  archive )  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" )   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose ) } else  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" )   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"host\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"path\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"port\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame (   marts $ database ,   marts $ version ) } else  {   ret =   data.frame (   marts $ biomart ,   marts $ version ) }    colnames (  ret ) =   c (  \"biomart\" ,  \"version\" )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.biomart.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , verbose = FALSE )",
    "body": "{   request =  NULL  if (   is.null (  mart ) )  {  if (  archive )  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) } else  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) } } else  {  if (    class (  mart ) ==  'Mart' )  {   request =   paste (   martHost (  mart ) ,  \"?type=registry , sep =  \"\" ) } else  {   warning (   paste (  mart ,  \"object needs to be of class Mart created with the useMart function.  If you don't have a Mart object yet, use listMarts without arguments or only specify the host argument\" , sep =  \" \" ) ) } }   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose )   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame ( biomart =   as.character (   marts $ database ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) } else  {   ret =   data.frame ( biomart =   as.character (   marts $ biomart ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) }   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_1 biomart_release_3_2

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_1 biomart_release_3_2",
    "desc_release_old": "2.24.1",
    "desc_release_new": "2.26.1",
    "old_release_number": 17,
    "new_release_number": 18,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listEnsembl",
    "representation": "listEnsembl",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , verbose = FALSE )",
    "body": "{  if (  !   is.null (  version ) )  {   host =   paste (  \"e\" ,  version ,  \".ensembl.org\" , sep =  \"\" ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }   marts =   listMarts ( mart =  mart , host =  host , verbose =  verbose )   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_ENSEMBL\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"ensembl\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_SNP\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"snp\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_FUNCGEN\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"regulation\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_VEGA\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"vega\" }   return (  marts ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listEnsembl",
    "representation": "listEnsembl",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.  Will ignore the mirror argument and connect to default ensembl host\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   host =   paste (  \"e\" ,  version ,  \".ensembl.org\" , sep =  \"\" ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror select a mirror from [uswest,useast,asia], default when no mirror is specified points to main ensembl hosted in the UK\" ) } else  {  if (   mirror ==  \"uswest\" )  {   host =  \"uswest.ensembl.org\" }  if (   mirror ==  \"useast\" )  {   host ==  \"useast.ensembl.org\" }  if (   mirror ==  \"asia\" )  {   host =  \"asia.ensembl.org\" } } }   marts =   listMarts ( mart =  mart , host =  host , verbose =  verbose )   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_ENSEMBL\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"ensembl\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_SNP\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"snp\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_FUNCGEN\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"regulation\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_VEGA\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"vega\" }   return (  marts ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , verbose = FALSE )",
    "body": "{  if (  !   is.null (  version ) )  {   host =   paste (  \"e\" ,  version ,  \".ensembl.org\" , sep =  \"\" ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose )   return (  ens ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.  Will ignore the mirror argument and connect to default ensembl host\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   host =   paste (  \"e\" ,  version ,  \".ensembl.org\" , sep =  \"\" ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror select a mirror from [uswest,useast,asia], default when no mirror is specified points to main ensembl hosted in the UK\" ) } else  {  if (   mirror ==  \"uswest\" )  {   host =  \"uswest.ensembl.org\" }  if (   mirror ==  \"useast\" )  {   host ==  \"useast.ensembl.org\" }  if (   mirror ==  \"asia\" )  {   host =  \"asia.ensembl.org\" } } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose )   return (  ens ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_2 biomart_release_3_3

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_2 biomart_release_3_3",
    "desc_release_old": "2.26.1",
    "desc_release_new": "2.28.0",
    "old_release_number": 18,
    "new_release_number": 19,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_3 biomart_release_3_4

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_3 biomart_release_3_4",
    "desc_release_old": "2.28.0",
    "desc_release_new": "2.30.0",
    "old_release_number": 19,
    "new_release_number": 20,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_4 biomart_release_3_5

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_4 biomart_release_3_5",
    "desc_release_old": "2.30.0",
    "desc_release_new": "2.32.1",
    "old_release_number": 20,
    "new_release_number": 21,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , verbose = FALSE )",
    "body": "{   request =  NULL  if (   is.null (  mart ) )  {  if (  archive )  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive , sep =  \"\" ) } else  {   request =   paste (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry , sep =  \"\" ) } } else  {  if (    class (  mart ) ==  'Mart' )  {   request =   paste (   martHost (  mart ) ,  \"?type=registry , sep =  \"\" ) } else  {   warning (   paste (  mart ,  \"object needs to be of class Mart created with the useMart function.  If you don't have a Mart object yet, use listMarts without arguments or only specify the host argument\" , sep =  \" \" ) ) } }   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose )   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame ( biomart =   as.character (   marts $ database ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) } else  {   ret =   data.frame ( biomart =   as.character (   marts $ biomart ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) }   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = TRUE , verbose = FALSE )",
    "body": "{   request =  NULL  if (   is.null (  mart ) )  { ## adding option to force use of specificed host with ensembl   redirect -   ifelse (   !  ensemblRedirect undefined   grepl ( x =  host , pattern =  \"ensembl.org\" ) ,  \" ,  \"\" )  if (  archive )  {   request =   paste0 (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry_archive ) } else  {   request =   paste0 (  \"http://\" ,  host ,  \":\" ,  port ,  path ,  \"?type=registry ,  redirect ) } } else  {  if (    class (  mart ) ==  'Mart' )  {   request =   paste0 (   martHost (  mart ) ,  \"?type=registry ) } else  {   warning (   paste (  mart ,  \"object needs to be of class Mart created with the useMart function.  If you don't have a Mart object yet, use listMarts without arguments or only specify the host argument\" , sep =  \" \" ) ) } }   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose ) ## check this looks like the MartRegistry XML, otherwise throw an error  if (  !   grepl ( x =  registry , pattern =  \"^\\n* ) )  {   stop (  'Unexpected format to the list of available marts.\\n' ,  'Please check the following URL manually, ' ,  'and try ?listMarts for advice.\\n' ,  request ) }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {  if (  archive )  {   ret =   data.frame ( biomart =   as.character (   marts $ database ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) } else  {   ret =   data.frame ( biomart =   as.character (   marts $ biomart ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE ) }   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , version , verbose = FALSE )",
    "body": "{  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is no string.  The biomart argument should be a single character string\" ) }  if (    biomart ==  \"ensembl\" undefined  (    host ==  \"www.ensembl.org\" |   host ==  \"uswest.ensembl.org\" ) )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }   reqHost =  host   marts =  NULL   marts =   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] , sep =  \"\" ) , archive =  archive )  if (   length (    grep (  \"archive\" ,   martHost (  mart ) ) undefined  0 ) )  {  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Note: requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) )   writeLines (  \"When using archived Ensembl versions this sometimes can result in connecting to a newer version than the intended Ensembl version\" )   writeLines (  \"Check your ensembl version using listMarts(mart)\" ) } }   BioMartVersion =   bmVersion (  mart , verbose =  verbose )  if (    martHost (  mart ) ==  \"http://www.biomart.org:80/biomart/martservice\" )  {   if (  verbose )   writeLines (  \"Using Central Repository at www.biomart.org\" ) ;    martVSchema (  mart ) -  'default' #Assume central service query uses default vSchema }  if (  verbose )  {   writeLines (   paste (  \"BioMartServer running BioMart version:\" ,  BioMartVersion , sep =  \" \" ) )   writeLines (   paste (  \"Mart virtual schema:\" ,   martVSchema (  mart ) , sep =  \" \" ) )  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) ) }   writeLines (   paste (  \"Mart host:\" ,   martHost (  mart ) , sep =  \" \" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset , verbose =  verbose ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = TRUE , version , verbose = FALSE )",
    "body": "{  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is not a string. \" ,  \"The biomart argument should be a single character string\" ) } #if(biomart == \"ensembl\"  if (    biomart ==  \"ensembl\" undefined   grepl ( x =  host , pattern =  \"ensembl.org\" ) )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }   reqHost =  host   marts -   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer , ensemblRedirect =  ensemblRedirect )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry  if (  archive )   biomart =    marts $ biomart [  mindex ]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE ) ## adding option to force use of specificed host with ensembl   redirect -   ifelse (   !  ensemblRedirect undefined   grepl ( x =  host , pattern =  \"ensembl.org\" ) ,  \"?redirect=no\" ,  \"\" )   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste0 (  \"http://\" ,    marts $ host [  mindex ] ,  \":\" ,    marts $ port [  mindex ] ,    marts $ path [  mindex ] ,  redirect ) , archive =  archive )  if (   length (    grep (  \"archive\" ,   martHost (  mart ) ) undefined  0 ) )  {  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Note: requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) )   writeLines (  \"When using archived Ensembl versions this sometimes can result in connecting to a newer version than the intended Ensembl version\" )   writeLines (  \"Check your ensembl version using listMarts(mart)\" ) } }   BioMartVersion =   bmVersion (  mart , verbose =  verbose ) #### below can probably be deleted, MS - 05/04/2017 #if(martHost(mart) ==\"http://www.biomart.org:80/biomart/martservice\"){ #    if(verbose) writeLines(\"Using Central Repository at www.biomart.org\"); #    martVSchema(mart) #} ####  if (  verbose )  {   writeLines (   paste (  \"BioMartServer running BioMart version:\" ,  BioMartVersion , sep =  \" \" ) )   writeLines (   paste (  \"Mart virtual schema:\" ,   martVSchema (  mart ) , sep =  \" \" ) )  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) ) }   writeLines (   paste (  \"Mart host:\" ,   martHost (  mart ) , sep =  \" \" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset , verbose =  verbose ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_5 biomart_release_3_6

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_5 biomart_release_3_6",
    "desc_release_old": "2.32.1",
    "desc_release_new": "2.34.2",
    "old_release_number": 21,
    "new_release_number": 22,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

listEnsemblArchives


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_6 biomart_release_3_7

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_6 biomart_release_3_7",
    "desc_release_old": "2.34.2",
    "desc_release_new": "2.36.1",
    "old_release_number": 22,
    "new_release_number": 23,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_7 biomart_release_3_8

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_7 biomart_release_3_8",
    "desc_release_old": "2.36.1",
    "desc_release_new": "2.38.0",
    "old_release_number": 23,
    "new_release_number": 24,
    "function_removals": 0,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

searchAttributes
searchDatasets
searchFilters


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_8 biomart_release_3_9

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_8 biomart_release_3_9",
    "desc_release_old": "2.38.0",
    "desc_release_new": "2.40.5",
    "old_release_number": 24,
    "new_release_number": 25,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

listFilterValues
searchFilterValues


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  biomart ) )  {   stop (  \"You must provide the argument 'biomart'\\n\" ,  \"Available Ensembl Marts can be viewed with \" ,  \"the function listEnsembl()\" ) }  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.  Will ignore the mirror argument and connect to main Ensembl site.\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   archives -   listEnsemblArchives ( )   idx -   match (  version ,   archives [ ,  'version' ] , nomatch =  NA )  if (   is.na (  idx ) )  {   stop (  'Specified Ensembl version is not available.\\n' ,  'Use listEnsemblArchives() to view available versions.' , call. =  FALSE ) }   host =   archives [  idx ,  'url' ] }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"www\" ,  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror select a mirror from [www, uswest, useast, asia].\\n\" ,  \"default when no mirror is specified is to use \" ,  \"www.ensembl.org\" )   host -  \"www.ensembl.org\" } else  {   host -   paste0 (  mirror ,  \".ensembl.org\" ) } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose )   return (  ens ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  biomart ) )  {   stop (  \"You must provide the argument 'biomart'\\n\" ,  \"Available Ensembl Marts can be viewed with \" ,  \"the function listEnsembl()\" ) }  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.', \r\n                'We will ignore the mirror argument and connect to main Ensembl site.\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   archives -   listEnsemblArchives ( )   idx -   match (  version ,   archives [ ,  'version' ] , nomatch =  NA )  if (   is.na (  idx ) )  {   stop (  'Specified Ensembl version is not available.\\n' ,  'Use listEnsemblArchives() to view available versions.' , call. =  FALSE ) }   host -   archives [  idx ,  'url' ]   host -   gsub ( x =  host , pattern =  \"http://\" , replacement =  \"https://\" , fixed =  TRUE ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host -   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"www\" ,  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror. Select a mirror from [www, uswest, useast, asia].\\n\" ,  \"Default when no mirror is specified is to use \" ,  \"www.ensembl.org\" )   host -  \"https://www.ensembl.org\" } else  {   host -   paste0 (  \"https://\" ,  mirror ,  \".ensembl.org\" ) } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }  if (   missing (  host ) )  {   host =  \"https://www.ensembl.org\" } ## choose the port based on whether we use https or not   port -   ifelse (   grepl ( pattern =  \"https://\" , x =  host ) , yes =  443 , no =  80 )   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose , port =  port )   return (  ens ) } ",
    "filename": "ensembl.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  biomart ) )  {   stop (  \"You must provide the argument 'biomart'\\n\" ,  \"Available Ensembl Marts can be viewed with \" ,  \"the function listEnsembl()\" ) }  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.  Will ignore the mirror argument and connect to main Ensembl site.\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   archives -   listEnsemblArchives ( )   idx -   match (  version ,   archives [ ,  'version' ] , nomatch =  NA )  if (   is.na (  idx ) )  {   stop (  'Specified Ensembl version is not available.\\n' ,  'Use listEnsemblArchives() to view available versions.' , call. =  FALSE ) }   host =   archives [  idx ,  'url' ] }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"www\" ,  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror select a mirror from [www, uswest, useast, asia].\\n\" ,  \"default when no mirror is specified is to use \" ,  \"www.ensembl.org\" )   host -  \"www.ensembl.org\" } else  {   host -   paste0 (  mirror ,  \".ensembl.org\" ) } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose )   return (  ens ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "useEnsembl",
    "representation": "useEnsembl",
    "parameters": "function ( biomart , dataset , host , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  biomart ) )  {   stop (  \"You must provide the argument 'biomart'\\n\" ,  \"Available Ensembl Marts can be viewed with \" ,  \"the function listEnsembl()\" ) }  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.', \r\n                'We will ignore the mirror argument and connect to main Ensembl site.\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   archives -   listEnsemblArchives ( )   idx -   match (  version ,   archives [ ,  'version' ] , nomatch =  NA )  if (   is.na (  idx ) )  {   stop (  'Specified Ensembl version is not available.\\n' ,  'Use listEnsemblArchives() to view available versions.' , call. =  FALSE ) }   host -   archives [  idx ,  'url' ]   host -   gsub ( x =  host , pattern =  \"http://\" , replacement =  \"https://\" , fixed =  TRUE ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host -   paste (  \"grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"www\" ,  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror. Select a mirror from [www, uswest, useast, asia].\\n\" ,  \"Default when no mirror is specified is to use \" ,  \"www.ensembl.org\" )   host -  \"https://www.ensembl.org\" } else  {   host -   paste0 (  \"https://\" ,  mirror ,  \".ensembl.org\" ) } }  if (   biomart ==  \"ensembl\" )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }  if (   biomart ==  \"snp\" )  {   biomart =  \"ENSEMBL_MART_SNP\" }  if (   biomart ==  \"regulation\" )  {   biomart =  \"ENSEMBL_MART_FUNCGEN\" }  if (   biomart ==  \"vega\" )  {   biomart =  \"ENSEMBL_MART_VEGA\" }  if (   missing (  host ) )  {   host =  \"https://www.ensembl.org\" } ## choose the port based on whether we use https or not   port -   ifelse (   grepl ( pattern =  \"https://\" , x =  host ) , yes =  443 , no =  80 )   ens =   useMart ( biomart =  biomart , dataset =  dataset , host =  host , verbose =  verbose , port =  port )   return (  ens ) } ",
    "filename": "ensembl.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_9 biomart_release_3_11

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_9 biomart_release_3_11",
    "desc_release_old": "2.40.5",
    "desc_release_new": "2.44.4",
    "old_release_number": 25,
    "new_release_number": 26,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 2,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########

biomartCacheClear
biomartCacheInfo
useEnsemblGenomes
listEnsemblGenomes


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' )   ensemblRedirect -  NULL }   request =  NULL  if (   is.null (  mart ) )  {   host -   .cleanHostURL (  host )  if (  archive )  {   stop (  \"The archive = TRUE argument is now defunct.\\nUse listEnsemblArchives() to find the URL to directly query an Ensembl archive.\" ) } else  {   request =   paste0 (  host ,  \":\" ,  port ,  path ,  \"?type=registry ) } } else  {  if (    class (  mart ) ==  'Mart' )  {   request =   paste0 (   martHost (  mart ) ,  \"?type=registry ) } else  {   warning (   paste (  mart ,  \"object needs to be of class Mart created with the useMart function.  If you don't have a Mart object yet, use listMarts without arguments or only specify the host argument\" , sep =  \" \" ) ) } }   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose ) ## check this looks like the MartRegistry XML, otherwise throw an error  if (  !   grepl ( x =  registry , pattern =  \"^\\n* ) )  {  if (   grepl ( x =  registry , pattern =  \"status.ensembl.org\" ) )  {   stop (  \"Your query has been redirected to http://status.ensembl.org \" ,  \"indicating this Ensembl service is currently unavailable\" ,  \"\\nLook at ?useEnsembl for details on how to try a mirror site.\" , call. =  FALSE ) } else  {   stop (  'Unexpected format to the list of available marts.\\n' ,  'Please check the following URL manually, ' ,  'and try ?listMarts for advice.\\n' ,  request ) } }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {   ret =   data.frame ( biomart =   as.character (   marts $ biomart ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and does not do anything.' ,  '\\nSee ?useEnsembl for details on using mirror sites.' ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = NULL , version , verbose = FALSE )",
    "body": "{  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' )   ensemblRedirect -  NULL }  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is not a string. \" ,  \"The biomart argument should be a single character string\" ) }  if (    biomart ==  \"ensembl\" undefined   grepl ( x =  host , pattern =  \"ensembl.org\" ) )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }   reqHost =  host   host -   .cleanHostURL (  host )   marts -   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry #if(archive) biomart = marts$biomart[mindex]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE ) ## adding option to force use of specificed host with ensembl #redirect #                   \"?redirect=no\", #                   \"\")   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste0 (  host ,  \":\" ,  port ,    marts $ path [  mindex ] ) )  if (   length (    grep (  \"archive\" ,   martHost (  mart ) ) undefined  0 ) )  { ## hack to work around redirection of most recent mirror URL   archives -   listEnsemblArchives ( )   current_release -   archives [    archives $ current_release ==  \"*\" ,  'url' ]  if (   grepl (   mart @ host , pattern =  current_release ) )  {    mart @ host -   stringr :: str_replace (   mart @ host , pattern =  current_release ,  \"https://www.ensembl.org\" )    mart @ host -   stringr :: str_replace (   mart @ host , pattern =  \":80/\" ,  \":443/\" ) } #if(length(grep(reqHost,martHost(mart))) == 0){ #    message(\"Note: requested host was redirected from\\n\", reqHost, \" to \" , martHost(mart)) #    message(\"This often occurs when connecting to the archive URL for the current Ensembl release\") #    message(\"You can check the current version number using listEnsemblArchives()\") #} }   BioMartVersion =   bmVersion (  mart , verbose =  verbose )  if (  verbose )  {   writeLines (   paste (  \"BioMartServer running BioMart version:\" ,  BioMartVersion , sep =  \" \" ) )   writeLines (   paste (  \"Mart virtual schema:\" ,   martVSchema (  mart ) , sep =  \" \" ) )  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) ) }   writeLines (   paste (  \"Mart host:\" ,   martHost (  mart ) , sep =  \" \" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset , verbose =  verbose ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"https://www.ensembl.org\" , path = \"/biomart/martservice\" , port , archive = FALSE , ensemblRedirect = NULL , version , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' ) }   mart -   .useMart (  biomart ,  dataset , host =  host , path =  path , port =  port , archive =  archive , version =  version , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , includeHosts = FALSE , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' )   ensemblRedirect -  NULL }   request =  NULL  if (   is.null (  mart ) )  {   host -   .cleanHostURL (  host )  if (  archive )  {   stop (  \"The archive = TRUE argument is now defunct.\\nUse listEnsemblArchives() to find the URL to directly query an Ensembl archive.\" ) } else  {   request =   paste0 (  host ,  \":\" ,  port ,  path ,  \"?type=registry ) } } else  {  if (    class (  mart ) ==  'Mart' )  {   request =   paste0 (   martHost (  mart ) ,  \"?type=registry ) } else  {   warning (   paste (  mart ,  \"object needs to be of class Mart created with the useMart function.  If you don't have a Mart object yet, use listMarts without arguments or only specify the host argument\" , sep =  \" \" ) ) } }   registry =   bmRequest ( request =  request , ssl.verifypeer =  ssl.verifypeer , verbose =  verbose ) ## check this looks like the MartRegistry XML, otherwise throw an error  if (  !   grepl ( x =  registry , pattern =  \"^\\n* ) )  {  if (   grepl ( x =  registry , pattern =  \"status.ensembl.org\" ) )  {   stop (  \"Your query has been redirected to http://status.ensembl.org \" ,  \"indicating this Ensembl service is currently unavailable\" ,  \"\\nLook at ?useEnsembl for details on how to try a mirror site.\" , call. =  FALSE ) } else  {   stop (  'Unexpected format to the list of available marts.\\n' ,  'Please check the following URL manually, ' ,  'and try ?listMarts for advice.\\n' ,  request ) } }   registry =   xmlTreeParse (  registry , asText =  TRUE )   registry =     registry $ doc $ children [[  1 ] ]   marts =   list ( biomart =  NULL , version =  NULL , host =  NULL , path =  NULL , database =  NULL )   index =  1  if (    host !=  \"www.biomart.org\" ||  archive )  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) ) )     marts $ host [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"host\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) ) )     marts $ path [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"path\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) ) )     marts $ port [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"port\" ) )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   as.character (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) }   index =   index +  1 } } } } else  {  for  ( i in   seq ( len =   xmlSize (  registry ) ) )  {  if (    xmlName (   registry [[  i ] ] ) ==  \"MartURLLocation\" )  {  if (    xmlGetAttr (   registry [[  i ] ] ,  \"visible\" ) ==  1 )  {  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"name\" ) ) )     marts $ biomart [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"name\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"database\" ) ) )     marts $ database [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"database\" )  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" ) ) )     marts $ version [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"displayName\" )     marts $ host [  index ] =  host     marts $ path [  index ] =  path     marts $ port [  index ] =  80  if (  !   is.null (   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) ) )  {     marts $ vschema [  index ] =   xmlGetAttr (   registry [[  i ] ] ,  \"serverVirtualSchema\" ) }   index =   index +  1 } } } }  if (  includeHosts )  {   return (  marts ) } else  {   ret =   data.frame ( biomart =   as.character (   marts $ biomart ) , version =   as.character (   marts $ version ) , stringsAsFactors =  FALSE )   return (  ret ) } } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and does not do anything.' ,  '\\nSee ?useEnsembl for details on using mirror sites.' ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port = 80 , archive = FALSE , ssl.verifypeer = TRUE , ensemblRedirect = NULL , version , verbose = FALSE )",
    "body": "{  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' )   ensemblRedirect -  NULL }  if (    missing (  biomart ) undefined   missing (  version ) )   stop (  \"No biomart databases specified. Specify a biomart database to use using the biomart or version argument\" )  if (  !   missing (  biomart ) )  {  if (  !  (   is.character (  biomart ) ) )   stop (  \"biomart argument is not a string. \" ,  \"The biomart argument should be a single character string\" ) }  if (    biomart ==  \"ensembl\" undefined   grepl ( x =  host , pattern =  \"ensembl.org\" ) )  {   biomart =  \"ENSEMBL_MART_ENSEMBL\" }   reqHost =  host   host -   .cleanHostURL (  host )   marts -   listMarts ( host =  host , path =  path , port =  port , includeHosts =  TRUE , archive =  archive , ssl.verifypeer =  ssl.verifypeer )   mindex =  NA  if (  !   missing (  biomart ) )  {   mindex =   match (  biomart ,   marts $ biomart ) }  if (  !   missing (  version ) )  {   mindex =   match (  version ,   marts $ version ) }  if (    is.na (  mindex ) ||  archive )  {   mindex =   match (  biomart ,   marts $ database ) }  if (   is.na (  mindex ) )   stop (  \"Incorrect BioMart name, use the listMarts function to see which BioMart databases are available\" )  if (       is.na (    marts $ path [  mindex ] ) ||   is.na (    marts $ vschema [  mindex ] ) ||   is.na (    marts $ host [  mindex ] ) ||   is.na (    marts $ port [  mindex ] ) ||   is.na (    marts $ path [  mindex ] ) )   stop (  \"The selected biomart databases is not available due to error in the BioMart central registry, please report so the BioMart registry file can be fixed.\" )  if (     marts $ path [  mindex ] ==  \"\" )     marts $ path [  mindex ] =  \"/biomart/martservice\" #temporary to catch bugs in registry #if(archive) biomart = marts$biomart[mindex]  if (  !   missing (  version ) )   biomart =    marts $ biomart [  mindex ]   biomart =   sub (  \" \" ,  \"%20\" ,  biomart , fixed =  TRUE , useBytes =  TRUE ) ## adding option to force use of specificed host with ensembl #redirect #                   \"?redirect=no\", #                   \"\")   mart -   new (  \"Mart\" , biomart =  biomart , vschema =    marts $ vschema [  mindex ] , host =   paste0 (  host ,  \":\" ,  port ,    marts $ path [  mindex ] ) )  if (   length (    grep (  \"archive\" ,   martHost (  mart ) ) undefined  0 ) )  { ## hack to work around redirection of most recent mirror URL   archives -   listEnsemblArchives ( )   current_release -   archives [    archives $ current_release ==  \"*\" ,  'url' ]  if (   grepl (   mart @ host , pattern =  current_release ) )  {    mart @ host -   stringr :: str_replace (   mart @ host , pattern =  current_release ,  \"https://www.ensembl.org\" )    mart @ host -   stringr :: str_replace (   mart @ host , pattern =  \":80/\" ,  \":443/\" ) } #if(length(grep(reqHost,martHost(mart))) == 0){ #    message(\"Note: requested host was redirected from\\n\", reqHost, \" to \" , martHost(mart)) #    message(\"This often occurs when connecting to the archive URL for the current Ensembl release\") #    message(\"You can check the current version number using listEnsemblArchives()\") #} }   BioMartVersion =   bmVersion (  mart , verbose =  verbose )  if (  verbose )  {   writeLines (   paste (  \"BioMartServer running BioMart version:\" ,  BioMartVersion , sep =  \" \" ) )   writeLines (   paste (  \"Mart virtual schema:\" ,   martVSchema (  mart ) , sep =  \" \" ) )  if (    length (   grep (  reqHost ,   martHost (  mart ) ) ) ==  0 )  {   writeLines (   paste (  \"Requested host was redirected from \" ,  reqHost ,  \" to \" ,   martHost (  mart ) , sep =  \"\" ) ) }   writeLines (   paste (  \"Mart host:\" ,   martHost (  mart ) , sep =  \" \" ) ) }  if (  !   missing (  dataset ) )  {   mart =   useDataset ( mart =  mart , dataset =  dataset , verbose =  verbose ) }   return (  mart ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"https://www.ensembl.org\" , path = \"/biomart/martservice\" , port , archive = FALSE , ensemblRedirect = NULL , version , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' ) }   mart -   .useMart (  biomart ,  dataset , host =  host , path =  path , port =  port , archive =  archive , version =  version , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_11 biomart_release_3_12

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_11 biomart_release_3_12",
    "desc_release_old": "2.44.4",
    "desc_release_new": "2.46.3",
    "old_release_number": 26,
    "new_release_number": 27,
    "function_removals": 1,
    "function_additions": 0,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 2
}

##########
Functions Removed
##########

getXML


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( )",
    "body": "{   url -  \"https://www.ensembl.org/info/website/archives/index.html?redirect=no\"   html -   xml2 :: read_html (   GET (  url ) )   html -   htmlParse (  html )   archive_box -    getNodeSet (  html , path =  \"//div[@class='plain-box float-right archive-box']\" ) [[  1 ] ]   archive_box_string -   toString.XMLNode (  archive_box )   archives -     strsplit (  archive_box_string , split =  \" ) [[  1 ] ] [  -  1 ]   extracted -   str_extract_all ( string =  archives , pattern =  \"Ensembl [A-Za-z0-9 ]{2,6}|http[s]?://.*ensembl\\\\.org|[A-Z][a-z]{2} [0-9]{4}\" ) ## split the version number into a separate column   extracted -   lapply (  extracted , FUN =  function ( x )  {   version -    str_match (   x [  2 ] , pattern =  \".+ ([a-zA-Z0-9]+)$\" ) [  2 ]   return (   c (  x ,  version ) ) } )   current -   ifelse (   stringr :: str_detect (  archives ,  \"- this site\" ) ,  \"*\" ,  \"\" )   tab -   do.call (  \"rbind\" ,  extracted )   tab -   cbind (  tab ,  current )   dframe -   data.frame ( \"name\" =   as.character (   tab [ ,  2 ] ) , \"date\" =   as.character (   tab [ ,  3 ] ) , \"url\" =   tolower (   as.character (   tab [ ,  1 ] ) ) , \"version\" =   as.character (   tab [ ,  4 ] ) , \"current_release\" =   as.character (   tab [ ,  5 ] ) , stringsAsFactors =  FALSE )   return (  dframe ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https = TRUE )",
    "body": "{   url -   ifelse (  https ,  \"https://www.ensembl.org/info/website/archives/index.html\" ,  \"http://www.ensembl.org/info/website/archives/index.html\" )   html -   xml2 :: read_html (   GET (  url ) )   html -   htmlParse (  html )   archive_box -    getNodeSet (  html , path =  \"//div[@class='plain-box float-right archive-box']\" ) [[  1 ] ]   archive_box_string -   toString.XMLNode (  archive_box )   archives -     strsplit (  archive_box_string , split =  \" ) [[  1 ] ] [  -  1 ]   extracted -   str_extract_all ( string =  archives , pattern =  \"Ensembl [A-Za-z0-9 ]{2,6}|http[s]?://.*ensembl\\\\.org|[A-Z][a-z]{2} [0-9]{4}\" ) ## split the version number into a separate column   extracted -   lapply (  extracted , FUN =  function ( x )  {   version -    str_match (   x [  2 ] , pattern =  \".+ ([a-zA-Z0-9]+)$\" ) [  2 ]   return (   c (  x ,  version ) ) } )   current -   ifelse (   stringr :: str_detect (  archives ,  \"- this site\" ) ,  \"*\" ,  \"\" )   tab -   do.call (  \"rbind\" ,  extracted )   tab -   cbind (  tab ,  current )   dframe -   data.frame ( \"name\" =   as.character (   tab [ ,  2 ] ) , \"date\" =   as.character (   tab [ ,  3 ] ) , \"url\" =   stringr :: str_replace (   tolower (   as.character (   tab [ ,  1 ] ) ) ,  \"http://\" ,  \"https://\" ) , \"version\" =   as.character (   tab [ ,  4 ] ) , \"current_release\" =   as.character (   tab [ ,  5 ] ) , stringsAsFactors =  FALSE )   return (  dframe ) } ",
    "filename": "ensembl.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( )",
    "body": "{   url -  \"https://www.ensembl.org/info/website/archives/index.html?redirect=no\"   html -   xml2 :: read_html (   GET (  url ) )   html -   htmlParse (  html )   archive_box -    getNodeSet (  html , path =  \"//div[@class='plain-box float-right archive-box']\" ) [[  1 ] ]   archive_box_string -   toString.XMLNode (  archive_box )   archives -     strsplit (  archive_box_string , split =  \" ) [[  1 ] ] [  -  1 ]   extracted -   str_extract_all ( string =  archives , pattern =  \"Ensembl [A-Za-z0-9 ]{2,6}|http[s]?://.*ensembl\\\\.org|[A-Z][a-z]{2} [0-9]{4}\" ) ## split the version number into a separate column   extracted -   lapply (  extracted , FUN =  function ( x )  {   version -    str_match (   x [  2 ] , pattern =  \".+ ([a-zA-Z0-9]+)$\" ) [  2 ]   return (   c (  x ,  version ) ) } )   current -   ifelse (   stringr :: str_detect (  archives ,  \"- this site\" ) ,  \"*\" ,  \"\" )   tab -   do.call (  \"rbind\" ,  extracted )   tab -   cbind (  tab ,  current )   dframe -   data.frame ( \"name\" =   as.character (   tab [ ,  2 ] ) , \"date\" =   as.character (   tab [ ,  3 ] ) , \"url\" =   tolower (   as.character (   tab [ ,  1 ] ) ) , \"version\" =   as.character (   tab [ ,  4 ] ) , \"current_release\" =   as.character (   tab [ ,  5 ] ) , stringsAsFactors =  FALSE )   return (  dframe ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https = TRUE )",
    "body": "{   url -   ifelse (  https ,  \"https://www.ensembl.org/info/website/archives/index.html\" ,  \"http://www.ensembl.org/info/website/archives/index.html\" )   html -   xml2 :: read_html (   GET (  url ) )   html -   htmlParse (  html )   archive_box -    getNodeSet (  html , path =  \"//div[@class='plain-box float-right archive-box']\" ) [[  1 ] ]   archive_box_string -   toString.XMLNode (  archive_box )   archives -     strsplit (  archive_box_string , split =  \" ) [[  1 ] ] [  -  1 ]   extracted -   str_extract_all ( string =  archives , pattern =  \"Ensembl [A-Za-z0-9 ]{2,6}|http[s]?://.*ensembl\\\\.org|[A-Z][a-z]{2} [0-9]{4}\" ) ## split the version number into a separate column   extracted -   lapply (  extracted , FUN =  function ( x )  {   version -    str_match (   x [  2 ] , pattern =  \".+ ([a-zA-Z0-9]+)$\" ) [  2 ]   return (   c (  x ,  version ) ) } )   current -   ifelse (   stringr :: str_detect (  archives ,  \"- this site\" ) ,  \"*\" ,  \"\" )   tab -   do.call (  \"rbind\" ,  extracted )   tab -   cbind (  tab ,  current )   dframe -   data.frame ( \"name\" =   as.character (   tab [ ,  2 ] ) , \"date\" =   as.character (   tab [ ,  3 ] ) , \"url\" =   stringr :: str_replace (   tolower (   as.character (   tab [ ,  1 ] ) ) ,  \"http://\" ,  \"https://\" ) , \"version\" =   as.character (   tab [ ,  4 ] ) , \"current_release\" =   as.character (   tab [ ,  5 ] ) , stringsAsFactors =  FALSE )   return (  dframe ) } ",
    "filename": "ensembl.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_12 biomart_release_3_13

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_12 biomart_release_3_13",
    "desc_release_old": "2.46.3",
    "desc_release_new": "2.48.3",
    "old_release_number": 27,
    "new_release_number": 28,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 4
}

##########
Functions Removed
##########



##########
Functions Added
##########

listFilterOptions
searchFilterOptions


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and does not do anything.' ,  '\\nSee ?useEnsembl for details on using mirror sites.' ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , httr_config , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (   missing (  httr_config ) )  {   httr_config -   httr :: config ( ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , httr_config =  httr_config , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , ensemblRedirect = NULL , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and does not do anything.' ,  '\\nSee ?useEnsembl for details on using mirror sites.' ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "listMarts",
    "representation": "listMarts",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , path = \"/biomart/martservice\" , port , includeHosts = FALSE , archive = FALSE , httr_config , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (   missing (  httr_config ) )  {   httr_config -   httr :: config ( ) }   .listMarts ( mart =  mart , host =  host , path =  path , port =  port , includeHosts =  includeHosts , archive =  archive , verbose =  verbose , httr_config =  httr_config , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}

1.
{
  "old_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"https://www.ensembl.org\" , path = \"/biomart/martservice\" , port , archive = FALSE , ensemblRedirect = NULL , version , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }  if (  !   is.null (  ensemblRedirect ) )  {   warning (  'The argument \"ensemblRedirect\" has been deprecated and will be removed in the next biomaRt release.' ) }   mart -   .useMart (  biomart ,  dataset , host =  host , path =  path , port =  port , archive =  archive , version =  version , verbose =  verbose , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "useMart",
    "representation": "useMart",
    "parameters": "function ( biomart , dataset , host = \"https://www.ensembl.org\" , path = \"/biomart/martservice\" , port , archive = FALSE , version , verbose = FALSE )",
    "body": "{  if (   missing (  port ) )  {   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 ) }   mart -   .useMart (  biomart ,  dataset , host =  host , path =  path , port =  port , archive =  archive , version =  version , verbose =  verbose , httr_config =   list (   httr :: config ( ) ) , ensemblRedirect =  TRUE ) } ",
    "filename": "biomaRt.txt"
  }
}

2.
{
  "old_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , upstream , downstream , mart , verbose = FALSE )",
    "body": "{   martCheck (  mart ,   c (  \"ensembl\" ,  \"ENSEMBL_MART_ENSEMBL\" ) )  if (    missing (  seqType ) ||  !   seqType %in%   c (  \"cdna\" ,  \"peptide\" ,  \"3utr\" ,  \"5utr\" ,  \"gene_exon\" ,  \"transcript_exon\" ,  \"transcript_exon_intron\" ,  \"gene_exon_intron\" ,  \"coding\" ,  \"coding_transcript_flank\" ,  \"coding_gene_flank\" ,  \"transcript_flank\" ,  \"gene_flank\" ) )  {   stop (  \"Please specify the type of sequence that needs to be retrieved when using biomaRt in web service mode.  Choose either gene_exon, transcript_exon,transcript_exon_intron, gene_exon_intron, cdna, coding,coding_transcript_flank,coding_gene_flank,transcript_flank,gene_flank,peptide, 3utr or 5utr\" ) }  if (   missing (  type ) )   stop (  \"Please specify the type argument.  If you use chromosomal coordinates to retrieve sequences, then the type argument will specify the type of gene indentifiers that you will retrieve with the sequences. \" ,  \"If you use a vector of identifiers to retrieve the sequences, the type argument specifies the type of identifiers you are using.\" )  if (     missing (  id ) undefined   missing (  chromosome ) undefined  !   missing (  type ) )   stop (  \"No vector of identifiers given. Please use the id argument to give a vector of identifiers for which you want to retrieve the sequences.\" )  if (   !   missing (  chromosome ) undefined  !   missing (  id ) )   stop (  \"The getSequence function retrieves sequences given a vector of identifiers specified with the id argument of a type specified by the type argument.  Or alternatively getSequence retrieves sequences given a chromosome, a start and a stop position on the chromosome.  As you specified both a vector of identifiers and chromsomal coordinates. Your query won't be processed.\" )  if (  !   missing (  chromosome ) )  {  if (   !   missing (  start ) undefined   missing (  end ) )   stop (  \"You specified a chromosomal start position but no end position.  Please also specify a chromosomal end position.\" )  if (   !   missing (  end ) undefined   missing (  start ) )   stop (  \"You specified a chromosomal end position but no start position.  Please also specify a chromosomal start position.\" )  if (  !   missing (  start ) )  {   start =   as.integer (  start )   end =   as.integer (  end ) }  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ) , values =   list (  chromosome ,  start ,  end ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"upstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  \"chromosome_name\" ,  \"start\" ,  \"end\" ,  \"downstream_flank\" ) , values =   list (  chromosome ,  start ,  end ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }  if (  !   missing (  id ) )  {  if (   missing (  type ) )  {   stop (  \"Type argument is missing. \" ,  \"This will be used to retrieve an identifier along with the sequence so one knows which gene it is from. \" ,  \"Use the listFilters() function to select a valid type argument.\" ) }  if (  !   type %in%   listFilters (  mart , what =  \"name\" ) )  {   stop (  \"Invalid type argument.  Use the listFilters() function to select a valid type argument.\" ) }   valuesString =   paste (  id ,  \"\" , collapse =  \",\" , sep =  \"\" )  if (    missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =  type , values =  id , mart =  mart , verbose =  verbose ) } else  {  if (   !   missing (  upstream ) undefined   missing (  downstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"upstream_flank\" ) , values =   list (  id ,  upstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined   missing (  upstream ) )  {   sequence =   getBM (   c (  seqType ,  type ) , filters =   c (  type ,  \"downstream_flank\" ) , values =   list (  id ,  downstream ) , mart =  mart , checkFilters =  FALSE , verbose =  verbose ) }  if (   !   missing (  downstream ) undefined  !   missing (  upstream ) )  {   stop (  \"Currently getSequence only allows the user to specify either an upstream of a downstream argument but not both.\" ) } } }   return (  sequence ) } ",
    "filename": "biomaRt.txt"
  },
  "new_function": {
    "name": "getSequence",
    "representation": "getSequence",
    "parameters": "function ( chromosome , start , end , id , type , seqType , upstream , downstream , mart , useCache = TRUE , verbose = FALSE )",
    "body": "{   martCheck (  mart ,   c (  \"ensembl\" ,  \"ENSEMBL_MART_ENSEMBL\" ) )   .checkSequenceArgs (  seqType ,  type ,  chromosome ,  id )  if (  !   missing (  chromosome ) )  {   sequence -   .getSequenceFromCoords (  chromosome ,  start ,  end ,  type ,  seqType ,  upstream ,  downstream ,  mart , useCache =  useCache , verbose =  verbose ) }  if (  !   missing (  id ) )  {   sequence -   .getSequenceFromId (  id ,  type ,  seqType ,  upstream ,  downstream ,  mart , useCache =  useCache , verbose =  verbose ) }   return (  sequence ) } ",
    "filename": "ensembl_wrappers.txt"
  }
}

3.
{
  "old_function": {
    "name": "listEnsembl",
    "representation": "listEnsembl",
    "parameters": "function ( mart = NULL , host = \"www.ensembl.org\" , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{  if (   !   is.null (  mirror ) undefined  (   !   is.null (  version ) |  !   is.null (  GRCh ) ) )  {   warning (  \"version or GRCh arguments can not be used together with the mirror argument.\\n\" ,  \"Will ignore the mirror argument and connect to default ensembl host\" )   mirror =  NULL }  if (  !   is.null (  version ) )  {   host -   paste0 (  \"e\" ,  version ,  \".ensembl.org\" ) }  if (  !   is.null (  GRCh ) )  {  if (   GRCh ==  37 )  {   host =   paste (  \"https://grch\" ,  GRCh ,  \".ensembl.org\" , sep =  \"\" ) } else  {   print (  \"Only 37 can be specified for GRCh version\" ) } }   ensemblRedirect -  TRUE  if (  !   is.null (  mirror ) )  {  if (  !  (   mirror %in%   c (  \"www\" ,  \"uswest\" ,  \"useast\" ,  \"asia\" ) ) )  {   warning (  \"Invalid mirror. Select a mirror from [www, uswest, useast, asia].\\n\" ,  \"Default when no mirror is specified is to be redirected to \" ,  \"www.ensembl.org\" ) } else  {   host -   paste0 (  mirror ,  \".ensembl.org\" )   ensemblRedirect -  FALSE } }   marts -   .listMarts ( mart =  mart , host =  host , verbose =  verbose , ensemblRedirect =  ensemblRedirect )   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_ENSEMBL\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"genes\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_SNP\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"snps\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_FUNCGEN\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"regulation\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_VEGA\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"vega\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_MOUSE\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"mouse_strains\" }   return (  marts ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "listEnsembl",
    "representation": "listEnsembl",
    "parameters": "function ( mart = NULL , version = NULL , GRCh = NULL , mirror = NULL , verbose = FALSE )",
    "body": "{   host -   .constructEnsemblURL ( mirror =  mirror , version =  version , GRCh =  GRCh )   port -   ifelse (   grepl (  \"https\" ,  host ) , yes =  443 , no =  80 )   ensemblRedirect -   is.null (  mirror )   httr_config -   .getEnsemblSSL ( )   marts -   .listMarts ( mart =  mart , host =  host , verbose =  verbose , httr_config =  httr_config , port =  port , ensemblRedirect =  ensemblRedirect )   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_ENSEMBL\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"genes\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_SNP\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"snps\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_FUNCGEN\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"regulation\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_VEGA\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"vega\" }   sel =   which (    marts $ biomart ==  \"ENSEMBL_MART_MOUSE\" )  if (    length (  sel ) undefined  0 )  {     marts $ biomart [  sel ] =  \"mouse_strains\" }   return (  marts ) } ",
    "filename": "ensembl.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_13 biomart_release_3_14

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_13 biomart_release_3_14",
    "desc_release_old": "2.48.3",
    "desc_release_new": "2.50.3",
    "old_release_number": 28,
    "new_release_number": 29,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https = FALSE )",
    "body": "{   .listEnsemblArchives ( https =  https , httr_config =   list ( ) ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https )",
    "body": "{  if (  !   missing (  https ) )  {   warning (  \"Ensembl will soon enforce the use of https.\\n\" ,  \"As such the 'https' argument will be deprecated in the next release.\" ) }   https -  TRUE   .listEnsemblArchives ( https =  https , httr_config =   list ( ) ) } ",
    "filename": "ensembl.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https = FALSE )",
    "body": "{   .listEnsemblArchives ( https =  https , httr_config =   list ( ) ) } ",
    "filename": "ensembl.txt"
  },
  "new_function": {
    "name": "listEnsemblArchives",
    "representation": "listEnsemblArchives",
    "parameters": "function ( https )",
    "body": "{  if (  !   missing (  https ) )  {   warning (  \"Ensembl will soon enforce the use of https.\\n\" ,  \"As such the 'https' argument will be deprecated in the next release.\" ) }   https -  TRUE   .listEnsemblArchives ( https =  https , httr_config =   list ( ) ) } ",
    "filename": "ensembl.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  biomart_release_3_14 biomart_master

{
    "package": "biomaRt",
    "release_versions": "biomart_release_3_14 biomart_master",
    "desc_release_old": "2.50.3",
    "desc_release_new": "2.51.3",
    "old_release_number": 29,
    "new_release_number": 30,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

