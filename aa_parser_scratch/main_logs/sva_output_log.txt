
###############################
###############################
###############################
###############################
Checking Versions:  sva_release_2_9 sva_release_2_11

{
    "package": "sva",
    "release_versions": "sva_release_2_9 sva_release_2_11",
    "desc_release_old": "3.0.3",
    "desc_release_new": "3.4.0",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_2_11 sva_release_2_12

{
    "package": "sva",
    "release_versions": "sva_release_2_11 sva_release_2_12",
    "desc_release_old": "3.4.0",
    "desc_release_new": "3.6.0",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_2_12 sva_release_2_13

{
    "package": "sva",
    "release_versions": "sva_release_2_12 sva_release_2_13",
    "desc_release_old": "3.6.0",
    "desc_release_new": "3.8.0",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_2_13 sva_release_2_14

{
    "package": "sva",
    "release_versions": "sva_release_2_13 sva_release_2_14",
    "desc_release_old": "3.8.0",
    "desc_release_new": "3.10.0",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_2_14 sva_release_3_1

{
    "package": "sva",
    "release_versions": "sva_release_2_14 sva_release_3_1",
    "desc_release_old": "3.10.0",
    "desc_release_new": "3.14.0",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 6,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 3,
    "total_count": 3
}

##########
Functions Removed
##########



##########
Functions Added
##########

empirical.controls
fstats
psva
ssva
sva.check
svaseq


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "ComBat",
    "representation": "ComBat",
    "parameters": "function ( dat , batch , mod , numCovs = NULL , par.prior = TRUE , prior.plots = FALSE )",
    "body": "{   mod =   cbind (  mod ,  batch ) # check for intercept, and drop if present   check =   apply (  mod ,  2 ,  function ( x )   all (   x ==  1 ) )   mod =   as.matrix (   mod [ ,  !  check ] )     colnames (  mod ) [   ncol (  mod ) ] =  \"Batch\"  if (     sum (  check ) undefined  0 undefined  !   is.null (  numCovs ) )   numCovs =   numCovs -  1   design -   design.mat (  mod , numCov =  numCovs )   batches -   list.batch (  mod )   n.batch -   length (  batches )   n.batches -   sapply (  batches ,  length )   n.array -   sum (  n.batches ) ## Check for missing values   NAs =   any (   is.na (  dat ) )  if (  NAs )  {   cat (   c (  'Found' ,   sum (   is.na (  dat ) ) ,  'Missing Data Values\\n' ) , sep =  ' ' ) } #print(dat[1:2,]) ##Standardize Data across genes   cat (  'Standardizing Data across genes\\n' )  if (  !  NAs )  {   B.hat -     solve (    t (  design ) %*%  design ) %*%   t (  design ) %*%   t (   as.matrix (  dat ) ) } else  {   B.hat =   apply (  dat ,  1 ,  Beta.NA ,  design ) } #Standarization Model   grand.mean -    t (   n.batches /  n.array ) %*%   B.hat [   1 :  n.batch , ]  if (  !  NAs )  {   var.pooled -   (   (   dat -   t (   design %*%  B.hat ) ) ^  2 ) %*%   rep (   1 /  n.array ,  n.array ) } else  {   var.pooled -   apply (   dat -   t (   design %*%  B.hat ) ,  1 ,  var , na.rm =  T ) }   stand.mean -    t (  grand.mean ) %*%   t (   rep (  1 ,  n.array ) )  if (  !   is.null (  design ) )  {   tmp -  design ;    tmp [ ,   c (   1 :  n.batch ) ] -  0 ;   stand.mean -   stand.mean +   t (   tmp %*%  B.hat ) }   s.data -   (   dat -  stand.mean ) /  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ##Get regression batch effect parameters   cat (  \"Fitting L/S model and finding priors\\n\" )   batch.design -   design [ ,   1 :  n.batch ]  if (  !  NAs )  {   gamma.hat -     solve (    t (  batch.design ) %*%  batch.design ) %*%   t (  batch.design ) %*%   t (   as.matrix (  s.data ) ) } else  {   gamma.hat =   apply (  s.data ,  1 ,  Beta.NA ,  batch.design ) }   delta.hat -  NULL  for  ( i in  batches )  {   delta.hat -   rbind (  delta.hat ,   apply (   s.data [ ,  i ] ,  1 ,  var , na.rm =  T ) ) } ##Find Priors   gamma.bar -   apply (  gamma.hat ,  1 ,  mean )   t2 -   apply (  gamma.hat ,  1 ,  var )   a.prior -   apply (  delta.hat ,  1 ,  aprior )   b.prior -   apply (  delta.hat ,  1 ,  bprior ) ##Plot empirical and parametric priors  if (   prior.plots undefined  par.prior )  {   par ( mfrow =   c (  2 ,  2 ) )   tmp -   density (   gamma.hat [  1 , ] )   plot (  tmp , type =  'l' , main =  \"Density Plot\" )   xx -   seq (   min (   tmp $ x ) ,   max (   tmp $ x ) , length =  100 )   lines (  xx ,   dnorm (  xx ,   gamma.bar [  1 ] ,   sqrt (   t2 [  1 ] ) ) , col =  2 )   qqnorm (   gamma.hat [  1 , ] )   qqline (   gamma.hat [  1 , ] , col =  2 )   tmp -   density (   delta.hat [  1 , ] )   invgam -   1 /   rgamma (   ncol (  delta.hat ) ,   a.prior [  1 ] ,   b.prior [  1 ] )   tmp1 -   density (  invgam )   plot (  tmp , typ =  'l' , main =  \"Density Plot\" , ylim =   c (  0 ,   max (   tmp $ y ,   tmp1 $ y ) ) )   lines (  tmp1 , col =  2 )   qqplot (   delta.hat [  1 , ] ,  invgam , xlab =  \"Sample Quantiles\" , ylab =  'Theoretical Quantiles' )   lines (   c (  0 ,   max (  invgam ) ) ,   c (  0 ,   max (  invgam ) ) , col =  2 )   title (  'Q-Q Plot' ) } ##Find EB batch adjustments   gamma.star -   delta.star -  NULL  if (  par.prior )  {   cat (  \"Finding parametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   it.sol (   s.data [ ,   batches [[  i ] ] ] ,   gamma.hat [  i , ] ,   delta.hat [  i , ] ,   gamma.bar [  i ] ,   t2 [  i ] ,   a.prior [  i ] ,   b.prior [  i ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } else  {   cat (  \"Finding nonparametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   int.eprior (   as.matrix (   s.data [ ,   batches [[  i ] ] ] ) ,   gamma.hat [  i , ] ,   delta.hat [  i , ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } ### Normalize the Data ###   cat (  \"Adjusting the Data\\n\" )   bayesdata -  s.data   j -  1  for  ( i in  batches )  {    bayesdata [ ,  i ] -   (    bayesdata [ ,  i ] -   t (    batch.design [  i , ] %*%  gamma.star ) ) /  (    sqrt (   delta.star [  j , ] ) %*%   t (   rep (  1 ,   n.batches [  j ] ) ) )   j -   j +  1 }   bayesdata -   (   bayesdata *  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ) +  stand.mean   return (  bayesdata ) } ",
    "filename": "sva.txt"
  },
  "new_function": {
    "name": "ComBat",
    "representation": "ComBat",
    "parameters": "function ( dat , batch , mod = NULL , par.prior = TRUE , prior.plots = FALSE )",
    "body": "{ # make batch a factor and make a set of indicators for batch  if (    length (   dim (  batch ) ) undefined  1 )  {   stop (  \"This version of ComBat only allows one batch variable\" ) } ## to be updated soon!   batch -   as.factor (  batch )   batchmod -   model.matrix (  ~   -  1 +  batch )   cat (  \"Found\" ,   nlevels (  batch ) ,  'batches\\n' ) # A few other characteristics on the batches   n.batch -   nlevels (  batch )   batches -   list ( )  for  ( i in   1 :  n.batch )  {    batches [[  i ] ] -   which (   batch ==    levels (  batch ) [  i ] ) } # list of samples in each batch   n.batches -   sapply (  batches ,  length )   n.array -   sum (  n.batches ) #combine batch variable and covariates   design -   cbind (  batchmod ,  mod ) # check for intercept in covariates, and drop if present   check -   apply (  design ,  2 ,  function ( x )   all (   x ==  1 ) )   design -   as.matrix (   design [ ,  !  check ] ) # Number of covariates or covariate levels   cat (  \"Adjusting for\" ,    ncol (  design ) -   ncol (  batchmod ) ,  'covariate(s) or covariate level(s)\\n' ) # Check if the design is confounded  if (     qr (  design ) $ rank undefined   ncol (  design ) )  { #if(ncol(design)  if (    ncol (  design ) ==  (   n.batch +  1 ) )  {   stop (  \"The covariate is confounded with batch! Remove the covariate and rerun ComBat\" ) }  if (    ncol (  design ) undefined  (   n.batch +  1 ) )  {  if (  (     qr (   design [ ,  -   c (   1 :  n.batch ) ] ) $ rank undefined   ncol (   design [ ,  -   c (   1 :  n.batch ) ] ) ) )  {   stop (  'The covariates are confounded! Please remove one or more of the covariates so the design is not confounded' ) } else  {   stop (  \"At least one covariate is confounded with batch! Please remove confounded covariates and rerun ComBat\" ) } } } ## Check for missing values   NAs =   any (   is.na (  dat ) )  if (  NAs )  {   cat (   c (  'Found' ,   sum (   is.na (  dat ) ) ,  'Missing Data Values\\n' ) , sep =  ' ' ) } #print(dat[1:2,]) ##Standardize Data across genes   cat (  'Standardizing Data across genes\\n' )  if (  !  NAs )  {   B.hat -     solve (    t (  design ) %*%  design ) %*%   t (  design ) %*%   t (   as.matrix (  dat ) ) } else  {   B.hat =   apply (  dat ,  1 ,  Beta.NA ,  design ) } #Standarization Model   grand.mean -    t (   n.batches /  n.array ) %*%   B.hat [   1 :  n.batch , ]  if (  !  NAs )  {   var.pooled -   (   (   dat -   t (   design %*%  B.hat ) ) ^  2 ) %*%   rep (   1 /  n.array ,  n.array ) } else  {   var.pooled -   apply (   dat -   t (   design %*%  B.hat ) ,  1 ,  var , na.rm =  T ) }   stand.mean -    t (  grand.mean ) %*%   t (   rep (  1 ,  n.array ) )  if (  !   is.null (  design ) )  {   tmp -  design ;    tmp [ ,   c (   1 :  n.batch ) ] -  0 ;   stand.mean -   stand.mean +   t (   tmp %*%  B.hat ) }   s.data -   (   dat -  stand.mean ) /  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ##Get regression batch effect parameters   cat (  \"Fitting L/S model and finding priors\\n\" )   batch.design -   design [ ,   1 :  n.batch ]  if (  !  NAs )  {   gamma.hat -     solve (    t (  batch.design ) %*%  batch.design ) %*%   t (  batch.design ) %*%   t (   as.matrix (  s.data ) ) } else  {   gamma.hat =   apply (  s.data ,  1 ,  Beta.NA ,  batch.design ) }   delta.hat -  NULL  for  ( i in  batches )  {   delta.hat -   rbind (  delta.hat ,   apply (   s.data [ ,  i ] ,  1 ,  var , na.rm =  T ) ) } ##Find Priors   gamma.bar -   apply (  gamma.hat ,  1 ,  mean )   t2 -   apply (  gamma.hat ,  1 ,  var )   a.prior -   apply (  delta.hat ,  1 ,  aprior )   b.prior -   apply (  delta.hat ,  1 ,  bprior ) ##Plot empirical and parametric priors  if (   prior.plots undefined  par.prior )  {   par ( mfrow =   c (  2 ,  2 ) )   tmp -   density (   gamma.hat [  1 , ] )   plot (  tmp , type =  'l' , main =  \"Density Plot\" )   xx -   seq (   min (   tmp $ x ) ,   max (   tmp $ x ) , length =  100 )   lines (  xx ,   dnorm (  xx ,   gamma.bar [  1 ] ,   sqrt (   t2 [  1 ] ) ) , col =  2 )   qqnorm (   gamma.hat [  1 , ] )   qqline (   gamma.hat [  1 , ] , col =  2 )   tmp -   density (   delta.hat [  1 , ] )   invgam -   1 /   rgamma (   ncol (  delta.hat ) ,   a.prior [  1 ] ,   b.prior [  1 ] )   tmp1 -   density (  invgam )   plot (  tmp , typ =  'l' , main =  \"Density Plot\" , ylim =   c (  0 ,   max (   tmp $ y ,   tmp1 $ y ) ) )   lines (  tmp1 , col =  2 )   qqplot (   delta.hat [  1 , ] ,  invgam , xlab =  \"Sample Quantiles\" , ylab =  'Theoretical Quantiles' )   lines (   c (  0 ,   max (  invgam ) ) ,   c (  0 ,   max (  invgam ) ) , col =  2 )   title (  'Q-Q Plot' ) } ##Find EB batch adjustments   gamma.star -   delta.star -  NULL  if (  par.prior )  {   cat (  \"Finding parametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   it.sol (   s.data [ ,   batches [[  i ] ] ] ,   gamma.hat [  i , ] ,   delta.hat [  i , ] ,   gamma.bar [  i ] ,   t2 [  i ] ,   a.prior [  i ] ,   b.prior [  i ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } else  {   cat (  \"Finding nonparametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   int.eprior (   as.matrix (   s.data [ ,   batches [[  i ] ] ] ) ,   gamma.hat [  i , ] ,   delta.hat [  i , ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } ### Normalize the Data ###   cat (  \"Adjusting the Data\\n\" )   bayesdata -  s.data   j -  1  for  ( i in  batches )  {    bayesdata [ ,  i ] -   (    bayesdata [ ,  i ] -   t (    batch.design [  i , ] %*%  gamma.star ) ) /  (    sqrt (   delta.star [  j , ] ) %*%   t (   rep (  1 ,   n.batches [  j ] ) ) )   j -   j +  1 }   bayesdata -   (   bayesdata *  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ) +  stand.mean   return (  bayesdata ) } ",
    "filename": "ComBat.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "num.sv",
    "representation": "num.sv",
    "parameters": "function ( dat , mod , method = c ( \"be\" , \"leek\" ) , vfilter = NULL , B = 20 , sv.sig = 0.10 , seed = NULL )",
    "body": "{ #Input #============================================================================= #dat: A m genes by n arrays matrix of expression data #mod: A model matrix for the terms included in the analysis #method: Leek is the method proposed in Leek 2011 Biometrics. be is the method #         proposed in Buja and 1992 #B: The number of null iterations to perform #sv.sig: The significance cutoff for the surrogate variables #Output #============================================================================= #n.sv: Number of significant surrogate variables. #id: An indicator of the significant surrogate variables #B: number of null iterations #sv.sig: significance level for surrogate variables  if (  !   is.null (  vfilter ) )  {  if (    vfilter undefined  100 |   vfilter undefined    dim (  dat ) [  1 ] )  {   stop (   paste (  \"The number of genes used in the analysis must be between 100 and\" ,    dim (  dat ) [  1 ] ,  \"\\n\" ) ) }   tmpv =   rowVars (  dat )   ind =   which (    rank (  -  tmpv ) undefined  vfilter )   dat =   dat [  ind , ] }   method -   match.arg (  method )  if (   method ==  \"be\" )  {  if (  !   is.null (  seed ) )  {   set.seed (  seed ) }   warn -  NULL   n -   ncol (  dat )   m -   nrow (  dat )   H -    mod %*%   solve (    t (  mod ) %*%  mod ) %*%   t (  mod )   res -   dat -   t (   H %*%   t (  dat ) )   uu -   fast.svd (  res , tol =  0 )   ndf -   n -   ceiling (   sum (   diag (  H ) ) )   dstat -      uu $ d [   1 :  ndf ] ^  2 /   sum (     uu $ d [   1 :  ndf ] ^  2 )   dstat0 -   matrix (  0 , nrow =  B , ncol =  ndf )  for  ( i in   1 :  B )  {   res0 -   t (   apply (  res ,  1 ,  sample , replace =  FALSE ) )   res0 -   res0 -   t (   H %*%   t (  res0 ) )   uu0 -   fast.svd (  res0 , tol =  0 )    dstat0 [  i , ] -      uu0 $ d [   1 :  ndf ] ^  2 /   sum (     uu0 $ d [   1 :  ndf ] ^  2 ) }   psv -   rep (  1 ,  n )  for  ( i in   1 :  ndf )  {    psv [  i ] -   mean (    dstat0 [ ,  i ] =   dstat [  i ] ) }  for  ( i in   2 :  ndf )  {    psv [  i ] -   max (   psv [  (   i -  1 ) ] ,   psv [  i ] ) }   nsv -   sum (   psv =  sv.sig )   return (   as.numeric (   list ( n.sv =  nsv ) ) ) } else  {   dat -   as.matrix (  dat )   dims -   dim (  dat )   a -   seq (  0 ,  2 , length =  100 )   n -   floor (    dims [  1 ] /  10 )   rhat -   matrix (  0 , nrow =  100 , ncol =  10 )   P -  (    diag (   dims [  2 ] ) -    mod %*%   solve (    t (  mod ) %*%  mod ) %*%   t (  mod ) )  for  ( j in   1 :  10 )  {   dats -   dat [   1 :  (   j *  n ) , ]   ee -   eigen (    t (  dats ) %*%  dats )   sigbar -     ee $ values [   dims [  2 ] ] /  (   j *  n )   R -   dats %*%  P   wm -    (   1 /  (   j *  n ) ) *    t (  R ) %*%  R -   P *  sigbar   ee -   eigen (  wm )   v -   c (   rep (  T ,  100 ) ,   rep (  F ,   dims [  2 ] ) )   v -   v [   order (   c (    a *   (   j *  n ) ^  (   -  1 /  3 ) *   dims [  2 ] ,   ee $ values ) , decreasing =  TRUE ) ]   u -   1 :   length (  v )   w -   1 :  100    rhat [ ,  j ] -   rev (  (    u [   v ==  TRUE ] -  w ) ) }   ss -   rowVars (  rhat )   bumpstart -   which.max (   ss undefined  (   2 *   ss [  1 ] ) )   start -   which.max (    c (   rep (  1e5 ,  bumpstart ) ,   ss [   (   bumpstart +  1 ) :  100 ] ) undefined   0.5 *   ss [  1 ] )   finish -   which.max (    ss *   c (   rep (  0 ,  start ) ,   rep (  1 ,   100 -  start ) ) undefined   ss [  1 ] )  if (   finish ==  1 )  {   finish -  100 }   n.sv -   modefunc (   rhat [   start :  finish ,  10 ] )   return (  n.sv )   print (  method ) } } ",
    "filename": "sva.txt"
  },
  "new_function": {
    "name": "num.sv",
    "representation": "num.sv",
    "parameters": "function ( dat , mod , method = c ( \"be\" , \"leek\" ) , vfilter = NULL , B = 20 , seed = NULL )",
    "body": "{  if (  !   is.null (  vfilter ) )  {  if (    vfilter undefined  100 |   vfilter undefined    dim (  dat ) [  1 ] )  {   stop (   paste (  \"The number of genes used in the analysis must be between 100 and\" ,    dim (  dat ) [  1 ] ,  \"\\n\" ) ) }   tmpv =   rowVars (  dat )   ind =   which (    rank (  -  tmpv ) undefined  vfilter )   dat =   dat [  ind , ] }   method -   match.arg (  method )  if (   method ==  \"be\" )  {  if (  !   is.null (  seed ) )  {   set.seed (  seed ) }   warn -  NULL   n -   ncol (  dat )   m -   nrow (  dat )   H -    mod %*%   solve (    t (  mod ) %*%  mod ) %*%   t (  mod )   res -   dat -   t (   H %*%   t (  dat ) )   uu -   svd (  res )   ndf -    min (  m ,  n ) -   ceiling (   sum (   diag (  H ) ) )   dstat -      uu $ d [   1 :  ndf ] ^  2 /   sum (     uu $ d [   1 :  ndf ] ^  2 )   dstat0 -   matrix (  0 , nrow =  B , ncol =  ndf )  for  ( i in   1 :  B )  {   res0 -   t (   apply (  res ,  1 ,  sample , replace =  FALSE ) )   res0 -   res0 -   t (   H %*%   t (  res0 ) )   uu0 -   svd (  res0 )    dstat0 [  i , ] -      uu0 $ d [   1 :  ndf ] ^  2 /   sum (     uu0 $ d [   1 :  ndf ] ^  2 ) }   psv -   rep (  1 ,  n )  for  ( i in   1 :  ndf )  {    psv [  i ] -   mean (    dstat0 [ ,  i ] =   dstat [  i ] ) }  for  ( i in   2 :  ndf )  {    psv [  i ] -   max (   psv [  (   i -  1 ) ] ,   psv [  i ] ) }   nsv -   sum (   psv =  0.10 )   return (   as.numeric (   list ( n.sv =  nsv ) ) ) } else  {   dat -   as.matrix (  dat )   dims -   dim (  dat )   a -   seq (  0 ,  2 , length =  100 )   n -   floor (    dims [  1 ] /  10 )   rhat -   matrix (  0 , nrow =  100 , ncol =  10 )   P -  (    diag (   dims [  2 ] ) -    mod %*%   solve (    t (  mod ) %*%  mod ) %*%   t (  mod ) )  for  ( j in   1 :  10 )  {   dats -   dat [   1 :  (   j *  n ) , ]   ee -   eigen (    t (  dats ) %*%  dats )   sigbar -     ee $ values [   dims [  2 ] ] /  (   j *  n )   R -   dats %*%  P   wm -    (   1 /  (   j *  n ) ) *    t (  R ) %*%  R -   P *  sigbar   ee -   eigen (  wm )   v -   c (   rep (  T ,  100 ) ,   rep (  F ,   dims [  2 ] ) )   v -   v [   order (   c (    a *   (   j *  n ) ^  (   -  1 /  3 ) *   dims [  2 ] ,   ee $ values ) , decreasing =  TRUE ) ]   u -   1 :   length (  v )   w -   1 :  100    rhat [ ,  j ] -   rev (  (    u [   v ==  TRUE ] -  w ) ) }   ss -   rowVars (  rhat )   bumpstart -   which.max (   ss undefined  (   2 *   ss [  1 ] ) )   start -   which.max (    c (   rep (  1e5 ,  bumpstart ) ,   ss [   (   bumpstart +  1 ) :  100 ] ) undefined   0.5 *   ss [  1 ] )   finish -   which.max (    ss *   c (   rep (  0 ,  start ) ,   rep (  1 ,   100 -  start ) ) undefined   ss [  1 ] )  if (   finish ==  1 )  {   finish -  100 }   n.sv -   modefunc (   rhat [   start :  finish ,  10 ] )   return (  n.sv )   print (  method ) } } ",
    "filename": "num.sv.txt"
  }
}

1.
{
  "old_function": {
    "name": "sva",
    "representation": "sva",
    "parameters": "function ( dat , mod , mod0 = NULL , n.sv = NULL , method = c ( \"irw\" , \"two-step\" ) , vfilter = NULL , B = 5 , numSVmethod = \"be\" )",
    "body": "{ #Input #============================================================================= #dat: A m genes by n arrays matrix of expression data #mod: A model matrix for the terms included in the analysis #mod0: A null model matrix #n.sv: The number of surrogate variables to build #vfilter: The number of most variable genes/probes to use in the analysis (must be #B: The number of iterations to perform #numSVmethod: The method for determining the number of SVs (see num.sv for more details) #Output #============================================================================= #sv: A n by n.sv matrix where each column is a distinct surrogate variable #pprob.gam: A vector of the posterior probabilities each gene is affected by heterogeneity #pprob.b: A vector of the posterior probabilities each gene is affected by mod #n.sv: The number of significant surrogate variables  if (   is.null (  n.sv ) )  {   n.sv =   num.sv (  dat ,  mod , method =  numSVmethod , vfilter =  vfilter ) }  if (  !   is.null (  vfilter ) )  {  if (    vfilter undefined  100 |   vfilter undefined    dim (  dat ) [  1 ] )  {   stop (   paste (  \"The number of genes used in the analysis must be between 100 and\" ,    dim (  dat ) [  1 ] ,  \"\\n\" ) ) }   tmpv =   rowVars (  dat )   ind =   which (    rank (  -  tmpv ) undefined  vfilter )   dat =   dat [  ind , ] }  if (   n.sv undefined  0 )  {   cat (   paste (  \"Number of significant surrogate variables is: \" ,  n.sv ,  \"\\n\" ) )   method -   match.arg (  method )  if (   method ==  \"two-step\" )  {   return (   twostepsva.build ( dat =  dat , mod =  mod , n.sv =  n.sv ) ) }  if (   method ==  \"irw\" )  {   return (   irwsva.build ( dat =  dat , mod =  mod , mod0 =  mod0 , n.sv =  n.sv , B =  B ) ) } } else  {   print (  \"No significant surrogate variables\" ) ;   return (   list ( sv =  0 , pprob.gam =  0 , pprob.b =  0 , n.sv =  0 ) ) } } ",
    "filename": "sva.txt"
  },
  "new_function": {
    "name": "sva",
    "representation": "sva",
    "parameters": "function ( dat , mod , mod0 = NULL , n.sv = NULL , controls = NULL , method = c ( \"irw\" , \"two-step\" , \"supervised\" ) , vfilter = NULL , B = 5 , numSVmethod = \"be\" )",
    "body": "{   method -   match.arg (  method )  if (   !   is.null (  controls ) undefined  !   is.null (  vfilter ) )  {   stop (  \"sva error: if controls is provided vfilter must be NULL.\\n\" ) }  if (   (   method ==  \"supervised\" ) undefined   is.null (  controls ) )  {   stop (  \"sva error: for a supervised analysis you must provide a vector of controls.\\n\" ) }  if (   !   is.null (  controls ) undefined  (   method !=  \"supervised\" ) )  {   method =  \"supervised\" ;   cat (  \"sva warning: controls provided so supervised sva is being performed.\\n\" ) }  if (  !   is.null (  vfilter ) )  {  if (    vfilter undefined  100 |   vfilter undefined    dim (  dat ) [  1 ] )  {   stop (   paste (  \"sva error: the number of genes used in the analysis must be between 100 and\" ,    dim (  dat ) [  1 ] ,  \"\\n\" ) ) }   tmpv =   rowVars (  dat )   ind =   which (    rank (  -  tmpv ) =  vfilter )   dat =   dat [  ind , ] }  if (   is.null (  n.sv ) )  {   n.sv =   num.sv (  dat ,  mod , method =  numSVmethod , vfilter =  vfilter ) }  if (   n.sv undefined  0 )  {   cat (   paste (  \"Number of significant surrogate variables is: \" ,  n.sv ,  \"\\n\" ) )  if (   method ==  \"two-step\" )  {   return (   twostepsva.build ( dat =  dat , mod =  mod , n.sv =  n.sv ) ) }  if (   method ==  \"irw\" )  {   return (   irwsva.build ( dat =  dat , mod =  mod , mod0 =  mod0 , n.sv =  n.sv , B =  B ) ) }  if (   method ==  \"supervised\" )  {   return (   ssva (  dat ,  controls ,  n.sv ) ) } } else  {   cat (  \"No significant surrogate variables\\n\" ) ;   return (   list ( sv =  0 , pprob.gam =  0 , pprob.b =  0 , n.sv =  0 ) ) } } ",
    "filename": "sva.txt"
  }
}

2.
{
  "old_function": {
    "name": "ComBat",
    "representation": "ComBat",
    "parameters": "function ( dat , batch , mod , numCovs = NULL , par.prior = TRUE , prior.plots = FALSE )",
    "body": "{   mod =   cbind (  mod ,  batch ) # check for intercept, and drop if present   check =   apply (  mod ,  2 ,  function ( x )   all (   x ==  1 ) )   mod =   as.matrix (   mod [ ,  !  check ] )     colnames (  mod ) [   ncol (  mod ) ] =  \"Batch\"  if (     sum (  check ) undefined  0 undefined  !   is.null (  numCovs ) )   numCovs =   numCovs -  1   design -   design.mat (  mod , numCov =  numCovs )   batches -   list.batch (  mod )   n.batch -   length (  batches )   n.batches -   sapply (  batches ,  length )   n.array -   sum (  n.batches ) ## Check for missing values   NAs =   any (   is.na (  dat ) )  if (  NAs )  {   cat (   c (  'Found' ,   sum (   is.na (  dat ) ) ,  'Missing Data Values\\n' ) , sep =  ' ' ) } #print(dat[1:2,]) ##Standardize Data across genes   cat (  'Standardizing Data across genes\\n' )  if (  !  NAs )  {   B.hat -     solve (    t (  design ) %*%  design ) %*%   t (  design ) %*%   t (   as.matrix (  dat ) ) } else  {   B.hat =   apply (  dat ,  1 ,  Beta.NA ,  design ) } #Standarization Model   grand.mean -    t (   n.batches /  n.array ) %*%   B.hat [   1 :  n.batch , ]  if (  !  NAs )  {   var.pooled -   (   (   dat -   t (   design %*%  B.hat ) ) ^  2 ) %*%   rep (   1 /  n.array ,  n.array ) } else  {   var.pooled -   apply (   dat -   t (   design %*%  B.hat ) ,  1 ,  var , na.rm =  T ) }   stand.mean -    t (  grand.mean ) %*%   t (   rep (  1 ,  n.array ) )  if (  !   is.null (  design ) )  {   tmp -  design ;    tmp [ ,   c (   1 :  n.batch ) ] -  0 ;   stand.mean -   stand.mean +   t (   tmp %*%  B.hat ) }   s.data -   (   dat -  stand.mean ) /  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ##Get regression batch effect parameters   cat (  \"Fitting L/S model and finding priors\\n\" )   batch.design -   design [ ,   1 :  n.batch ]  if (  !  NAs )  {   gamma.hat -     solve (    t (  batch.design ) %*%  batch.design ) %*%   t (  batch.design ) %*%   t (   as.matrix (  s.data ) ) } else  {   gamma.hat =   apply (  s.data ,  1 ,  Beta.NA ,  batch.design ) }   delta.hat -  NULL  for  ( i in  batches )  {   delta.hat -   rbind (  delta.hat ,   apply (   s.data [ ,  i ] ,  1 ,  var , na.rm =  T ) ) } ##Find Priors   gamma.bar -   apply (  gamma.hat ,  1 ,  mean )   t2 -   apply (  gamma.hat ,  1 ,  var )   a.prior -   apply (  delta.hat ,  1 ,  aprior )   b.prior -   apply (  delta.hat ,  1 ,  bprior ) ##Plot empirical and parametric priors  if (   prior.plots undefined  par.prior )  {   par ( mfrow =   c (  2 ,  2 ) )   tmp -   density (   gamma.hat [  1 , ] )   plot (  tmp , type =  'l' , main =  \"Density Plot\" )   xx -   seq (   min (   tmp $ x ) ,   max (   tmp $ x ) , length =  100 )   lines (  xx ,   dnorm (  xx ,   gamma.bar [  1 ] ,   sqrt (   t2 [  1 ] ) ) , col =  2 )   qqnorm (   gamma.hat [  1 , ] )   qqline (   gamma.hat [  1 , ] , col =  2 )   tmp -   density (   delta.hat [  1 , ] )   invgam -   1 /   rgamma (   ncol (  delta.hat ) ,   a.prior [  1 ] ,   b.prior [  1 ] )   tmp1 -   density (  invgam )   plot (  tmp , typ =  'l' , main =  \"Density Plot\" , ylim =   c (  0 ,   max (   tmp $ y ,   tmp1 $ y ) ) )   lines (  tmp1 , col =  2 )   qqplot (   delta.hat [  1 , ] ,  invgam , xlab =  \"Sample Quantiles\" , ylab =  'Theoretical Quantiles' )   lines (   c (  0 ,   max (  invgam ) ) ,   c (  0 ,   max (  invgam ) ) , col =  2 )   title (  'Q-Q Plot' ) } ##Find EB batch adjustments   gamma.star -   delta.star -  NULL  if (  par.prior )  {   cat (  \"Finding parametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   it.sol (   s.data [ ,   batches [[  i ] ] ] ,   gamma.hat [  i , ] ,   delta.hat [  i , ] ,   gamma.bar [  i ] ,   t2 [  i ] ,   a.prior [  i ] ,   b.prior [  i ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } else  {   cat (  \"Finding nonparametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   int.eprior (   as.matrix (   s.data [ ,   batches [[  i ] ] ] ) ,   gamma.hat [  i , ] ,   delta.hat [  i , ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } ### Normalize the Data ###   cat (  \"Adjusting the Data\\n\" )   bayesdata -  s.data   j -  1  for  ( i in  batches )  {    bayesdata [ ,  i ] -   (    bayesdata [ ,  i ] -   t (    batch.design [  i , ] %*%  gamma.star ) ) /  (    sqrt (   delta.star [  j , ] ) %*%   t (   rep (  1 ,   n.batches [  j ] ) ) )   j -   j +  1 }   bayesdata -   (   bayesdata *  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ) +  stand.mean   return (  bayesdata ) } ",
    "filename": "sva.txt"
  },
  "new_function": {
    "name": "ComBat",
    "representation": "ComBat",
    "parameters": "function ( dat , batch , mod = NULL , par.prior = TRUE , prior.plots = FALSE )",
    "body": "{ # make batch a factor and make a set of indicators for batch  if (    length (   dim (  batch ) ) undefined  1 )  {   stop (  \"This version of ComBat only allows one batch variable\" ) } ## to be updated soon!   batch -   as.factor (  batch )   batchmod -   model.matrix (  ~   -  1 +  batch )   cat (  \"Found\" ,   nlevels (  batch ) ,  'batches\\n' ) # A few other characteristics on the batches   n.batch -   nlevels (  batch )   batches -   list ( )  for  ( i in   1 :  n.batch )  {    batches [[  i ] ] -   which (   batch ==    levels (  batch ) [  i ] ) } # list of samples in each batch   n.batches -   sapply (  batches ,  length )   n.array -   sum (  n.batches ) #combine batch variable and covariates   design -   cbind (  batchmod ,  mod ) # check for intercept in covariates, and drop if present   check -   apply (  design ,  2 ,  function ( x )   all (   x ==  1 ) )   design -   as.matrix (   design [ ,  !  check ] ) # Number of covariates or covariate levels   cat (  \"Adjusting for\" ,    ncol (  design ) -   ncol (  batchmod ) ,  'covariate(s) or covariate level(s)\\n' ) # Check if the design is confounded  if (     qr (  design ) $ rank undefined   ncol (  design ) )  { #if(ncol(design)  if (    ncol (  design ) ==  (   n.batch +  1 ) )  {   stop (  \"The covariate is confounded with batch! Remove the covariate and rerun ComBat\" ) }  if (    ncol (  design ) undefined  (   n.batch +  1 ) )  {  if (  (     qr (   design [ ,  -   c (   1 :  n.batch ) ] ) $ rank undefined   ncol (   design [ ,  -   c (   1 :  n.batch ) ] ) ) )  {   stop (  'The covariates are confounded! Please remove one or more of the covariates so the design is not confounded' ) } else  {   stop (  \"At least one covariate is confounded with batch! Please remove confounded covariates and rerun ComBat\" ) } } } ## Check for missing values   NAs =   any (   is.na (  dat ) )  if (  NAs )  {   cat (   c (  'Found' ,   sum (   is.na (  dat ) ) ,  'Missing Data Values\\n' ) , sep =  ' ' ) } #print(dat[1:2,]) ##Standardize Data across genes   cat (  'Standardizing Data across genes\\n' )  if (  !  NAs )  {   B.hat -     solve (    t (  design ) %*%  design ) %*%   t (  design ) %*%   t (   as.matrix (  dat ) ) } else  {   B.hat =   apply (  dat ,  1 ,  Beta.NA ,  design ) } #Standarization Model   grand.mean -    t (   n.batches /  n.array ) %*%   B.hat [   1 :  n.batch , ]  if (  !  NAs )  {   var.pooled -   (   (   dat -   t (   design %*%  B.hat ) ) ^  2 ) %*%   rep (   1 /  n.array ,  n.array ) } else  {   var.pooled -   apply (   dat -   t (   design %*%  B.hat ) ,  1 ,  var , na.rm =  T ) }   stand.mean -    t (  grand.mean ) %*%   t (   rep (  1 ,  n.array ) )  if (  !   is.null (  design ) )  {   tmp -  design ;    tmp [ ,   c (   1 :  n.batch ) ] -  0 ;   stand.mean -   stand.mean +   t (   tmp %*%  B.hat ) }   s.data -   (   dat -  stand.mean ) /  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ##Get regression batch effect parameters   cat (  \"Fitting L/S model and finding priors\\n\" )   batch.design -   design [ ,   1 :  n.batch ]  if (  !  NAs )  {   gamma.hat -     solve (    t (  batch.design ) %*%  batch.design ) %*%   t (  batch.design ) %*%   t (   as.matrix (  s.data ) ) } else  {   gamma.hat =   apply (  s.data ,  1 ,  Beta.NA ,  batch.design ) }   delta.hat -  NULL  for  ( i in  batches )  {   delta.hat -   rbind (  delta.hat ,   apply (   s.data [ ,  i ] ,  1 ,  var , na.rm =  T ) ) } ##Find Priors   gamma.bar -   apply (  gamma.hat ,  1 ,  mean )   t2 -   apply (  gamma.hat ,  1 ,  var )   a.prior -   apply (  delta.hat ,  1 ,  aprior )   b.prior -   apply (  delta.hat ,  1 ,  bprior ) ##Plot empirical and parametric priors  if (   prior.plots undefined  par.prior )  {   par ( mfrow =   c (  2 ,  2 ) )   tmp -   density (   gamma.hat [  1 , ] )   plot (  tmp , type =  'l' , main =  \"Density Plot\" )   xx -   seq (   min (   tmp $ x ) ,   max (   tmp $ x ) , length =  100 )   lines (  xx ,   dnorm (  xx ,   gamma.bar [  1 ] ,   sqrt (   t2 [  1 ] ) ) , col =  2 )   qqnorm (   gamma.hat [  1 , ] )   qqline (   gamma.hat [  1 , ] , col =  2 )   tmp -   density (   delta.hat [  1 , ] )   invgam -   1 /   rgamma (   ncol (  delta.hat ) ,   a.prior [  1 ] ,   b.prior [  1 ] )   tmp1 -   density (  invgam )   plot (  tmp , typ =  'l' , main =  \"Density Plot\" , ylim =   c (  0 ,   max (   tmp $ y ,   tmp1 $ y ) ) )   lines (  tmp1 , col =  2 )   qqplot (   delta.hat [  1 , ] ,  invgam , xlab =  \"Sample Quantiles\" , ylab =  'Theoretical Quantiles' )   lines (   c (  0 ,   max (  invgam ) ) ,   c (  0 ,   max (  invgam ) ) , col =  2 )   title (  'Q-Q Plot' ) } ##Find EB batch adjustments   gamma.star -   delta.star -  NULL  if (  par.prior )  {   cat (  \"Finding parametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   it.sol (   s.data [ ,   batches [[  i ] ] ] ,   gamma.hat [  i , ] ,   delta.hat [  i , ] ,   gamma.bar [  i ] ,   t2 [  i ] ,   a.prior [  i ] ,   b.prior [  i ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } else  {   cat (  \"Finding nonparametric adjustments\\n\" )  for  ( i in   1 :  n.batch )  {   temp -   int.eprior (   as.matrix (   s.data [ ,   batches [[  i ] ] ] ) ,   gamma.hat [  i , ] ,   delta.hat [  i , ] )   gamma.star -   rbind (  gamma.star ,   temp [  1 , ] )   delta.star -   rbind (  delta.star ,   temp [  2 , ] ) } } ### Normalize the Data ###   cat (  \"Adjusting the Data\\n\" )   bayesdata -  s.data   j -  1  for  ( i in  batches )  {    bayesdata [ ,  i ] -   (    bayesdata [ ,  i ] -   t (    batch.design [  i , ] %*%  gamma.star ) ) /  (    sqrt (   delta.star [  j , ] ) %*%   t (   rep (  1 ,   n.batches [  j ] ) ) )   j -   j +  1 }   bayesdata -   (   bayesdata *  (    sqrt (  var.pooled ) %*%   t (   rep (  1 ,  n.array ) ) ) ) +  stand.mean   return (  bayesdata ) } ",
    "filename": "ComBat.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_1 sva_release_3_2

{
    "package": "sva",
    "release_versions": "sva_release_3_1 sva_release_3_2",
    "desc_release_old": "3.14.0",
    "desc_release_new": "3.18.0",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_2 sva_release_3_3

{
    "package": "sva",
    "release_versions": "sva_release_3_2 sva_release_3_3",
    "desc_release_old": "3.18.0",
    "desc_release_new": "3.20.0",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_3 sva_release_3_4

{
    "package": "sva",
    "release_versions": "sva_release_3_3 sva_release_3_4",
    "desc_release_old": "3.20.0",
    "desc_release_new": "3.22.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_4 sva_release_3_5

{
    "package": "sva",
    "release_versions": "sva_release_3_4 sva_release_3_5",
    "desc_release_old": "3.22.0",
    "desc_release_new": "3.24.4",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

qsva
read.degradation.matrix


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_5 sva_release_3_6

{
    "package": "sva",
    "release_versions": "sva_release_3_5 sva_release_3_6",
    "desc_release_old": "3.24.4",
    "desc_release_new": "3.26.0",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_6 sva_release_3_7

{
    "package": "sva",
    "release_versions": "sva_release_3_6 sva_release_3_7",
    "desc_release_old": "3.26.0",
    "desc_release_new": "3.28.0",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_7 sva_release_3_8

{
    "package": "sva",
    "release_versions": "sva_release_3_7 sva_release_3_8",
    "desc_release_old": "3.28.0",
    "desc_release_new": "3.30.1",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

sva_network


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_8 sva_release_3_9

{
    "package": "sva",
    "release_versions": "sva_release_3_8 sva_release_3_9",
    "desc_release_old": "3.30.1",
    "desc_release_new": "3.32.1",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_9 sva_release_3_11

{
    "package": "sva",
    "release_versions": "sva_release_3_9 sva_release_3_11",
    "desc_release_old": "3.32.1",
    "desc_release_new": "3.36.0",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

ComBat_seq


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_11 sva_release_3_12

{
    "package": "sva",
    "release_versions": "sva_release_3_11 sva_release_3_12",
    "desc_release_old": "3.36.0",
    "desc_release_new": "3.38.0",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_12 sva_release_3_13

{
    "package": "sva",
    "release_versions": "sva_release_3_12 sva_release_3_13",
    "desc_release_old": "3.38.0",
    "desc_release_new": "3.40.0",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_13 sva_release_3_14

{
    "package": "sva",
    "release_versions": "sva_release_3_13 sva_release_3_14",
    "desc_release_old": "3.40.0",
    "desc_release_new": "3.42.0",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  sva_release_3_14 sva_master

{
    "package": "sva",
    "release_versions": "sva_release_3_14 sva_master",
    "desc_release_old": "3.42.0",
    "desc_release_new": "3.43.0",
    "old_release_number": 17,
    "new_release_number": 18,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

