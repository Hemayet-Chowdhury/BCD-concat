
###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_2_11 phyloseq_release_2_12

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_2_11 phyloseq_release_2_12",
    "desc_release_old": "1.2.1",
    "desc_release_new": "1.4.5",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 13,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 7,
    "total_count": 7
}

##########
Functions Removed
##########



##########
Functions Added
##########

build_tax_table
nodeplotblank
nodeplotboot
nodeplotdefault
parse_taxonomy_default
parse_taxonomy_greengenes
parse_taxonomy_qiime
plot_bar
plot_scree
psmelt
sample_names<-
taxa_names<-
refseq


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "import_qiime_otu_tax",
    "representation": "import_qiime_otu_tax",
    "parameters": "function ( file , biotaxonomy = NULL , parallel = FALSE , chunk.size = 1000L , verbose = TRUE )",
    "body": "{ ### Some parallel-foreach housekeeping. # If user specifies not-parallel run (the default), register the sequential \"back-end\"  if (  !  parallel )  {   registerDoSEQ ( ) } # Check for commented lines, starting with line 1. # The deepest commented line (largest n) is assumed to have header information.   n -  1L   header -   readLines (  file ,  n )   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" )  while (  stillHeader )  { # Check again if this is a commented line   n -   n +  1   header -    strsplit (    readLines (  file ,  n ) [[  n ] ] ,  \"\\t\" ,  TRUE ) [[  1 ] ]   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" ) # Read the header portion of file up to the line # that contains the \"Consensus Lineage\" label   stillHeader -   stillHeader undefined  !   any (    c (  \"Consensus Lineage\" ,  \"Consensus\" ,  \"Lineage\" ) %in%  header ) } # Remove the first and last values (strings \"#OTU ID\" and \"Consensus Lineage\", respectively) # to get the sample names from the header   sampleNames -    header [  -   length (  header ) ] [  -  1 ]  if (  verbose )   cat (  \"\\nReading and parsing file in chunks ... Could take some time. Please be patient...\" , fill =  TRUE )  if (  verbose )   cat (  \"\\nBuilding OTU Table in chunks. Each chunk is one dot.\" , fill =  TRUE ) # Initialize taxstring, you will just build it up and parse it at once after the loop.   taxstring -   character (  0 ) # Initialize the empty matrix to build-up as you go.   otutab -   matrix (  NA_integer_ , nrow =  0 , ncol =   length (  sampleNames ) ) # Loop while chunk is as big as chunk.size   chunking_otu -  TRUE  while (  chunking_otu )  { # optionally print chunk indicator  if (  verbose )   cat (  \".\" ) # Define the chunk   taxa.scan -   scan (  file ,   as.list (  header ) , skip =  n , quiet =  TRUE , sep =  \"\\t\" , multi.line =  FALSE , nmax =  chunk.size ) # Store the taxa-names and taxonomy-string separately.   taxaNames -   taxa.scan [[  1 ] ]   taxstring -   c (  taxstring ,   taxa.scan [[   length (  taxa.scan ) ] ] )    names (  taxstring ) -  taxaNames # Trim taxa.scan to just abundance values, and name by sample   taxa.scan -    taxa.scan [  -   length (  header ) ] [  -  1 ]    names (  taxa.scan ) -  sampleNames # Parse otu_table.   otutab.chunk -    foreach ( i =  sampleNames , .combine =  cbind ) %dopar%  {   as.numeric (   taxa.scan [[  i ] ] ) }    colnames (  otutab.chunk ) -  sampleNames    rownames (  otutab.chunk ) -  taxaNames # Add to otutab   otutab -   rbind (  otutab ,  otutab.chunk ) # Control loop. Either stop, or calculate new n.  if (    length (   taxa.scan [[  1 ] ] ) undefined  chunk.size )  {   chunking_otu -  FALSE } else  { # Calculate the new start position, n   n -   n +  chunk.size } } # Remove taxa.scan to clear memory usage. Call garbage collection right away.   rm (  taxa.scan )   garbage.collection -   gc (  FALSE )  if (  verbose )   cat (  \"Building Taxonomy Table...\" , fill =  TRUE )   tax_table -   parse_qiime_tax_string (  taxstring ,  biotaxonomy )    rownames (  tax_table ) -   rownames (  otutab ) # Call garbage collection one more time. Lots of unneeded stuff.   garbage.collection -   gc (  FALSE )   return (   list ( otutab =  otutab , tax_table =  tax_table ) ) } ",
    "filename": "IO-methods.txt"
  },
  "new_function": {
    "name": "import_qiime_otu_tax",
    "representation": "import_qiime_otu_tax",
    "parameters": "function ( file , parseFunction = parse_taxonomy_qiime , parallel = FALSE , chunk.size = 1000L , verbose = TRUE )",
    "body": "{ ### Some parallel-foreach housekeeping. # If user specifies not-parallel run (the default), register the sequential \"back-end\"  if (  !  parallel )  {   registerDoSEQ ( ) } # Check for commented lines, starting with line 1. # The deepest commented line (largest n) is assumed to have header information.   n -  1L   header -   readLines (  file ,  n )   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" )  while (  stillHeader )  { # Check again if this is a commented line   n -   n +  1   header -    strsplit (    readLines (  file ,  n ) [[  n ] ] ,  \"\\t\" ,  TRUE ) [[  1 ] ]   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" ) # Read the header portion of file up to the line # that contains the \"Consensus Lineage\" label   stillHeader -   stillHeader undefined  !   any (    c (  \"Consensus Lineage\" ,  \"Consensus\" ,  \"Lineage\" ) %in%  header ) } # Remove the first and last values (strings \"#OTU ID\" and \"Consensus Lineage\", respectively) # to get the sample names from the header   sampleNames -    header [  -   length (  header ) ] [  -  1 ]  if (  verbose )   cat (  \"\\nReading and parsing file in chunks ... Could take some time. Please be patient...\" , fill =  TRUE )  if (  verbose )   cat (  \"\\nBuilding OTU Table in chunks. Each chunk is one dot.\" , fill =  TRUE ) # Initialize taxstring, you will just build it up and parse it at once after the loop.   taxstring -   character (  0 ) # Initialize the empty matrix to build-up as you go.   otutab -   matrix (  NA_integer_ , nrow =  0 , ncol =   length (  sampleNames ) ) # Loop while chunk is as big as chunk.size   chunking_otu -  TRUE  while (  chunking_otu )  { # optionally print chunk indicator  if (  verbose )   cat (  \".\" ) # Define the chunk   taxa.scan -   scan (  file ,   as.list (  header ) , skip =  n , quiet =  TRUE , sep =  \"\\t\" , multi.line =  FALSE , nmax =  chunk.size ) # Store the taxa-names and taxonomy-string separately.   taxaNames -   taxa.scan [[  1 ] ]   taxstring -   c (  taxstring ,   taxa.scan [[   length (  taxa.scan ) ] ] ) # Trim taxa.scan to just abundance values, and name by sample   taxa.scan -    taxa.scan [  -   length (  header ) ] [  -  1 ]    names (  taxa.scan ) -  sampleNames # Parse otu_table.   otutab.chunk -    foreach ( i =  sampleNames , .combine =  cbind ) %dopar%  {   as.numeric (   taxa.scan [[  i ] ] ) }    colnames (  otutab.chunk ) -  sampleNames    rownames (  otutab.chunk ) -  taxaNames # Add to otutab   otutab -   rbind (  otutab ,  otutab.chunk ) # Control loop. Either stop, or calculate new n.  if (    length (   taxa.scan [[  1 ] ] ) undefined  chunk.size )  {   chunking_otu -  FALSE } else  { # Calculate the new start position, n   n -   n +  chunk.size } } # Remove taxa.scan to clear memory usage. Call garbage collection right away.   rm (  taxa.scan )   garbage.collection -   gc (  FALSE )  if (  verbose )   cat (  \"Building Taxonomy Table...\" , fill =  TRUE ) # # # # # Explicit foreach loops lost the competition (by a lot) to llply # Split into \"jagged\" list (vectors of different lengths)   taxlist =   llply (  taxstring ,  parseFunction , .parallel =  parallel ) # Add OTU names to list element names    names (  taxlist ) -   rownames (  otutab ) # Build the tax table from the jagged list.   tax_table -   build_tax_table (  taxlist ) # Call garbage collection one more time. Lots of unneeded stuff.   garbage.collection -   gc (  FALSE )   return (   list ( otutab =  otutab , tax_table =  tax_table ) ) } ",
    "filename": "IO-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "otu_table",
    "parameters": "function ( x , eqspecies , archetype = 1 )",
    "body": "{  if (    length (  eqspecies ) undefined  2 )  {   return (  x ) }  if (    class (  eqspecies ) !=  \"character\" )  {   eqspecies -    taxa_names (  x ) [  eqspecies ] } # Shrink newx table to just those species in eqspecies   newx -   prune_taxa (  eqspecies ,  x )  if (    class (  archetype ) !=  \"character\" )  {   keepIndex =  archetype } else  {   keepIndex =   which (   eqspecies ==  archetype ) }  if (   taxa_are_rows (  x ) )  {    x [   eqspecies [  keepIndex ] , ] -   sample_sums (  newx ) } else  {    x [ ,   eqspecies [  keepIndex ] ] -   sample_sums (  newx ) }   removeIndex -   which (    taxa_names (  x ) %in%   eqspecies [  -  keepIndex ] )   x -   prune_taxa (    taxa_names (  x ) [  -  removeIndex ] ,  x )   return (  x ) } ",
    "filename": "merge-methods.txt"
  },
  "new_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "otu_table",
    "parameters": "function ( x , eqtaxa , archetype = 1L )",
    "body": "{  if (    length (  eqtaxa ) undefined  2 )  {   return (  x ) }   indList =   merge_taxa.indices.internal (  x ,  eqtaxa ,  archetype )   removeIndex =   indList $ removeIndex   keepIndex =   indList $ keepIndex # Merge taxa by summing all the equivalent taxa and assigning to the one in keepIndex  if (   taxa_are_rows (  x ) )  {    x [  keepIndex , ] =   colSums (   x [  eqtaxa , ] ) } else  {    x [ ,  keepIndex ] =   rowSums (   x [ ,  eqtaxa ] ) } # For speed, use matrix subsetting instead of prune_taxa()  if (   taxa_are_rows (  x ) )  {   x =   x [  -  removeIndex , , drop =  FALSE ] } else  {   x =   x [ ,  -  removeIndex , drop =  FALSE ] }   return (  x ) } ",
    "filename": "merge-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "phylo",
    "parameters": "function ( x , eqspecies , archetype = 1 )",
    "body": "{ # If there is nothing to merge, return x as-is  if (    length (  eqspecies ) undefined  2 )  {   return (  x ) }  if (    class (  eqspecies ) !=  \"character\" )  {   eqspecies -    x $ tip.label [  eqspecies ] }  if (    class (  archetype ) !=  \"character\" )  {   keepIndex -  archetype } else  {   keepIndex -   which (   eqspecies ==  archetype ) }   removeIndex -   which (    x $ tip.label %in%   eqspecies [  -  keepIndex ] ) # If there is too much to merge (tree would have one or 0 branches), return NULL/warning  if (    length (  removeIndex ) =  (    ntaxa (  x ) -  1 ) )  { # Can't have a tree with 1 or fewer tips   warning (  \"merge_taxa attempted to reduce tree to 1 or fewer tips.\\n tree replaced with NULL.\" )   return (  NULL ) # Else, drop the removeIndex tips and returns the pruned tree. } else  {   return (   drop.tip (  x ,  removeIndex ) ) } } ",
    "filename": "merge-methods.txt"
  },
  "new_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "phylo",
    "parameters": "function ( x , eqtaxa , archetype = 1L )",
    "body": "{ # If there is nothing to merge, return x as-is  if (    length (  eqtaxa ) undefined  2 )  {   return (  x ) }   indList =   merge_taxa.indices.internal (  x ,  eqtaxa ,  archetype )   removeIndex =   indList $ removeIndex # If there is too much to merge (tree would have 1 or 0 branches), return NULL/warning  if (    length (  removeIndex ) =  (    ntaxa (  x ) -  1 ) )  { # Can't have a tree with 1 or fewer tips   warning (  \"merge_taxa attempted to reduce tree to 1 or fewer tips.\\n tree replaced with NULL.\" )   return (  NULL ) # Else, drop the removeIndex tips and returns the pruned tree. } else  {   return (   drop.tip (  x ,  removeIndex ) ) } } ",
    "filename": "merge-methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "phyloseq",
    "parameters": "function ( x , eqspecies , archetype = 1 )",
    "body": "{   comp_list -   splat.phyloseq.objects (  x )   merged_list -   lapply (  comp_list ,  merge_taxa ,  eqspecies ,  archetype ) # the element names can wreak havoc on do.call    names (  merged_list ) -  NULL # Re-instantiate the combined object using the species-merged object.   do.call (  \"phyloseq\" ,  merged_list ) } ",
    "filename": "merge-methods.txt"
  },
  "new_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "phyloseq",
    "parameters": "function ( x , eqtaxa , archetype = 1L )",
    "body": "{   comp_list -   splat.phyloseq.objects (  x )   merged_list -   lapply (  comp_list ,  merge_taxa ,  eqtaxa ,  archetype ) # the element names can wreak havoc on do.call    names (  merged_list ) -  NULL # Re-instantiate the combined object using the species-merged object.   do.call (  \"phyloseq\" ,  merged_list ) } ",
    "filename": "merge-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "sample_data",
    "parameters": "function ( x , eqspecies , archetype = 1 )",
    "body": "{   return (  x ) } ",
    "filename": "merge-methods.txt"
  },
  "new_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "sample_data",
    "parameters": "function ( x , eqtaxa , archetype = 1L )",
    "body": "{   return (  x ) } ",
    "filename": "merge-methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "taxonomyTable",
    "parameters": "function ( x , eqspecies , archetype = 1 )",
    "body": "{  if (    length (  eqspecies ) undefined  2 )  {   return (  x ) }  if (    class (  eqspecies ) !=  \"character\" )  {   eqspecies -    taxa_names (  x ) [  eqspecies ] }  if (    class (  archetype ) !=  \"character\" )  {   keepIndex -  archetype } else  {   keepIndex -   which (   eqspecies ==  archetype ) }   removeIndex -   which (    taxa_names (  x ) %in%   eqspecies [  -  keepIndex ] ) # # # Taxonomy is trivial in ranks after disagreement among merged taxa # # # Make those values NA_character_   taxmerge -    as (   tax_table (  x ) ,  \"matrix\" ) [  eqspecies , ]   bad_ranks -   apply (  taxmerge ,  2 ,  function ( i )  {    length (   unique (  i ) ) !=  1 } ) # Test if all taxonomies agree. If so, do nothing. Just continue to pruning.  if (   any (  bad_ranks ) )  { # The col indices of the bad ranks   bad_ranks -    min (   which (  bad_ranks ) ) :   length (  bad_ranks ) # Replace bad taxonomy elements in the archetype only (others are pruned)     tax_table (  x ) [   eqspecies [  keepIndex ] ,  bad_ranks ] -  NA_character_ } # Finally, prune all the merging taxa, except the archetype   x -   prune_taxa (    taxa_names (  x ) [  -  removeIndex ] ,  x )   return (  x ) } ",
    "filename": "merge-methods.txt"
  },
  "new_function": {
    "name": "merge_taxa",
    "representation": "merge_taxa",
    "signature": "taxonomyTable",
    "parameters": "function ( x , eqtaxa , archetype = 1L )",
    "body": "{  if (    length (  eqtaxa ) undefined  2 )  {   return (  x ) }   indList =   merge_taxa.indices.internal (  x ,  eqtaxa ,  archetype )   removeIndex =   indList $ removeIndex   keepIndex =   indList $ keepIndex # # # Taxonomy is trivial in ranks after disagreement among merged taxa # # # Make those values NA_character_   taxmerge -    as (  x ,  \"matrix\" ) [  eqtaxa , ]   bad_ranks -   apply (  taxmerge ,  2 ,  function ( i )  {    length (   unique (  i ) ) !=  1 } ) # Test if all taxonomies agree. If so, do nothing. Just continue to pruning.  if (   any (  bad_ranks ) )  { # The col indices of the bad ranks   bad_ranks -    min (   which (  bad_ranks ) ) :   length (  bad_ranks ) # Replace bad taxonomy elements in the archetype only (others are pruned)    x [  keepIndex ,  bad_ranks ] -  NA_character_ } # Finally, remove the OTUs that have been merged into keepIndex   return (   x [  -  removeIndex , , drop =  FALSE ] ) } ",
    "filename": "merge-methods.txt"
  }
}

6.
{
  "old_function": {
    "name": "plot_tree",
    "representation": "plot_tree",
    "parameters": "function ( physeq , method = \"sampledodge\" , color = NULL , shape = NULL , size = NULL , min.abundance = Inf , label.tips = NULL , text.size = NULL , sizebase = 5 , base.spacing = 0.02 , title = NULL )",
    "body": "{  if (   method %in%   c (  \"treeonly\" ) )  {   p -   plot_tree_only (  physeq ) }  if (   method ==  \"sampledodge\" )  {   p -   plot_tree_sampledodge (  physeq ,  color ,  shape ,  size ,  min.abundance ,  label.tips ,  text.size ,  sizebase ,  base.spacing ) } # Theme-ing:   p -   p +   theme ( axis.ticks =   element_blank ( ) , axis.title.x =   element_blank ( ) , axis.text.x =   element_blank ( ) , axis.title.y =   element_blank ( ) , axis.text.y =   element_blank ( ) , panel.background =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , panel.grid.major =   element_blank ( ) ) # Optionally add a title to the plot  if (  !   is.null (  title ) )  {   p -   p +   ggtitle (  title ) }   return (  p ) } ",
    "filename": "plot-methods.txt"
  },
  "new_function": {
    "name": "plot_tree",
    "representation": "plot_tree",
    "parameters": "function ( physeq , method = \"sampledodge\" , nodelabf = NULL , color = NULL , shape = NULL , size = NULL , min.abundance = Inf , label.tips = NULL , text.size = NULL , sizebase = 5 , base.spacing = 0.02 , ladderize = FALSE , plot.margin = 0.2 , title = NULL )",
    "body": "{ # Test that physeq has tree, top-level test.  if (   is.null (   phy_tree (  physeq ,  FALSE ) ) )  {   stop (  \"There is no phylogenetic tree in the object you have provided. Try phy_tree(physeq) to see.\" ) } # Create the tree data.frame   tdf -   tree.layout (   phy_tree (  physeq ) , ladderize =  ladderize ) # \"Naked\" unannotated tree built in ggplot2 no matter what. Lines only.   p -   plot_tree_only (  tdf ) # If no text.size given, calculate it from number of tips (\"species\", aka taxa) # This is very fast. No need to worry about whether text is printed or not. DRY.  if (   is.null (  text.size ) )  {   text.size -   treetextsize (   ntaxa (  physeq ) ) } # Tip annotation section. # # Annotate dodged sample points, and other fancy tip labels  if (   method ==  \"sampledodge\" )  {   p -   plot_tree_sampledodge (  physeq ,  p ,  tdf ,  color ,  shape ,  size ,  min.abundance ,  label.tips ,  text.size ,  sizebase ,  base.spacing ) } # Node label section. # # If no nodelabf (\"node label function\") given, ask internal function to pick one. # Is NULL by default, meaning will dispatch to howtolabnodes to select function. # For no node labels, the \"dummy\" function nodeplotnot will return tree plot # object, p, as-is, unmodified.  if (   is.null (  nodelabf ) )  {   nodelabf =   howtolabnodes (  physeq ) } # Subset data.frame to just the internal nodes (not leaves).   nodelabdf =   subset (  tdf ,    is.leaf ==  FALSE undefined   type ==  \"node\" ) # Use the provided/inferred node label function to add the node labels layer(s)   p =   nodelabf (  p ,  nodelabdf ) # Plot margins. # # Adjust the tree graphic plot margins. # Helps to manually ensure that graphic elements aren't clipped, # especially when there are long tip labels.  if (   method ==  \"sampledodge\" )  {   min.x -   min (   tdf $ x ,      p $ layers [[  2 ] ] $ data $ x , na.rm =  TRUE )   max.x -   max (   tdf $ x ,      p $ layers [[  2 ] ] $ data $ x , na.rm =  TRUE ) } else  {   min.x -   min (   tdf $ x , na.rm =  TRUE )   max.x -   max (   tdf $ x , na.rm =  TRUE ) }  if (   plot.margin undefined  0 )  {   max.x -   max.x *  (   1.0 +  plot.margin ) }   p -   p +   scale_x_continuous ( limits =   c (  min.x ,  max.x ) ) # Themeing section. # # Theme-ing: Blank theming # Should open this up as function-argument also.   p -   p +   theme ( axis.ticks =   element_blank ( ) , axis.title.x =   element_blank ( ) , axis.text.x =   element_blank ( ) , axis.title.y =   element_blank ( ) , axis.text.y =   element_blank ( ) , panel.background =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , panel.grid.major =   element_blank ( ) ) # Optionally add a title to the plot  if (  !   is.null (  title ) )  {   p -   p +   ggtitle (  title ) }   return (  p ) } ",
    "filename": "plot-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_2_12 phyloseq_release_2_13

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_2_12 phyloseq_release_2_13",
    "desc_release_old": "1.4.5",
    "desc_release_new": "1.6.1",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

gapstat_ord
microbio_me_qiime
plot_clusgap
read_tree_greengenes


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "plot_richness",
    "representation": "plot_richness",
    "parameters": "function ( physeq , x = \"samples\" , color = NULL , shape = NULL , title = NULL , shsi = FALSE )",
    "body": "{ # Make the plotting data.frame   DF -   data.frame (   estimate_richness (  physeq ) ,   sample_data (  physeq ) ) # If there is no \"samples\" variable in DF, add it  if (  !   \"samples\" %in%   names (  DF ) )  {    DF $ samples =   sample_names (  physeq ) } # sample_names used to be default, and should also work. # #backwardcompatibility  if (  !   is.null (  x ) )  {  if (   x %in%   c (  \"sample\" ,  \"samples\" ,  \"sample_names\" ) )  {   x =  \"samples\" } } # Define \"measure\" variables and s.e. labels (ses).   measures =   c (  \"S.obs\" ,  \"S.chao1\" ,  \"S.ACE\" ,  \"shannon\" ,  \"simpson\" )   ses =   c (  \"se.obs\" ,  \"se.chao1\" ,  \"se.ACE\" ,  \"se.shannon\" ,  \"se.simpson\" ) # melt, for different richnesses...   mdf =   melt (  DF , measure.vars =  measures ) # Merge s.e. into one \"se\" column    mdf $ se =  NA_integer_    mdf $ wse =   paste (  \"se.\" ,   substr (   mdf $ variable ,  3 ,  10 ) , sep =  \"\" )  for  ( i in   1 :   nrow (  mdf ) )  {  if (    mdf [  i ,  \"wse\" ] %in%   c (  \"se.chao1\" ,  \"se.ACE\" ) )  {    mdf [  i ,  \"se\" ] =   mdf [  i ,  (   mdf [  i ,  \"wse\" ] ) ] } } # Rm shannon/simpson if !shsi  if (  !  shsi )  {   mdf =   subset (  mdf ,   variable %in%   measures [   1 :  3 ] ) } # map variables   richness_map -   aes_string ( x =  x , y =  \"value\" , color =  color , shape =  shape ) # Make the ggplot.   p -      ggplot (  mdf ,  richness_map ) +   geom_point ( na.rm =  TRUE ) +   geom_errorbar (   aes ( ymax =   value +  se , ymin =   value -  se ) , width =  0.2 ) +   theme ( axis.text.x =   element_text ( angle =  -  90 , hjust =  0 ) ) # Add label according to whether or not shannon/simpson indices are included  if (  shsi )  {   p =   p +   ylab (  'Alpha Diversity Measure' ) } else  {   p =   p +   ylab (  'Richness [number of taxa]' ) } # Facet differently, depending on whether shannon or simpson indices included  if (  shsi )  {   p =   p +   facet_wrap (  ~  variable , nrow =  1 , scales =  \"free\" ) } else  {   p =   p +   facet_grid (  ~  variable ) } # Optionally add a title to the plot  if (  !   is.null (  title ) )  {   p -   p +   ggtitle (  title ) }   return (  p ) } ",
    "filename": "plot-methods.txt"
  },
  "new_function": {
    "name": "plot_richness",
    "representation": "plot_richness",
    "parameters": "function ( physeq , x = \"samples\" , color = NULL , shape = NULL , title = NULL , scales = \"free_y\" , nrow = 1 , shsi = NULL , measures = NULL )",
    "body": "{ # Calculate the relevant alpha-diversity measures   erDF =   estimate_richness (  physeq , split =  TRUE , measures =  measures ) # Measures may have been renamed in `erDF`. Replace it with the name from erDF   measures =   colnames (  erDF ) # Define \"measure\" variables and s.e. labels, for melting.   ses =    colnames (  erDF ) [   grep (  \"^se\\\\.\" ,   colnames (  erDF ) ) ] # Remove any S.E. from `measures`   measures =   measures [  !   measures %in%  ses ] # Make the plotting data.frame. # This coerces to data.frame, required for reliable output from reshape2::melt()  if (  !   is.null (   sample_data (  physeq , errorIfNULL =  FALSE ) ) )  { # Include the sample data, if it is there.   DF -   data.frame (  erDF ,   sample_data (  physeq ) ) } else  { # If no sample data, leave it out.   DF -   data.frame (  erDF ) }  if (  !   \"samples\" %in%   colnames (  DF ) )  { # If there is no \"samples\" variable in DF, add it    DF $ samples -   sample_names (  physeq ) } # sample_names used to be default, and should also work. # #backwardcompatibility  if (  !   is.null (  x ) )  {  if (   x %in%   c (  \"sample\" ,  \"samples\" ,  \"sample_names\" ) )  {   x -  \"samples\" } } else  { # If x was NULL for some reason, set it to \"samples\"   x -  \"samples\" } # melt to display different alpha-measures separately   mdf =   melt (  DF , measure.vars =  measures ) # Initialize the se column. Helpful even if not used.    mdf $ se -  NA_integer_  if (    length (  ses ) undefined  0 )  { ## Merge s.e. into one \"se\" column # Define conversion vector   selabs =   c (  \"se.chao1\" ,  \"se.ACE\" ,  \"se.fisher\" )    names (  selabs ) -   c (  \"Chao1\" ,  \"ACE\" ,  \"Fisher\" )    mdf $ wse -   sapply (   as.character (   mdf $ variable ) ,  function ( i , selabs )  {   selabs [  i ] } ,  selabs )  for  ( i in   1 :   nrow (  mdf ) )  {  if (  !   is.na (   mdf [  i ,  \"wse\" ] ) )  {    mdf [  i ,  \"se\" ] -   mdf [  i ,  (   mdf [  i ,  \"wse\" ] ) ] } } # prune the redundant columns   mdf -   mdf [ ,  -   which (    colnames (  mdf ) %in%   c (  selabs ,  \"wse\" ) ) ] } ## Interpret measures # If not provided (default), keep all  if (  !   is.null (  measures ) )  {  if (   any (   measures %in%   as.character (   mdf $ variable ) ) )  { # If any measures were in mdf, then subset to just those.   mdf -   mdf [    as.character (   mdf $ variable ) %in%  measures , ] } else  { # Else, print warning about bad option choice for measures, keeping all.   warning (  \"Argument to `measures` not supported. All alpha-diversity measures included in plot.\" ) } }  if (  !   is.null (  shsi ) )  { # Deprecated: # If shsi is anything but NULL, print a warning about its being deprecated   warning (  \"shsi no longer supported option in plot_richness. Please use `measures` instead\" ) } # map variables   richness_map -   aes_string ( x =  x , y =  \"value\" , color =  color , shape =  shape ) # Make the ggplot.   p -    ggplot (  mdf ,  richness_map ) +   geom_point ( na.rm =  TRUE ) # Add error bars if mdf$se is not all NA  if (   any (  !   is.na (   mdf [ ,  \"se\" ] ) ) )  {   p =   p +   geom_errorbar (   aes ( ymax =   value +  se , ymin =   value -  se ) , width =  0.1 ) } # Rotate horizontal axis labels, and adjust   p =   p +   theme ( axis.text.x =   element_text ( angle =  -  90 , vjust =  0.5 , hjust =  0 ) ) # Add y-label   p =   p +   ylab (  'Alpha Diversity Measure' ) # Facet wrap using user-options   p =   p +   facet_wrap (  ~  variable , nrow =  nrow , scales =  scales ) # Optionally add a title to the plot  if (  !   is.null (  title ) )  {   p -   p +   ggtitle (  title ) }   return (  p ) } ",
    "filename": "plot-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_2_13 phyloseq_release_2_14

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_2_13 phyloseq_release_2_14",
    "desc_release_old": "1.6.1",
    "desc_release_new": "1.8.2",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

export_mothur_dist
import_usearch_uc
phyloseq_to_deseq2
show_mothur_cutoffs


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "import_mothur",
    "representation": "import_mothur",
    "parameters": "function ( mothur_list_file , mothur_group_file = NULL , mothur_tree_file = NULL , cutoff = NULL )",
    "body": "{  if (   missing (  mothur_list_file ) )  {   cat (  \"you must provide the mothur_list_file argument\\n\" ) } # Create otu_table object, OTU, only if group file provided.  if (  !   is.null (  mothur_group_file ) )  {   OTU -   import_mothur_otu_table (  mothur_list_file ,  mothur_group_file ,  cutoff ) } # Similarly, only get modified tree object if tree file provided.  if (  !   is.null (  mothur_tree_file ) )  {   tree -   import_mothur_tree (  mothur_tree_file ,  mothur_list_file ,  cutoff ) } ### Decide what is going to be returned, based on arguments. # If no group and no tree, then only list. Return list module output.  if (    is.null (  mothur_group_file ) undefined   is.null (  mothur_tree_file ) )  {   return (   import_mothur_otulist (  mothur_list_file ,  cutoff ) ) } else  if (   !   is.null (  mothur_group_file ) undefined   is.null (  mothur_tree_file ) )  {   return (  OTU ) } else  if (    is.null (  mothur_group_file ) undefined  !   is.null (  mothur_tree_file ) )  {   return (  tree ) } else  if (   !   is.null (  mothur_group_file ) undefined  !   is.null (  mothur_tree_file ) )  { # Return a merged OTU and tree object   return (   phyloseq (  OTU ,  tree ) ) } } ",
    "filename": "IO-methods.txt"
  },
  "new_function": {
    "name": "import_mothur",
    "representation": "import_mothur",
    "parameters": "function ( mothur_list_file = NULL , mothur_group_file = NULL , mothur_tree_file = NULL , cutoff = NULL , mothur_shared_file = NULL , mothur_constaxonomy_file = NULL , parseFunction = parse_taxonomy_default )",
    "body": "{   pslist =   vector (  \"list\" )  if (   !   is.null (  mothur_group_file ) undefined  !   is.null (  mothur_list_file ) )  { # If list   groupOTU =   import_mothur_otu_table (  mothur_list_file ,  mothur_group_file ,  cutoff )   pslist =   c (  pslist ,   list (  groupOTU ) ) }  if (  !   is.null (  mothur_tree_file ) )  {   tree -   read_tree (  mothur_tree_file )   pslist =   c (  pslist ,   list (  tree ) ) }  if (  !   is.null (  mothur_shared_file ) )  {   OTUshared -   import_mothur_shared (  mothur_shared_file )   pslist =   c (  pslist ,   list (  OTUshared ) ) }  if (  !   is.null (  mothur_constaxonomy_file ) )  {   tax -   import_mothur_constaxonomy (  mothur_constaxonomy_file ,  parseFunction )   pslist =   c (  pslist ,   list (  tax ) ) }   return (   do.call (  \"phyloseq\" ,  pslist ) ) } ",
    "filename": "IO-methods.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "import_qiime_otu_tax",
    "representation": "import_qiime_otu_tax",
    "parameters": "function ( file , parseFunction = parse_taxonomy_qiime , parallel = FALSE , chunk.size = 1000L , verbose = TRUE )",
    "body": "{ ### Some parallel-foreach housekeeping. # If user specifies not-parallel run (the default), register the sequential \"back-end\"  if (  !  parallel )  {   registerDoSEQ ( ) } # Check for commented lines, starting with line 1. # The deepest commented line (largest n) is assumed to have header information.   n -  1L   header -   readLines (  file ,  n )   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" )  while (  stillHeader )  { # Check again if this is a commented line   n -   n +  1   header -    strsplit (    readLines (  file ,  n ) [[  n ] ] ,  \"\\t\" ,  TRUE ) [[  1 ] ]   stillHeader -   identical (   substr (   header [  1 ] ,  1 ,  1 ) ,  \"#\" ) # Read the header portion of file up to the line # that contains the \"Consensus Lineage\" label   stillHeader -   stillHeader undefined  !   any (    c (  \"Consensus Lineage\" ,  \"Consensus\" ,  \"Lineage\" ) %in%  header ) } # Remove the first and last values (strings \"#OTU ID\" and \"Consensus Lineage\", respectively) # to get the sample names from the header   sampleNames -    header [  -   length (  header ) ] [  -  1 ]  if (  verbose )   cat (  \"\\nReading and parsing file in chunks ... Could take some time. Please be patient...\" , fill =  TRUE )  if (  verbose )   cat (  \"\\nBuilding OTU Table in chunks. Each chunk is one dot.\" , fill =  TRUE ) # Initialize taxstring, you will just build it up and parse it at once after the loop.   taxstring -   character (  0 ) # Initialize the empty matrix to build-up as you go.   otutab -   matrix (  NA_integer_ , nrow =  0 , ncol =   length (  sampleNames ) ) # Loop while chunk is as big as chunk.size   chunking_otu -  TRUE  while (  chunking_otu )  { # optionally print chunk indicator  if (  verbose )   cat (  \".\" ) # Define the chunk   taxa.scan -   scan (  file ,   as.list (  header ) , skip =  n , quiet =  TRUE , sep =  \"\\t\" , multi.line =  FALSE , nmax =  chunk.size ) # Store the taxa-names and taxonomy-string separately.   taxaNames -   taxa.scan [[  1 ] ]   taxstring -   c (  taxstring ,   taxa.scan [[   length (  taxa.scan ) ] ] ) # Trim taxa.scan to just abundance values, and name by sample   taxa.scan -    taxa.scan [  -   length (  header ) ] [  -  1 ]    names (  taxa.scan ) -  sampleNames # Parse otu_table.   otutab.chunk -    foreach ( i =  sampleNames , .combine =  cbind ) %dopar%  {   as.numeric (   taxa.scan [[  i ] ] ) }    colnames (  otutab.chunk ) -  sampleNames    rownames (  otutab.chunk ) -  taxaNames # Add to otutab   otutab -   rbind (  otutab ,  otutab.chunk ) # Control loop. Either stop, or calculate new n.  if (    length (   taxa.scan [[  1 ] ] ) undefined  chunk.size )  {   chunking_otu -  FALSE } else  { # Calculate the new start position, n   n -   n +  chunk.size } } # Remove taxa.scan to clear memory usage. Call garbage collection right away.   rm (  taxa.scan )   garbage.collection -   gc (  FALSE )  if (  verbose )   cat (  \"Building Taxonomy Table...\" , fill =  TRUE ) # # # # # Explicit foreach loops lost the competition (by a lot) to llply # Split into \"jagged\" list (vectors of different lengths)   taxlist =   llply (  taxstring ,  parseFunction , .parallel =  parallel ) # Add OTU names to list element names    names (  taxlist ) -   rownames (  otutab ) # Build the tax table from the jagged list.   tax_table -   build_tax_table (  taxlist ) # Call garbage collection one more time. Lots of unneeded stuff.   garbage.collection -   gc (  FALSE )   return (   list ( otutab =  otutab , tax_table =  tax_table ) ) } ",
    "filename": "IO-methods.txt"
  },
  "new_function": {
    "name": "import_qiime_otu_tax",
    "representation": "import_qiime_otu_tax",
    "parameters": "function ( file , parseFunction = parse_taxonomy_qiime , verbose = TRUE , parallel = FALSE )",
    "body": "{  if (  verbose )  {   cat (  \"Reading file into memory prior to parsing...\\n\" ) }   x =   readLines (  file )  if (  verbose )  {   cat (  \"Detecting first header line...\\n\" ) } # Check for commented lines, starting with line 1. # The deepest commented line (largest n) is assumed to have header information.   skipLines =    max (   which (    substr (   x [   1 :  25L ] ,  1 ,  1 ) ==  \"#\" ) ) -  1L  if (  verbose )  {   cat (  \"Header is on line\" ,  (   skipLines +  1L ) ,  \" \\n\" ) }  if (  verbose )  {   cat (  \"Converting input file to a table...\\n\" ) }   x =   fread ( input =   paste0 (  x , collapse =  \"\\n\" ) , sep =  \"\\t\" , header =  TRUE , skip =  skipLines )  if (  verbose )  {   cat (  \"Defining OTU table... \\n\" ) }   taxstring =   x $ `Consensus Lineage` # This pops the taxonomy (Consensus Lineage) column, in-place statement   x [ ,   `Consensus Lineage` :=  NULL ] # Store the OTU names, you will pop the column   OTUnames =   x $ `#OTU ID` # This pops the OTUID column, in-place statement   x [ ,   `#OTU ID` :=  NULL ]   x -   as (  x ,  \"matrix\" )    rownames (  x ) -  OTUnames   rm (  OTUnames )  if (  verbose )  {   cat (  \"Parsing taxonomy table...\\n\" ) } # Split into \"jagged\" list (vectors of different lengths)   taxlist =   llply (  taxstring ,  parseFunction , .parallel =  parallel ) # Add OTU names to list element names    names (  taxlist ) -   rownames (  x ) # Build the tax table from the jagged list.   taxtab -   build_tax_table (  taxlist ) # Call garbage collection one more time. Lots of unneeded stuff.   garbage.collection -   gc (  FALSE ) # Return the named list   return (   list ( otutab =  x , taxtab =  taxtab ) ) } ",
    "filename": "IO-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_2_14 phyloseq_release_3_1

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_2_14 phyloseq_release_3_1",
    "desc_release_old": "1.8.2",
    "desc_release_new": "1.12.2",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

plot_net
tree_layout


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_1 phyloseq_release_3_2

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_1 phyloseq_release_3_2",
    "desc_release_old": "1.12.2",
    "desc_release_new": "1.14.0",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

distanceMethodList
phyloseq_to_metagenomeSeq


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_2 phyloseq_release_3_3

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_2 phyloseq_release_3_3",
    "desc_release_old": "1.14.0",
    "desc_release_new": "1.16.2",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

import_uparse


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_3 phyloseq_release_3_4

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_3 phyloseq_release_3_4",
    "desc_release_old": "1.16.2",
    "desc_release_new": "1.19.1",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_4 phyloseq_release_3_5

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_4 phyloseq_release_3_5",
    "desc_release_old": "1.19.1",
    "desc_release_new": "1.20.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_5 phyloseq_release_3_6

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_5 phyloseq_release_3_6",
    "desc_release_old": "1.20.0",
    "desc_release_new": "1.22.3",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_6 phyloseq_release_3_7

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_6 phyloseq_release_3_7",
    "desc_release_old": "1.22.3",
    "desc_release_new": "1.24.2",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_7 phyloseq_release_3_8

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_7 phyloseq_release_3_8",
    "desc_release_old": "1.24.2",
    "desc_release_new": "1.26.1",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_8 phyloseq_release_3_9

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_8 phyloseq_release_3_9",
    "desc_release_old": "1.26.1",
    "desc_release_new": "1.28.0",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_9 phyloseq_release_3_11

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_9 phyloseq_release_3_11",
    "desc_release_old": "1.28.0",
    "desc_release_new": "1.32.0",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_11 phyloseq_release_3_12

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_11 phyloseq_release_3_12",
    "desc_release_old": "1.32.0",
    "desc_release_new": "1.34.0",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_12 phyloseq_release_3_13

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_12 phyloseq_release_3_13",
    "desc_release_old": "1.34.0",
    "desc_release_new": "1.36.0",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_13 phyloseq_release_3_14

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_13 phyloseq_release_3_14",
    "desc_release_old": "1.36.0",
    "desc_release_new": "1.38.0",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  phyloseq_release_3_14 phyloseq_master

{
    "package": "phyloseq",
    "release_versions": "phyloseq_release_3_14 phyloseq_master",
    "desc_release_old": "1.38.0",
    "desc_release_new": "1.39.1",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

