
###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_1 ensembldb_release_3_2

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_1 ensembldb_release_3_2",
    "desc_release_old": "1.0.1",
    "desc_release_new": "1.2.2",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

runEnsDbApp
ensemblVersion
getGenomeFaFile
promoters


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_2 ensembldb_release_3_3

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_2 ensembldb_release_3_3",
    "desc_release_old": "1.2.2",
    "desc_release_new": "1.4.7",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 27,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 2
}

##########
Functions Removed
##########



##########
Functions Added
##########

ensDbFromGff
ensDbFromAH
GRangesFilter
ExonrankFilter
value
condition<-
value<-
seqnames
start
end
strand
seqlevels
cdsBy
fiveUTRsByTranscript
threeUTRsByTranscript
getGeneRegionTrackForGviz
updateEnsDb
transcriptsByOverlaps
exonsByOverlaps
columns
keytypes
keys
select
mapIds
seqlevelsStyle
seqlevelsStyle<-
supportedSeqlevelsStyles


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "ensDbFromGtf",
    "representation": "ensDbFromGtf",
    "parameters": "function ( gtf , outfile , path , organism , genomeVersion , version , verbose = FALSE )",
    "body": "{   options ( useFancyQuotes =  FALSE )  if (  verbose )   cat (  \"importing gtf file...\" )   wanted.features -   c (  \"gene\" ,  \"transcript\" ,  \"exon\" ,  \"CDS\" )   GTF -   import ( con =  gtf , format =  \"gtf\" , feature.type =  wanted.features )  if (  verbose )   cat (  \"done\\n\" ) ## check what we've got... ## all wanted features?  if (   any (  !  (   wanted.features %in%   levels (   GTF $ type ) ) ) )  {   stop (   paste0 (  \"One or more required types are not in the gtf file. Need \" ,   paste (  wanted.features , collapse =  \",\" ) ,  \" but got only \" ,   paste (   wanted.features [   wanted.features %in%   levels (   GTF $ type ) ] , collapse =  \",\" ) ,  \".\" ) ) } ## transcript biotype?  if (   any (    colnames (   mcols (  GTF ) ) ==  \"transcript_biotype\" ) )  {   txBiotypeCol -  \"transcript_biotype\" } else  { ## that's a little weird, but it seems that certain gtf files from Ensembl ## provide the transcript biotype in the element \"source\"   txBiotypeCol -  \"source\" } ## processing the metadata: ## first read the header...   tmp -   readLines (  gtf , n =  10 )   tmp -   tmp [   grep (  tmp , pattern =  \"^#\" ) ]   haveHeader -  FALSE  if (    length (  tmp ) undefined  0 )  {   tmp -   gsub (  tmp , pattern =  \"^#\" , replacement =  \"\" )   tmp -   gsub (  tmp , pattern =  \"^!\" , replacement =  \"\" )   Header -   do.call (  rbind ,   strsplit (  tmp , split =  \" \" , fixed =  TRUE ) )    colnames (  Header ) -   c (  \"name\" ,  \"value\" )   haveHeader -  TRUE } ## getting the species name and the ensembl version from the GTF file name   fromFile -  FALSE  if (     missing (  organism ) |   missing (  version ) |   missing (  genomeVersion ) )   fromFile -  TRUE  if (   missing (  organism ) )   organism -   .organismName (   organismFromGtfFileName (  gtf ) )  if (   missing (  version ) )  {   ensemblVersion -   ensemblVersionFromGtfFileName (  gtf ) } else  {   ensemblVersion -  version }  if (   missing (  genomeVersion ) )  {   genomeVersion -   genomeVersionFromGtfFileName (  gtf ) }  if (   is.na (   as.numeric (  ensemblVersion ) ) )  {  if (  fromFile )  {   stop (  \"The GTF file name is not as expected: ) } }  if (  haveHeader )  {  if (   genomeVersion !=   Header [    Header [ ,  \"name\" ] ==  \"genome-version\" ,  \"value\" ] )  {   stop (   paste0 (  \"The GTF file name is not as expected: ,  \" I've got genome version \" ,  genomeVersion ,  \" but in the header of the GTF file \" ,   Header [    Header [ ,  \"name\" ] ==  \"genome-version\" ,  \"value\" ] ,  \" is specified!\" ) ) } }   GTF -   fixCDStypeInEnsemblGTF (  GTF ) ## here on -   dbname -   ensDbFromGRanges (  GTF , outfile =  outfile , path =  path , organism =  organism , genomeVersion =  genomeVersion , version =  ensemblVersion , verbose =  verbose )   gtfFilename -   unlist (   strsplit (  gtf , split =   .Platform $ file.sep ) )   gtfFilename -   gtfFilename [   length (  gtfFilename ) ] ## updating the Metadata information...   lite -   dbDriver (  \"SQLite\" )   con -   dbConnect (  lite , dbname =  dbname )   bla -   dbGetQuery (  con ,   paste0 (  \"update metadata set value='\" ,  gtfFilename ,  \"' where name='source_file';\" ) )   dbDisconnect (  con )   return (  dbname ) } ",
    "filename": "EnsDbFromGTF.txt"
  },
  "new_function": {
    "name": "ensDbFromGtf",
    "representation": "ensDbFromGtf",
    "parameters": "function ( gtf , outfile , path , organism , genomeVersion , version )",
    "body": "{   options ( useFancyQuotes =  FALSE )   message (  \"Importing GTF file...\" , appendLF =  FALSE ) ## wanted.features   wanted.features -   c (  \"exon\" ) ## GTF   GTF -   import ( con =  gtf , format =  \"gtf\" )   message (  \"OK\" ) ## check what we've got... ## all wanted features?  if (   any (  !  (   wanted.features %in%   levels (   GTF $ type ) ) ) )  {   stop (   paste0 (  \"One or more required types are not in the gtf file. Need \" ,   paste (  wanted.features , collapse =  \",\" ) ,  \" but got only \" ,   paste (   wanted.features [   wanted.features %in%   levels (   GTF $ type ) ] , collapse =  \",\" ) ,  \".\" ) ) } ## transcript biotype?  if (   any (    colnames (   mcols (  GTF ) ) ==  \"transcript_biotype\" ) )  {   txBiotypeCol -  \"transcript_biotype\" } else  { ## that's a little weird, but it seems that certain gtf files from Ensembl ## provide the transcript biotype in the element \"source\"   txBiotypeCol -  \"source\" } ## processing the metadata: ## first read the header...   tmp -   readLines (  gtf , n =  10 )   tmp -   tmp [   grep (  tmp , pattern =  \"^#\" ) ]   haveHeader -  FALSE  if (    length (  tmp ) undefined  0 )  { ##message(\"GTF file has a header.\")   tmp -   gsub (  tmp , pattern =  \"^#\" , replacement =  \"\" )   tmp -   gsub (  tmp , pattern =  \"^!\" , replacement =  \"\" )   Header -   do.call (  rbind ,   strsplit (  tmp , split =  \" \" , fixed =  TRUE ) )    colnames (  Header ) -   c (  \"name\" ,  \"value\" )   haveHeader -  TRUE } ## Check parameters   Parms -   .checkExtractVersions (  gtf ,  organism ,  genomeVersion ,  version )   ensemblVersion -   Parms [  \"version\" ]   organism -   Parms [  \"organism\" ]   genomeVersion -   Parms [  \"genomeVersion\" ]  if (  haveHeader )  {  if (   genomeVersion !=   Header [    Header [ ,  \"name\" ] ==  \"genome-version\" ,  \"value\" ] )  {   stop (   paste0 (  \"The GTF file name is not as expected: ,  \" ,  \" I've got genome version \" ,  genomeVersion ,  \" but in the header of the GTF file \" ,   Header [    Header [ ,  \"name\" ] ==  \"genome-version\" ,  \"value\" ] ,  \" is specified!\" ) ) } }   GTF -   fixCDStypeInEnsemblGTF (  GTF ) ## here on -   dbname -   ensDbFromGRanges (  GTF , outfile =  outfile , path =  path , organism =  organism , genomeVersion =  genomeVersion , version =  ensemblVersion )   gtfFilename -   unlist (   strsplit (  gtf , split =   .Platform $ file.sep ) )   gtfFilename -   gtfFilename [   length (  gtfFilename ) ] ## updating the Metadata information...   lite -   dbDriver (  \"SQLite\" )   con -   dbConnect (  lite , dbname =  dbname )   bla -   dbGetQuery (  con ,   paste0 (  \"update metadata set value='\" ,  gtfFilename ,  \"' where name='source_file';\" ) )   dbDisconnect (  con )   return (  dbname ) } ",
    "filename": "EnsDbFromGTF.txt"
  }
}

1.
{
  "old_function": {
    "name": "ensDbFromGRanges",
    "representation": "ensDbFromGRanges",
    "parameters": "function ( x , outfile , path , organism , genomeVersion , version , verbose = FALSE )",
    "body": "{  if (    class (  x ) !=  \"GRanges\" )   stop (  \"This method can only be called on GRanges objects!\" ) ## check for missing parameters  if (   missing (  organism ) )  {   stop (  \"The organism has to be specified (e.g. using organism=\\\"Homo_sapiens\\\")\" ) }  if (   missing (  version ) )  {   stop (  \"The Ensembl version has to be specified!\" ) } ## checking the seqinfo in the GRanges object...   Seqinfo -   seqinfo (  x )   fetchSeqinfo -  FALSE ## check if we've got some information...  if (   any (   is.na (   seqlengths (  Seqinfo ) ) ) )  {   fetchSeqinfo -  TRUE ## means we have to fetch the seqinfo ourselfs... }  if (   missing (  genomeVersion ) )  { ## is there a seqinfo in x that I could use???  if (  !  fetchSeqinfo )  {   genomeVersion -   unique (   genome (  Seqinfo ) )  if (    is.na (  genomeVersion ) |    length (  genomeVersion ) undefined  1 )  {   stop (  \"The genome version has to be specified as it can not be extracted from the seqinfo!\" ) } } else  {   stop (  \"The genome version has to be specified!\" ) } }  if (   missing (  outfile ) )  { ## use the organism, genome version and ensembl version as the file name.   outfile -   paste0 (   c (  organism ,  genomeVersion ,  version ,  \"sqlite\" ) , collapse =  \".\" )  if (   missing (  path ) )   path -  \".\"   dbname -   paste0 (  path ,   .Platform $ file.sep ,  outfile ) } else  {  if (  !   missing (  path ) )   warning (  \"outfile specified, thus I will discard the path argument.\" )   dbname -  outfile } ## that's quite some hack ## transcript biotype?  if (   any (    colnames (   mcols (  x ) ) ==  \"transcript_biotype\" ) )  {   txBiotypeCol -  \"transcript_biotype\" } else  { ## that's a little weird, but it seems that certain gtf files from Ensembl ## provide the transcript biotype in the element \"source\"   txBiotypeCol -  \"source\" }   con -   dbConnect (   dbDriver (  \"SQLite\" ) , dbname =  dbname )   on.exit (   dbDisconnect (  con ) ) ## ---------------------------- ## metadata table:  if (  verbose )  {   cat (  \"processing metadata...\" ) }   Metadata -   buildMetadata (  organism ,  version , host =  \"unknown\" , sourceFile =  \"GRanges object\" , genomeVersion =  genomeVersion )   dbWriteTable (  con , name =  \"metadata\" ,  Metadata , overwrite =  TRUE , row.names =  FALSE )  if (  verbose )   cat (  \"OK\\n\" ) ## ---------------------------- ## ## process genes ## we're lacking NCBI Entrezids and also the coord system, but these are not ## required columns anyway...  if (  verbose )  {   cat (  \"processing genes...\" ) } ## want to have: gene_id, gene_name, entrezid, gene_biotype, gene_seq_start, ##               gene_seq_end, seq_name, seq_strand, seq_coord_system.   reqCols -   c (  \"gene_id\" ,  \"gene_name\" ,  \"gene_biotype\" )  if (  !   any (   reqCols %in%   colnames (   mcols (  x ) ) ) )   stop (   paste0 (  \"One or more required fields are not defined in the submitted GRanges object! Need \" ,   paste (  reqCols , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%   colnames (   mcols (  x ) ) ] , collapse =  \",\" ) ,  \".\" ) )   genes -   as.data.frame (   x [    x $ type ==  \"gene\" ,  reqCols ] )   genes -   cbind (  genes , entrezid =   rep (  NA ,   nrow (  genes ) ) , seq_coord_system =   rep (  NA ,   nrow (  genes ) ) )     colnames (  genes ) [   1 :  5 ] -   c (  \"seq_name\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"width\" ,  \"seq_strand\" ) ## transforming seq_strand from +/- to +1, -1.   strand -   rep (  0L ,   nrow (  genes ) )    strand [    as.character (   genes $ seq_strand ) ==  \"+\" ] -  1L    strand [    as.character (   genes $ seq_strand ) ==  \"-\" ] -  -  1L    genes [ ,  \"seq_strand\" ] -  strand ## rearranging data.frame...   genes -   genes [ ,   c (  \"gene_id\" ,  \"gene_name\" ,  \"entrezid\" ,  \"gene_biotype\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ,  \"seq_coord_system\" ) ]   dbWriteTable (  con , name =  \"gene\" ,  genes , overwrite =  TRUE , row.names =  FALSE )  if (  verbose )  {   cat (  \"OK\\n\" ) } ## ---------------------------- ## ## process transcripts  if (  verbose )   cat (  \"processing transcripts...\" ) ## want to have: tx_id, tx_biotype, tx_seq_start, tx_seq_end, tx_cds_seq_start, ##               tx_cds_seq_end, gene_id   reqCols -   c (  \"transcript_id\" ,  \"gene_id\" ,  txBiotypeCol )  if (  !   any (   reqCols %in%   colnames (   mcols (  x ) ) ) )   stop (   paste0 (  \"One or more required fields are not defined in the submitted GRanges object! Need \" ,   paste (  reqCols , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%   colnames (   mcols (  x ) ) ] , collapse =  \",\" ) ,  \".\" ) )   tx -    as.data.frame (   x [    x $ type ==  \"transcript\" ,  reqCols ] ) [ ,  -   c (  1 ,  4 ,  5 ) ] ## process the CDS features to get the cds start and end of the transcript.   CDS -   as.data.frame (   x [    x $ type ==  \"CDS\" ,  \"transcript_id\" ] )   cdsStarts -   aggregate (   CDS [ ,  \"start\" ] , by =   list (   CDS $ transcript_id ) , FUN =  min , na.rm =  TRUE )   cdsEnds -   aggregate (   CDS [ ,  \"end\" ] , by =   list (   CDS $ transcript_id ) , FUN =  max , na.rm =  TRUE )   idx -   match (   cdsStarts [ ,  1 ] ,   tx $ transcript_id )   tx -   cbind (  tx , tx_cds_seq_start =   rep (  NA ,   nrow (  tx ) ) , tx_cds_seq_end =   rep (  NA ,   nrow (  tx ) ) )    tx [  idx ,  \"tx_cds_seq_start\" ] -   cdsStarts [ ,  2 ]    tx [  idx ,  \"tx_cds_seq_end\" ] -   cdsEnds [ ,  2 ]    colnames (  tx ) -   c (  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_id\" ,  \"gene_id\" ,  \"tx_biotype\" ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ) ## rearranging data.frame:   tx -   tx [ ,   c (  \"tx_id\" ,  \"tx_biotype\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ,  \"gene_id\" ) ] ## write the table.   dbWriteTable (  con , name =  \"tx\" ,  tx , overwrite =  TRUE , row.names =  FALSE )   rm (  tx )   rm (  CDS )   rm (  cdsStarts )   rm (  cdsEnds )  if (  verbose )  {   cat (  \"OK\\n\" ) } ## ---------------------------- ## ## process exons  if (  verbose )   cat (  \"processing exons...\" )   reqCols -   c (  \"exon_id\" ,  \"transcript_id\" ,  \"exon_number\" )  if (  !   any (   reqCols %in%   colnames (   mcols (  x ) ) ) )   stop (   paste0 (  \"One or more required fields are not defined in the submitted GRanges object! Need \" ,   paste (  reqCols , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%   colnames (   mcols (  x ) ) ] , collapse =  \",\" ) ,  \".\" ) )   exons -    as.data.frame (   x [    x $ type ==  \"exon\" ,  reqCols ] ) [ ,  -   c (  1 ,  4 ,  5 ) ] ## for table tx2exon we want to have: ##    tx_id, exon_id, exon_idx   t2e -   unique (   exons [ ,   c (  \"transcript_id\" ,  \"exon_id\" ,  \"exon_number\" ) ] )    colnames (  t2e ) -   c (  \"tx_id\" ,  \"exon_id\" ,  \"exon_idx\" ) ## for table exons we want to have: ##    exon_id, exon_seq_start, exon_seq_end   exons -   unique (   exons [ ,   c (  \"exon_id\" ,  \"start\" ,  \"end\" ) ] )    colnames (  exons ) -   c (  \"exon_id\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ## writing the tables.   dbWriteTable (  con , name =  \"exon\" ,  exons , overwrite =  TRUE , row.names =  FALSE )   dbWriteTable (  con , name =  \"tx2exon\" ,  t2e , overwrite =  TRUE , row.names =  FALSE )  if (  verbose )   cat (  \"OK\\n\" ) ## ---------------------------- ## ## process chromosomes  if (  verbose )   cat (  \"processing chromosomes...\" )  if (  fetchSeqinfo )  { ## problem is I don't have these available...   chroms -   data.frame ( seq_name =   unique (   as.character (   genes $ seq_name ) ) )   chroms -   cbind (  chroms , seq_length =   rep (  NA ,   nrow (  chroms ) ) , is_circular =   rep (  NA ,   nrow (  chroms ) ) )    rownames (  chroms ) -   chroms $ seq_name ## now trying to get the sequence lengths directly from Ensembl using internal ## functions from the GenomicFeatures package. I will use \"try\" to not break ## the call if no seqlengths are available.   seqlengths -   tryGetSeqinfoFromEnsembl (  organism ,  version , seqnames =   chroms $ seq_name , verbose =  verbose )  if (    nrow (  seqlengths ) undefined  0 )  {   seqlengths -   seqlengths [    seqlengths [ ,  \"name\" ] %in%   rownames (  chroms ) , ]    chroms [   seqlengths [ ,  \"name\" ] ,  \"seq_length\" ] -   seqlengths [ ,  \"length\" ] } } else  { ## have seqinfo available.   chroms -   data.frame ( seq_name =   seqnames (  Seqinfo ) , seq_length =   seqlengths (  Seqinfo ) , is_circular =   isCircular (  Seqinfo ) ) } ## write the table.   dbWriteTable (  con , name =  \"chromosome\" ,  chroms , overwrite =  TRUE , row.names =  FALSE )   rm (  genes )  if (  verbose )   cat (  \"OK\\n\" )  if (  verbose )   cat (  \"generating index...\" ) ## generating all indices...   dbGetQuery (  con ,  \"create index seq_name_idx on chromosome (seq_name);\" )   dbGetQuery (  con ,  \"create index gene_id_idx on gene (gene_id);\" )   dbGetQuery (  con ,  \"create index tx_id_idx on tx (tx_id);\" )   dbGetQuery (  con ,  \"create index exon_id_idx on exon (exon_id);\" )   dbGetQuery (  con ,  \"create index t2e_tx_id_idx on tx2exon (tx_id);\" )   dbGetQuery (  con ,  \"create index t2e_exon_id_idx on tx2exon (exon_id);\" )  if (  verbose )   cat (  \"OK\\n\" )  if (  verbose )   cat (  \"Verifying validity of the information in the database:\\n\" )   checkValidEnsDb (   EnsDb (  dbname ) , verbose =  verbose )   return (  dbname ) } ",
    "filename": "EnsDbFromGTF.txt"
  },
  "new_function": {
    "name": "ensDbFromGRanges",
    "representation": "ensDbFromGRanges",
    "parameters": "function ( x , outfile , path , organism , genomeVersion , version )",
    "body": "{  if (  !   is (  x ,  \"GRanges\" ) )   stop (  \"This method can only be called on GRanges objects!\" ) ## check for missing parameters  if (   missing (  organism ) )  {   stop (  \"The organism has to be specified (e.g. using organism=\\\"Homo_sapiens\\\")\" ) }  if (   missing (  version ) )  {   stop (  \"The Ensembl version has to be specified!\" ) } ## checking the seqinfo in the GRanges object...   Seqinfo -   seqinfo (  x )   fetchSeqinfo -  FALSE ## check if we've got some information...  if (   any (   is.na (   seqlengths (  Seqinfo ) ) ) )  {   fetchSeqinfo -  TRUE ## means we have to fetch the seqinfo ourselfs... }  if (   missing (  genomeVersion ) )  { ## is there a seqinfo in x that I could use???  if (  !  fetchSeqinfo )  {   genomeVersion -   unique (   genome (  Seqinfo ) )  if (    is.na (  genomeVersion ) |    length (  genomeVersion ) undefined  1 )  {   stop (   paste0 (  \"The genome version has to be specified as\" ,  \" it can not be extracted from the seqinfo!\" ) ) } } else  {   stop (  \"The genome version has to be specified!\" ) } }  if (   missing (  outfile ) )  { ## use the organism, genome version and ensembl version as the file name.   outfile -   paste0 (   c (  organism ,  genomeVersion ,  version ,  \"sqlite\" ) , collapse =  \".\" )  if (   missing (  path ) )   path -  \".\"   dbname -   paste0 (  path ,   .Platform $ file.sep ,  outfile ) } else  {  if (  !   missing (  path ) )   warning (  \"outfile specified, thus I will discard the path argument.\" )   dbname -  outfile } ## that's quite some hack ## transcript biotype?  if (   any (    colnames (   mcols (  x ) ) ==  \"transcript_biotype\" ) )  {   txBiotypeCol -  \"transcript_biotype\" } else  { ## that's a little weird, but it seems that certain gtf files from Ensembl ## provide the transcript biotype in the element \"source\"   txBiotypeCol -  \"source\" }   con -   dbConnect (   dbDriver (  \"SQLite\" ) , dbname =  dbname )   on.exit (   dbDisconnect (  con ) ) ## ---------------------------- ## metadata table:   message (  \"Processing metadata...\" , appendLF =  FALSE )   Metadata -   buildMetadata (  organism ,  version , host =  \"unknown\" , sourceFile =  \"GRanges object\" , genomeVersion =  genomeVersion )   dbWriteTable (  con , name =  \"metadata\" ,  Metadata , overwrite =  TRUE , row.names =  FALSE )   message (  \"OK\" ) ## Check if we've got column \"type\"  if (  !   any (    colnames (   mcols (  x ) ) ==  \"type\" ) )   stop (  \"The GRanges object lacks the required column 'type', sorry.\" )   gotTypes -   as.character (   unique (   x $ type ) )   gotColumns -   colnames (   mcols (  x ) ) ## ---------------------------- ## ## process genes ## we're lacking NCBI Entrezids and also the coord system, but these are not ## required columns anyway...   message (  \"Processing genes...\" ) ## want to have: gene_id, gene_name, entrezid, gene_biotype, gene_seq_start, ##               gene_seq_end, seq_name, seq_strand, seq_coord_system.   wouldBeNice -   c (  \"gene_id\" ,  \"gene_name\" ,  \"entrezid\" ,  \"gene_biotype\" )   dontHave -   wouldBeNice [  !  (   wouldBeNice %in%  gotColumns ) ]   haveGot -   wouldBeNice [   wouldBeNice %in%  gotColumns ] ## Just really require the gene_id...   reqCols -   c (  \"gene_id\" )  if (    length (  dontHave ) undefined  0 )  {   mess -   paste0 (  \" I'm missing column(s): \" ,   paste0 (   sQuote (  dontHave ) , collapse =  \",\" ) ,  \".\" )   warning (  mess ,  \" The corresponding database column(s) will be empty!\" ) }   message (  \" Attribute availability:\" , appendLF =  TRUE )  for  ( i in   1 :   length (  wouldBeNice ) )  {   message (  \"  o \" ,   wouldBeNice [  i ] ,  \"...\" ,   ifelse (   any (   gotColumns ==   wouldBeNice [  i ] ) , yes =  \" OK\" , no =  \" Nope\" ) ) }  if (  !   any (   reqCols %in%  haveGot ) )   stop (   paste0 (  \"One or more required fields are not defined in the\" ,  \" submitted GRanges object! Need \" ,   paste (   sQuote (  reqCols ) , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%  gotColumns ] , collapse =  \",\" ) ,  \".\" ) ) ## Now gets tricky; special case Ensembl  if (   any (   gotTypes ==  \"gene\" ) )  { ## All is fine.   genes -   as.data.frame (   x [    x $ type ==  \"gene\" ,  haveGot ] ) } else  { ## Well, have to split by gene_id and process...   genes -   split (   x [ ,  haveGot ] ,   x $ gene_id )   gnRanges -   unlist (   range (  genes ) )   gnMcol -   as.data.frame (   unique (   mcols (   unlist (  genes ) ) ) )   genes -   as.data.frame (  gnRanges ) ## Adding mcols again.   genes -   cbind (  genes ,   gnMcol [   match (   rownames (  genes ) ,   gnMcol $ gene_id ) , ] )   rm (  gnRanges )   rm (  gnMcol ) }    colnames (  genes ) -   c (  \"seq_name\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"width\" ,  \"seq_strand\" ,  haveGot ) ## Add missing cols...  if (    length (  dontHave ) undefined  0 )  {   cn -   colnames (  genes )  for  ( i in   1 :   length (  dontHave ) )  {   genes -   cbind (  genes ,   rep (  NA ,   nrow (  genes ) ) ) }    colnames (  genes ) -   c (  cn ,  dontHave ) }   genes -   cbind (  genes , seq_coord_system =   rep (  NA ,   nrow (  genes ) ) ) ## transforming seq_strand from +/- to +1, -1.   strand -   rep (  0L ,   nrow (  genes ) )    strand [    as.character (   genes $ seq_strand ) ==  \"+\" ] -  1L    strand [    as.character (   genes $ seq_strand ) ==  \"-\" ] -  -  1L    genes [ ,  \"seq_strand\" ] -  strand ## rearranging data.frame...   genes -   genes [ ,   c (  \"gene_id\" ,  \"gene_name\" ,  \"entrezid\" ,  \"gene_biotype\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ,  \"seq_coord_system\" ) ]   dbWriteTable (  con , name =  \"gene\" ,  genes , overwrite =  TRUE , row.names =  FALSE ) ## Done.   message (  \"OK\" ) ## ---------------------------- ## ## process transcripts   message (  \"Processing transcripts...\" , appendLF =  TRUE ) ## want to have: tx_id, tx_biotype, tx_seq_start, tx_seq_end, tx_cds_seq_start, ##               tx_cds_seq_end, gene_id   wouldBeNice -   c (  \"transcript_id\" ,  \"gene_id\" ,  txBiotypeCol )   dontHave -   wouldBeNice [  !  (   wouldBeNice %in%  gotColumns ) ]  if (    length (  dontHave ) undefined  0 )  {   mess -   paste0 (  \"I'm missing column(s): \" ,   paste0 (   sQuote (  dontHave ) , collapse =  \",\" ) ,  \".\" )   warning (  mess ,  \" The corresponding database columns will be empty!\" ) }   haveGot -   wouldBeNice [   wouldBeNice %in%  gotColumns ]   message (  \" Attribute availability:\" , appendLF =  TRUE )  for  ( i in   1 :   length (  wouldBeNice ) )  {   message (  \"  o \" ,   wouldBeNice [  i ] ,  \"...\" ,   ifelse (   any (   gotColumns ==   wouldBeNice [  i ] ) , yes =  \" OK\" , no =  \" Nope\" ) ) }   reqCols -   c (  \"transcript_id\" ,  \"gene_id\" )  if (  !   any (   reqCols %in%  gotColumns ) )   stop (   paste0 (  \"One or more required fields are not defined in\" ,  \" the submitted GRanges object! Need \" ,   paste (  reqCols , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%  gotColumns ] , collapse =  \",\" ) ,  \".\" ) )  if (   any (   gotTypes ==  \"transcript\" ) )  {   tx -   as.data.frame (   x [    x $ type ==  \"transcript\" ,  haveGot ] ) } else  {   tx -   split (   x [ ,  haveGot ] ,   x $ transcript_id )   txRanges -   unlist (   range (  tx ) )   txMcol -   as.data.frame (   unique (   mcols (   unlist (  tx ) ) ) )   tx -   as.data.frame (  txRanges )   tx -   cbind (  tx ,   txMcol [   match (   rownames (  tx ) ,   txMcol $ transcript_id ) , ] )   rm (  txRanges )   rm (  txMcol ) } ## Drop columns seqnames, width and strand   tx -   tx [ ,  -   c (  1 ,  4 ,  5 ) ] ## Add empty columns, eventually  if (    length (  dontHave ) undefined  0 )  {   cn -   colnames (  tx )  for  ( i in   1 :   length (  dontHave ) )  {   tx -   cbind (  tx ,   rep (  NA ,   nrow (  tx ) ) ) }    colnames (  tx ) -   c (  cn ,  dontHave ) } ## Add columns for UTR   tx -   cbind (  tx , tx_cds_seq_start =   rep (  NA ,   nrow (  tx ) ) , tx_cds_seq_end =   rep (  NA ,   nrow (  tx ) ) ) ## Process CDS...  if (   any (   gotTypes ==  \"CDS\" ) )  { ## Only do that if we've got type == \"CDS\"! ## process the CDS features to get the cds start and end of the transcript.   CDS -   as.data.frame (   x [    x $ type ==  \"CDS\" ,  \"transcript_id\" ] ) ##   startByTx -   split (   CDS $ start , f =   CDS $ transcript_id )   cdsStarts -   unlist (   lapply (  startByTx ,  function ( z )  {   return (   min (  z , na.rm =  TRUE ) ) } ) )   endByTx -   split (   CDS $ end , f =   CDS $ transcript_id )   cdsEnds -   unlist (   lapply (  endByTx ,  function ( z )  {   return (   max (  z , na.rm =  TRUE ) ) } ) )   idx -   match (   names (  cdsStarts ) ,   tx $ transcript_id )   areNas -   is.na (  idx )   idx -   idx [  !  areNas ]   cdsStarts -   cdsStarts [  !  areNas ]   cdsEnds -   cdsEnds [  !  areNas ]    tx [  idx ,  \"tx_cds_seq_start\" ] -  cdsStarts    tx [  idx ,  \"tx_cds_seq_end\" ] -  cdsEnds } else  {   mess -  \" I can't find type=='CDS'! The resulting database will lack CDS information!\"   message (  mess , appendLF =  TRUE )   warning (  mess ) }    colnames (  tx ) -   c (  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_id\" ,  \"gene_id\" ,  \"tx_biotype\" ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ) ## rearranging data.frame:   tx -   tx [ ,   c (  \"tx_id\" ,  \"tx_biotype\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ,  \"gene_id\" ) ] ## write the table.   dbWriteTable (  con , name =  \"tx\" ,  tx , overwrite =  TRUE , row.names =  FALSE )   rm (  tx )   rm (  CDS )   rm (  cdsStarts )   rm (  cdsEnds )   message (  \"OK\" ) ## ---------------------------- ## ## process exons   message (  \"Processing exons...\" , appendLF =  FALSE )   reqCols -   c (  \"exon_id\" ,  \"transcript_id\" ,  \"exon_number\" )  if (  !   any (   reqCols %in%  gotColumns ) )   stop (   paste0 (  \"One or more required fields are not defined in\" ,  \" the submitted GRanges object! Need \" ,   paste (  reqCols , collapse =  \",\" ) ,  \" but got only \" ,   paste (   reqCols [   reqCols %in%  gotColumns ] , collapse =  \",\" ) ,  \".\" ) )   exons -    as.data.frame (   x [    x $ type ==  \"exon\" ,  reqCols ] ) [ ,  -   c (  1 ,  4 ,  5 ) ] ## for table tx2exon we want to have: ##    tx_id, exon_id, exon_idx   t2e -   unique (   exons [ ,   c (  \"transcript_id\" ,  \"exon_id\" ,  \"exon_number\" ) ] )    colnames (  t2e ) -   c (  \"tx_id\" ,  \"exon_id\" ,  \"exon_idx\" ) ## Force exon_idx to be an integer!    t2e [ ,  \"exon_idx\" ] -   as.integer (   t2e [ ,  \"exon_idx\" ] ) ## Cross-check that we've got the corresponding tx_ids in the tx table! ## for table exons we want to have: ##    exon_id, exon_seq_start, exon_seq_end   exons -   unique (   exons [ ,   c (  \"exon_id\" ,  \"start\" ,  \"end\" ) ] )    colnames (  exons ) -   c (  \"exon_id\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ## writing the tables.   dbWriteTable (  con , name =  \"exon\" ,  exons , overwrite =  TRUE , row.names =  FALSE )   dbWriteTable (  con , name =  \"tx2exon\" ,  t2e , overwrite =  TRUE , row.names =  FALSE )   message (  \"OK\" ) ## ---------------------------- ## ## process chromosomes   message (  \"Processing chromosomes...\" , appendLF =  FALSE )  if (  fetchSeqinfo )  { ## problem is I don't have these available...   chroms -   data.frame ( seq_name =   unique (   as.character (   genes $ seq_name ) ) )   chroms -   cbind (  chroms , seq_length =   rep (  NA ,   nrow (  chroms ) ) , is_circular =   rep (  NA ,   nrow (  chroms ) ) )    rownames (  chroms ) -   chroms $ seq_name ## now trying to get the sequence lengths directly from Ensembl using internal ## functions from the GenomicFeatures package. I will use \"try\" to not break ## the call if no seqlengths are available.   seqlengths -   tryGetSeqinfoFromEnsembl (  organism ,  version , seqnames =   chroms $ seq_name )  if (    nrow (  seqlengths ) undefined  0 )  {   seqlengths -   seqlengths [    seqlengths [ ,  \"name\" ] %in%   rownames (  chroms ) , ]    chroms [   seqlengths [ ,  \"name\" ] ,  \"seq_length\" ] -   seqlengths [ ,  \"length\" ] } } else  { ## have seqinfo available.   chroms -   data.frame ( seq_name =   seqnames (  Seqinfo ) , seq_length =   seqlengths (  Seqinfo ) , is_circular =   isCircular (  Seqinfo ) ) } ## write the table.   dbWriteTable (  con , name =  \"chromosome\" ,  chroms , overwrite =  TRUE , row.names =  FALSE )   rm (  genes )   message (  \"OK\" )   message (  \"Generating index...\" , appendLF =  FALSE ) ## generating all indices...   dbGetQuery (  con ,  \"create index seq_name_idx on chromosome (seq_name);\" )   dbGetQuery (  con ,  \"create index gene_id_idx on gene (gene_id);\" )   dbGetQuery (  con ,  \"create index tx_id_idx on tx (tx_id);\" )   dbGetQuery (  con ,  \"create index exon_id_idx on exon (exon_id);\" )   dbGetQuery (  con ,  \"create index t2e_tx_id_idx on tx2exon (tx_id);\" )   dbGetQuery (  con ,  \"create index t2e_exon_id_idx on tx2exon (exon_id);\" )   message (  \"OK\" )   message (  \"  -------------\" )   message (  \"Verifying validity of the information in the database:\" )   checkValidEnsDb (   EnsDb (  dbname ) )   return (  dbname ) } ",
    "filename": "EnsDbFromGTF.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_3 ensembldb_release_3_4

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_3 ensembldb_release_3_4",
    "desc_release_old": "1.4.7",
    "desc_release_new": "1.6.2",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 5,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

listEnsDbs
SymbolFilter
returnFilterColumns
returnFilterColumns<-
useMySQL


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_4 ensembldb_release_3_5

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_4 ensembldb_release_3_5",
    "desc_release_old": "1.6.2",
    "desc_release_new": "2.0.4",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 14,
    "function_additions": 10,
    "parameter_removals": 10,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 14
}

##########
Functions Removed
##########

GenenameFilter
GRangesFilter
SymbolFilter
column
print
value
where
condition<-
value<-
start
end
strand
condition
buildQuery


##########
Functions Added
##########

listProteinColumns
UniprotDbFilter
UniprotMappingTypeFilter
OnlyCodingTxFilter
ProtDomIdFilter
supportedFilters
hasProteinData
proteins
listUniprotDbs
listUniprotMappingTypes


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "genes",
    "representation": "genes",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = listColumns ( x , \"gene\" ) , filter , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )   columns -   unique (   c (  columns ,  \"gene_id\" ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   filter -   setFeatureInGRangesFilter (  filter ,  \"gene\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   all (   order.by ==  \"\" ) )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"gene_seq_start\" ) )   order.by -   c (  order.by ,  \"gene_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   retColumns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ gene_seq_start , end =   Res $ gene_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ gene_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "genes",
    "representation": "genes",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = c ( listColumns ( x , \"gene\" ) , \"entrezid\" ) , filter = AnnotationFilterList ( ) , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )   columns -   cleanColumns (  x ,   unique (   c (  columns ,  \"gene_id\" ) ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"gene_seq_start\" ,  \"gene_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }   filter -   .processFilterParam (  filter ,  x )   filter -   setFeatureInGRangesFilter (  filter ,  \"gene\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   all (   order.by ==  \"\" ) )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"gene_seq_start\" ) )   order.by -   c (  order.by ,  \"gene_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type , startWith =  \"gene\" , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"gene_id\" )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (  \"Columns \" ,   paste0 (  \"'\" ,   retColumns [  notThere ] ,  \"'\" , collapse =  \", \" ) ,  \" not found in the database!\" )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns , drop =  FALSE ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"gene_seq_start\" ,  \"gene_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ gene_seq_start , end =   Res $ gene_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ gene_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "transcripts",
    "representation": "transcripts",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = listColumns ( x , \"tx\" ) , filter , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )   columns -   unique (   c (  columns ,  \"tx_id\" ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   filter -   setFeatureInGRangesFilter (  filter ,  \"tx\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   all (   order.by ==  \"\" ) )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"tx_seq_start\" ) )   order.by -   c (  order.by ,  \"tx_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   retColumns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ tx_seq_start , end =   Res $ tx_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ tx_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "transcripts",
    "representation": "transcripts",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = listColumns ( x , \"tx\" ) , filter = AnnotationFilterList ( ) , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )   columns -   cleanColumns (  x ,   unique (   c (  columns ,  \"tx_id\" ) ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }   filter -   .processFilterParam (  filter ,  x )   filter -   setFeatureInGRangesFilter (  filter ,  \"tx\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   all (   order.by ==  \"\" ) )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"tx_seq_start\" ) )   order.by -   c (  order.by ,  \"tx_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type , startWith =  \"tx\" , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"tx_id\" )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (  \"Columns \" ,   paste0 (  \"'\" ,   retColumns [  notThere ] ,  \"'\" , collapse =  \", \" ) ,  \" not found in the database!\" )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns , drop =  FALSE ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ tx_seq_start , end =   Res $ tx_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ tx_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "exons",
    "representation": "exons",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = listColumns ( x , \"exon\" ) , filter , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )  if (  !   any (   columns %in%   c (   listColumns (  x ,  \"exon\" ) ,  \"exon_idx\" ) ) )  { ## have to have at least one column from the gene table...   columns -   c (  columns ,  \"exon_id\" ) }   columns -   unique (   c (  columns ,  \"exon_id\" ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"exon_seq_start\" ,  \"exon_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   filter -   setFeatureInGRangesFilter (  filter ,  \"exon\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   order.by ==  \"\" )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"exon_seq_start\" ) )   order.by -   c (  order.by ,  \"exon_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   retColumns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ exon_seq_start , end =   Res $ exon_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ exon_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "exons",
    "representation": "exons",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = listColumns ( x , \"exon\" ) , filter = AnnotationFilterList ( ) , order.by = \"\" , order.type = \"asc\" , return.type = \"GRanges\" )",
    "body": "{   return.type -   match.arg (  return.type ,   c (  \"data.frame\" ,  \"GRanges\" ,  \"DataFrame\" ) )  if (  !   any (   columns %in%   c (   listColumns (  x ,  \"exon\" ) ,  \"exon_idx\" ) ) )  { ## have to have at least one column from the gene table...   columns -   c (  columns ,  \"exon_id\" ) }   columns -   cleanColumns (  x ,   unique (   c (  columns ,  \"exon_id\" ) ) ) ## if return.type is GRanges we require columns: seq_name, gene_seq_start ## and gene_seq_end and seq_strand  if (   return.type ==  \"GRanges\" )  {   columns -   unique (   c (  columns ,   c (  \"exon_seq_start\" ,  \"exon_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ) ) ) }   filter -   .processFilterParam (  filter ,  x )   filter -   setFeatureInGRangesFilter (  filter ,  \"exon\" ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   retColumns -  columns ## If we don't have an order.by define one.  if (   order.by ==  \"\" )  {   order.by -  NULL  if (   any (   columns ==  \"seq_name\" ) )   order.by -   c (  order.by ,  \"seq_name\" )  if (   any (   columns ==  \"exon_seq_start\" ) )   order.by -   c (  order.by ,  \"exon_seq_start\" )  if (   is.null (  order.by ) )   order.by -  \"\" }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , order.type =  order.type , startWith =  \"exon\" , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"exon_id\" )  if (    return.type ==  \"data.frame\" |   return.type ==  \"DataFrame\" )  {   notThere -  !  (   retColumns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (  \"Columns \" ,   paste0 (  \"'\" ,   retColumns [  notThere ] ,  \"'\" , collapse =  \", \" ) ,  \" not found in the database!\" )   retColumns -   retColumns [  !  notThere ]   Res -   Res [ ,  retColumns , drop =  FALSE ]  if (   return.type ==  \"DataFrame\" )   Res -   DataFrame (  Res )   return (  Res ) }  if (   return.type ==  \"GRanges\" )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   metacols -   columns [  !  (   columns %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ]   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , ranges =   IRanges ( start =   Res $ exon_seq_start , end =   Res $ exon_seq_end ) , strand =   Rle (   Res $ seq_strand ) , seqinfo =   SI [   as.character (   unique (   Res $ seq_name ) ) ] ,   Res [ ,  metacols , drop =  FALSE ] )    names (  GR ) -   Res $ exon_id   return (  GR ) } } ",
    "filename": "Methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "exonsBy",
    "representation": "exonsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"tx\" , \"gene\" ) , columns = listColumns ( x , \"exon\" ) , filter , use.names = FALSE )",
    "body": "{   by -   match.arg (  by ,   c (  \"tx\" ,  \"gene\" ) )   bySuff -  \"_id\"  if (  use.names )  {  if (   by ==  \"tx\" )  {   use.names -  FALSE   warning (  \"Argument use.names ignored as no transcript names are available.\" ) } else  {   columns -   unique (   c (  columns ,  \"gene_name\" ) )   bySuff -  \"_name\" } }  if (   missing (  filter ) )  {   filter -   list ( ) } else  {   filter -   checkFilter (  filter ) } ## We're applying eventual GRangesFilter to either gene or tx.   filter -   setFeatureInGRangesFilter (  filter ,  by ) ## Eventually add columns for the filters:   columns -   unique (   c (  columns ,  \"exon_id\" ) )   columns -   addFilterColumns (  columns ,  filter ,  x ) ## Quick fix; rename any exon_rank to exon_idx.    columns [   columns ==  \"exon_rank\" ] -  \"exon_idx\" ## The minimum columns we need, in addition to \"columns\"   min.columns -   c (   paste0 (  by ,  \"_id\" ) ,  \"seq_name\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ,  \"exon_id\" ,  \"seq_strand\" )   by.id.full -   unlist (   prefixColumns (  x , columns =   paste0 (  by ,  \"_id\" ) , clean =  FALSE ) , use.names =  FALSE )  if (   by ==  \"gene\" )  { ## tx columns have to be removed, since the same exon can be part of ## more than one tx   txcolumns -   c (   listColumns (  x ,  \"tx\" ) ,  \"exon_idx\" )   txcolumns -   txcolumns [   txcolumns !=  \"gene_id\" ]   torem -   columns %in%  txcolumns  if (   any (  torem ) )   warning (  \"Columns \" ,   paste (   columns [  torem ] , collapse =  \",\" ) ,  \" have been removed as they are not allowed if exons\" ,  \" are fetched by gene.\" )   columns -   columns [  !  torem ] } else  {   min.columns -   unique (   c (  min.columns ,  \"exon_idx\" ) )   columns -   c (  columns ,  \"exon_idx\" ) } ## define the minimal columns that we need...   ret_cols -   unique (  columns ) ## before adding the \"min.columns\"   columns -   unique (   c (  columns ,  min.columns ) ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) ) ## Resolve ordering problems.   orderR -   orderResultsInR (  x )  if (  orderR )  {   order.by -  \"\" } else  {  if (   by ==  \"gene\" )  {   order.by -   paste0 (  \"gene.gene_id, \" ,  \"case when seq_strand = 1 then exon_seq_start\" ,  \" when seq_strand = -1 then (exon_seq_end * -1)\" ,  \" end\" ) } else  { ## Funny thing is the query takes longer if I use tx2exon.tx_id!   order.by -  \"tx.tx_id, tx2exon.exon_idx\" } }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , skip.order.check =  TRUE ) ## Now, order in R, if not already done in SQL.  if (  orderR )  {  if (   by ==  \"gene\" )  {   startend -    (    Res $ seq_strand ==  1 ) *   Res $ exon_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ exon_seq_end *  -  1 )   Res -   Res [   order (   Res $ gene_id ,  startend , method =  \"radix\" ) , ] } else  {   Res -   Res [   order (   Res $ tx_id ,   Res $ exon_idx , method =  \"radix\" ) , ] } }   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## replace exon_idx with exon_rank     colnames (  Res ) [    colnames (  Res ) ==  \"exon_idx\" ] -  \"exon_rank\"    columns [   columns ==  \"exon_idx\" ] -  \"exon_rank\"    ret_cols [   ret_cols ==  \"exon_idx\" ] -  \"exon_rank\"   notThere -  !  (   ret_cols %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   ret_cols [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   ret_cols -   ret_cols [  !  notThere ]   columns.metadata -   ret_cols [  !  (   ret_cols %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ]   columns.metadata -   match (  columns.metadata ,   colnames (  Res ) )   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =   Res $ exon_seq_start , end =   Res $ exon_seq_end ) , seqinfo =  SI ,   Res [ ,  columns.metadata , drop =  FALSE ] )   return (   split (  GR ,   Res [ ,   paste0 (  by ,  bySuff ) ] ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "exonsBy",
    "representation": "exonsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"tx\" , \"gene\" ) , columns = listColumns ( x , \"exon\" ) , filter = AnnotationFilterList ( ) , use.names = FALSE )",
    "body": "{   by -   match.arg (  by ,   c (  \"tx\" ,  \"gene\" ) )   bySuff -  \"_id\"  if (  use.names )  {  if (   by ==  \"tx\" )  {   use.names -  FALSE   warning (  \"Argument use.names ignored as no transcript names are available.\" ) } else  {   columns -   unique (   c (  columns ,  \"gene_name\" ) )   bySuff -  \"_name\" } }   filter -   .processFilterParam (  filter ,  x ) ## We're applying eventual GRangesFilter to either gene or tx.   filter -   setFeatureInGRangesFilter (  filter ,  by ) ## Eventually add columns for the filters:   columns -   cleanColumns (  x ,   unique (   c (  columns ,  \"exon_id\" ) ) )   columns -   addFilterColumns (  columns ,  filter ,  x ) ## Quick fix; rename any exon_rank to exon_idx.    columns [   columns ==  \"exon_rank\" ] -  \"exon_idx\" ## The minimum columns we need, in addition to \"columns\"   min.columns -   c (   paste0 (  by ,  \"_id\" ) ,  \"seq_name\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ,  \"exon_id\" ,  \"seq_strand\" )   by.id.full -   unlist (   prefixColumns (  x , columns =   paste0 (  by ,  \"_id\" ) , clean =  FALSE ) , use.names =  FALSE )  if (   by ==  \"gene\" )  { ## tx columns have to be removed, since the same exon can be part of ## more than one tx   txcolumns -   c (   listColumns (  x ,  \"tx\" ) ,  \"exon_idx\" )   txcolumns -   txcolumns [   txcolumns !=  \"gene_id\" ]   torem -   columns %in%  txcolumns  if (   any (  torem ) )   warning (  \"Columns \" ,   paste (   columns [  torem ] , collapse =  \",\" ) ,  \" have been removed as they are not allowed if exons\" ,  \" are fetched by gene.\" )   columns -   columns [  !  torem ] } else  {   min.columns -   unique (   c (  min.columns ,  \"exon_idx\" ) )   columns -   c (  columns ,  \"exon_idx\" ) } ## define the minimal columns that we need...   ret_cols -   unique (  columns ) ## before adding the \"min.columns\"   columns -   unique (   c (  columns ,  min.columns ) ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) ) ## Resolve ordering problems.   orderR -   orderResultsInR (  x )  if (  orderR )  {   order.by -  \"\" } else  {  if (   by ==  \"gene\" )  {   order.by -   paste0 (  \"gene.gene_id, \" ,  \"case when seq_strand = 1 then exon_seq_start\" ,  \" when seq_strand = -1 then (exon_seq_end * -1)\" ,  \" end\" ) } else  { ## Funny thing is the query takes longer if I use tx2exon.tx_id!   order.by -  \"tx.tx_id, tx2exon.exon_idx\" } }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , skip.order.check =  TRUE , startWith =  by , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"exon_id\" ) ## Now, order in R, if not already done in SQL.  if (  orderR )  {  if (   by ==  \"gene\" )  {   startend -    (    Res $ seq_strand ==  1 ) *   Res $ exon_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ exon_seq_end *  -  1 )   Res -   Res [   order (   Res $ gene_id ,  startend , method =  \"radix\" ) , ] } else  {   Res -   Res [   order (   Res $ tx_id ,   Res $ exon_idx , method =  \"radix\" ) , ] } }   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## replace exon_idx with exon_rank     colnames (  Res ) [    colnames (  Res ) ==  \"exon_idx\" ] -  \"exon_rank\"    columns [   columns ==  \"exon_idx\" ] -  \"exon_rank\"    ret_cols [   ret_cols ==  \"exon_idx\" ] -  \"exon_rank\"   notThere -  !  (   ret_cols %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (  \"Columns \" ,   paste0 (  \"'\" ,   ret_cols [  notThere ] ,  \"'\" , collapse =  \", \" ) ,  \" not found in the database!\" )   ret_cols -   ret_cols [  !  notThere ]   columns.metadata -   ret_cols [  !  (   ret_cols %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ]   columns.metadata -   match (  columns.metadata ,   colnames (  Res ) )   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =   Res $ exon_seq_start , end =   Res $ exon_seq_end ) , seqinfo =  SI ,   Res [ ,  columns.metadata , drop =  FALSE ] )   return (   split (  GR ,   Res [ ,   paste0 (  by ,  bySuff ) ] ) ) } ",
    "filename": "Methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "transcriptsBy",
    "representation": "transcriptsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"gene\" , \"exon\" ) , columns = listColumns ( x , \"tx\" ) , filter )",
    "body": "{  if (   any (   by ==  \"cds\" ) )   stop (  \"fetching transcripts by cds is not (yet) implemented.\" )   by -   match.arg (  by ,   c (  \"gene\" ,  \"exon\" ) )   byId -   paste0 (  by ,  \"_id\" )   min.columns -   c (   paste0 (  by ,  \"_id\" ) ,  \"seq_name\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_id\" ,  \"seq_strand\" ) ## can not have exon columns!   ex_cols -   c (   listColumns (  x ,  \"exon\" ) ,  \"exon_idx\" )   ex_cols -   ex_cols [   ex_cols !=  \"tx_id\" ]   torem -   columns %in%  ex_cols  if (   any (  torem ) )   warning (  \"Columns \" ,   paste (   columns [  torem ] , collapse =  \",\" ) ,  \" have been removed as they are not allowed if\" ,  \" transcripts are fetched.\" )   columns -   columns [  !  torem ] ## Process filters  if (   missing (  filter ) )  {   filter -   list ( ) } else  {   filter -   checkFilter (  filter ) } ## GRanges filter should be based on either gene or exon coors.   filter -   setFeatureInGRangesFilter (  filter ,  by ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   ret_cols -   unique (  columns ) ## define the minimal columns that we need...   columns -   unique (   c (  columns ,  min.columns ) ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) )   byIdFull -   unlist (   prefixColumns (  x , columns =  byId , clean =  FALSE ) , use.names =  FALSE )   orderR -   orderResultsInR (  x )  if (  orderR )  {   order.by -  \"\" } else  {   order.by -   paste0 (  byIdFull ,  \", case when seq_strand = 1 then tx_seq_start\" ,  \" when seq_strand = -1 then (tx_seq_end * -1) end\" ) }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , skip.order.check =  TRUE )  if (  orderR )  {   startEnd -    (    Res $ seq_strand ==  1 ) *   Res $ tx_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ tx_seq_end *  -  1 )   Res -   Res [   order (   Res [ ,  byId ] ,  startEnd , method =  \"radix\" ) , ] }   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## Replace exon_idx with exon_rank    colnames (  Res ) -   gsub (   colnames (  Res ) , pattern =  \"exon_idx\" , replacement =  \"exon_rank\" , fixed =  TRUE )    ret_cols [   ret_cols ==  \"exon_idx\" ] -  \"exon_rank\"   notThere -  !  (   ret_cols %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   ret_cols [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   ret_cols -   ret_cols [  !  notThere ]   columns.metadata -   ret_cols [  !  (   ret_cols %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ) ) ]   columns.metadata -   match (  columns.metadata ,   colnames (  Res ) ) ## presumably faster...   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =   Res $ tx_seq_start , end =   Res $ tx_seq_end ) , seqinfo =  SI ,   Res [ ,  columns.metadata , drop =  FALSE ] )   return (   split (  GR ,   Res [ ,  byId ] ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "transcriptsBy",
    "representation": "transcriptsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"gene\" , \"exon\" ) , columns = listColumns ( x , \"tx\" ) , filter = AnnotationFilterList ( ) )",
    "body": "{  if (   any (   by ==  \"cds\" ) )   stop (  \"fetching transcripts by cds is not (yet) implemented.\" )   by -   match.arg (  by ,   c (  \"gene\" ,  \"exon\" ) )   byId -   paste0 (  by ,  \"_id\" )   min.columns -   c (   paste0 (  by ,  \"_id\" ) ,  \"seq_name\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ,  \"tx_id\" ,  \"seq_strand\" ) ## can not have exon columns!   ex_cols -   c (   listColumns (  x ,  \"exon\" ) ,  \"exon_idx\" )   ex_cols -   ex_cols [   ex_cols !=  \"tx_id\" ]   torem -   columns %in%  ex_cols  if (   any (  torem ) )   warning (  \"Columns \" ,   paste (   columns [  torem ] , collapse =  \",\" ) ,  \" have been removed as they are not allowed if\" ,  \" transcripts are fetched.\" )   columns -   columns [  !  torem ] ## Process filters   filter -   .processFilterParam (  filter ,  x ) ## GRanges filter should be based on either gene or exon coors.   filter -   setFeatureInGRangesFilter (  filter ,  by ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x )   ret_cols -   unique (  columns ) ## define the minimal columns that we need...   columns -   cleanColumns (  x ,   unique (   c (  columns ,  min.columns ) ) ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) )   byIdFull -   unlist (   prefixColumns (  x , columns =  byId , clean =  FALSE ) , use.names =  FALSE )   orderR -   orderResultsInR (  x )  if (  orderR )  {   order.by -  \"\" } else  {   order.by -   paste0 (  byIdFull ,  \", case when seq_strand = 1 then tx_seq_start\" ,  \" when seq_strand = -1 then (tx_seq_end * -1) end\" ) }   Res -   getWhat (  x , columns =  columns , filter =  filter , order.by =  order.by , skip.order.check =  TRUE , startWith =  by , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"tx_id\" )  if (  orderR )  {   startEnd -    (    Res $ seq_strand ==  1 ) *   Res $ tx_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ tx_seq_end *  -  1 )   Res -   Res [   order (   Res [ ,  byId ] ,  startEnd , method =  \"radix\" ) , ] }   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## Replace exon_idx with exon_rank    colnames (  Res ) -   gsub (   colnames (  Res ) , pattern =  \"exon_idx\" , replacement =  \"exon_rank\" , fixed =  TRUE )    ret_cols [   ret_cols ==  \"exon_idx\" ] -  \"exon_rank\"   notThere -  !  (   ret_cols %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (  \"Columns \" ,   paste0 (  \"'\" ,   ret_cols [  notThere ] ,  \"'\" , collapse =  \", \" ) ,  \" not found in the database!\" )   ret_cols -   ret_cols [  !  notThere ]   columns.metadata -   ret_cols [  !  (   ret_cols %in%   c (  \"seq_name\" ,  \"seq_strand\" ,  \"tx_seq_start\" ,  \"tx_seq_end\" ) ) ]   columns.metadata -   match (  columns.metadata ,   colnames (  Res ) )   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =   Res $ tx_seq_start , end =   Res $ tx_seq_end ) , seqinfo =  SI ,   Res [ ,  columns.metadata , drop =  FALSE ] )   return (   split (  GR ,   Res [ ,  byId ] ) ) } ",
    "filename": "Methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "cdsBy",
    "representation": "cdsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"tx\" , \"gene\" ) , columns = NULL , filter , use.names = FALSE )",
    "body": "{   by -   match.arg (  by ,   c (  \"tx\" ,  \"gene\" ) )  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   filter -   setFeatureInGRangesFilter (  filter ,  by ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x ) ## Add a filter ensuring that only coding transcripts are queried.   filter -   c (   list (   OnlyCodingTx ( ) ) ,  filter )   bySuff -  \"_id\"  if (   by ==  \"tx\" )  { ## adding exon_id, exon_idx to the columns.   columns -   unique (   c (  columns ,  \"exon_id\" ,  \"exon_idx\" ) )  if (  use.names )   warning (  \"Not considering use.names as no transcript names are available.\" ) } else  {   columns -   unique (   c (  \"gene_id\" ,  columns ) )  if (  use.names )  {   bySuff -  \"_name\"   columns -   c (  columns ,  \"gene_name\" ) } }   byId -   paste0 (  by ,  bySuff ) ## Query the data   fetchCols -   unique (   c (  byId ,  columns ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ,  \"exon_idx\" ,  \"exon_id\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ## Ordering of the results: ## Force ordering in R by default here to fix issue #11 ##orderR   orderR -  TRUE  if (  orderR )  {   order.by -  \"\" } else  {  if (   by ==  \"tx\" )  { ## Here we want to sort the exons by exon_idx   order.by -  \"tx.tx_id, tx2exon.exon_idx\" } else  { ## Here we want to sort the transcripts by tx start.   order.by -  \"gene.gene_id, case when seq_strand = 1 then tx_cds_seq_start when seq_strand = -1 then (tx_cds_seq_end * -1) end\" } }   Res -   getWhat (  x , columns =  fetchCols , filter =  filter , order.by =  order.by , skip.order.check =  TRUE ) ## Remove rows with NA in tx_cds_seq_start; that's the case for \"old\" databases.   nas -   is.na (   Res $ tx_cds_seq_start )  if (   any (  nas ) )   Res -   Res [  !  nas , ] ## Remove exons that are not within the cds.   Res -   Res [     Res $ exon_seq_end =   Res $ tx_cds_seq_start undefined    Res $ exon_seq_start =   Res $ tx_cds_seq_end , , drop =  FALSE ]  if (  orderR )  { ## And finally ordering them.  if (   by ==  \"tx\" )  {   Res -   Res [   order (   Res $ tx_id ,   Res $ exon_idx , method =  \"radix\" ) , ] } else  {   startend -    (    Res $ seq_strand ==  1 ) *   Res $ tx_cds_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ tx_cds_seq_end *  -  1 )   Res -   Res [   order (   Res $ gene_id ,  startend , method =  \"radix\" ) , ] } }  if (    nrow (  Res ) ==  0 )  {   warning (  \"No cds found!\" )   return (  NULL ) }   cdsStarts -   pmax.int (   Res $ exon_seq_start ,   Res $ tx_cds_seq_start )   cdsEnds -   pmin.int (   Res $ exon_seq_end ,   Res $ tx_cds_seq_end ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## Rename columns exon_idx to exon_rank, if present  if (   any (    colnames (  Res ) ==  \"exon_idx\" ) )  {     colnames (  Res ) [    colnames (  Res ) ==  \"exon_idx\" ] -  \"exon_rank\"    columns [   columns ==  \"exon_idx\" ] -  \"exon_rank\" } ## Building the result.  if (    length (  columns ) undefined  0 )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =  cdsStarts , end =  cdsEnds ) , seqinfo =  SI ,   Res [ ,  columns , drop =  FALSE ] ) } else  {   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =  cdsStarts , end =  cdsEnds ) , seqinfo =  SI ) }   GR -   split (  GR ,   Res [ ,   paste0 (  by ,  bySuff ) ] ) ## For \"by gene\" we reduce the redundant ranges; ## that way we loose however all additional columns!  if (   by ==  \"gene\" )   GR -   reduce (  GR )   return (  GR ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "cdsBy",
    "representation": "cdsBy",
    "signature": "EnsDb",
    "parameters": "function ( x , by = c ( \"tx\" , \"gene\" ) , columns = NULL , filter = AnnotationFilterList ( ) , use.names = FALSE )",
    "body": "{   by -   match.arg (  by ,   c (  \"tx\" ,  \"gene\" ) )   filter -   .processFilterParam (  filter ,  x )   filter -   setFeatureInGRangesFilter (  filter ,  by )   columns -   cleanColumns (  x ,  columns ) ## Eventually add columns for the filters:   columns -   addFilterColumns (  columns ,  filter ,  x ) ## Add a filter ensuring that only coding transcripts are queried.   filter -   AnnotationFilterList (   OnlyCodingTxFilter ( ) ,  filter )   bySuff -  \"_id\"  if (   by ==  \"tx\" )  { ## adding exon_id, exon_idx to the columns.   columns -   unique (   c (  columns ,  \"exon_id\" ,  \"exon_idx\" ) )  if (  use.names )   warning (  \"Not considering use.names as no transcript names are\" ,  \" available.\" ) } else  {   columns -   unique (   c (  \"gene_id\" ,  columns ) )  if (  use.names )  {   bySuff -  \"_name\"   columns -   c (  columns ,  \"gene_name\" ) } }   byId -   paste0 (  by ,  bySuff ) ## Query the data   fetchCols -   unique (   c (  byId ,  columns ,  \"tx_cds_seq_start\" ,  \"tx_cds_seq_end\" ,  \"seq_name\" ,  \"seq_strand\" ,  \"exon_idx\" ,  \"exon_id\" ,  \"exon_seq_start\" ,  \"exon_seq_end\" ) ) ## Ordering of the results: ## Force ordering in R by default here to fix issue #11 ##orderR   orderR -  TRUE  if (  orderR )  {   order.by -  \"\" } else  {  if (   by ==  \"tx\" )  { ## Here we want to sort the exons by exon_idx   order.by -  \"tx.tx_id, tx2exon.exon_idx\" } else  { ## Here we want to sort the transcripts by tx start.   order.by -   paste0 (  \"gene.gene_id, case when seq_strand = 1 then\" ,  \" tx_cds_seq_start when seq_strand = -1 then\" ,  \"(tx_cds_seq_end * -1) end\" ) } }   Res -   getWhat (  x , columns =  fetchCols , filter =  filter , order.by =  order.by , skip.order.check =  TRUE , startWith =  by , join =  \"suggested\" ) ## issue #48: collapse entrezid column if dbschema 2.0 is used.  if (     as.numeric (   dbSchemaVersion (  x ) ) undefined  1 undefined   any (   columns ==  \"entrezid\" ) )   Res -   .collapseEntrezidInTable (  Res , by =  \"exon_id\" ) ## Remove rows with NA in tx_cds_seq_start; that's the case for \"old\" ## databases.   nas -   is.na (   Res $ tx_cds_seq_start )  if (   any (  nas ) )   Res -   Res [  !  nas , ] ## Remove exons that are not within the cds.   Res -   Res [     Res $ exon_seq_end =   Res $ tx_cds_seq_start undefined    Res $ exon_seq_start =   Res $ tx_cds_seq_end , , drop =  FALSE ]  if (  orderR )  { ## And finally ordering them.  if (   by ==  \"tx\" )  {   Res -   Res [   order (   Res $ tx_id ,   Res $ exon_idx , method =  \"radix\" ) , ] } else  {   startend -    (    Res $ seq_strand ==  1 ) *   Res $ tx_cds_seq_start +   (    Res $ seq_strand ==  -  1 ) *  (    Res $ tx_cds_seq_end *  -  1 )   Res -   Res [   order (   Res $ gene_id ,  startend , method =  \"radix\" ) , ] } }  if (    nrow (  Res ) ==  0 )  {   warning (  \"No cds found!\" )   return (  NULL ) }   cdsStarts -   pmax.int (   Res $ exon_seq_start ,   Res $ tx_cds_seq_start )   cdsEnds -   pmin.int (   Res $ exon_seq_end ,   Res $ tx_cds_seq_end ) ## get the seqinfo:   suppressWarnings (   SI -   seqinfo (  x ) )   SI -   SI [   as.character (   unique (   Res $ seq_name ) ) ] ## Rename columns exon_idx to exon_rank, if present  if (   any (    colnames (  Res ) ==  \"exon_idx\" ) )  {     colnames (  Res ) [    colnames (  Res ) ==  \"exon_idx\" ] -  \"exon_rank\"    columns [   columns ==  \"exon_idx\" ] -  \"exon_rank\" } ## Building the result.  if (    length (  columns ) undefined  0 )  {   notThere -  !  (   columns %in%   colnames (  Res ) )  if (   any (  notThere ) )   warning (   paste0 (  \"Columns \" ,   paste (   columns [  notThere ] , collapse =  \", \" ) ,  \" not present in the result data.frame!\" ) )   columns -   columns [  !  notThere ]   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =  cdsStarts , end =  cdsEnds ) , seqinfo =  SI ,   Res [ ,  columns , drop =  FALSE ] ) } else  {   GR -   GRanges ( seqnames =   Rle (   Res $ seq_name ) , strand =   Rle (   Res $ seq_strand ) , ranges =   IRanges ( start =  cdsStarts , end =  cdsEnds ) , seqinfo =  SI ) }   GR -   split (  GR ,   Res [ ,   paste0 (  by ,  bySuff ) ] ) ## For \"by gene\" we reduce the redundant ranges; ## that way we loose however all additional columns!  if (   by ==  \"gene\" )   GR -   reduce (  GR )   return (  GR ) } ",
    "filename": "Methods.txt"
  }
}

6.
{
  "old_function": {
    "name": "threeUTRsByTranscript",
    "representation": "threeUTRsByTranscript",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = NULL , filter )",
    "body": "{  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   return (   getUTRsByTranscript ( x =  x , what =  \"three\" , columns =  columns , filter =  filter ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "threeUTRsByTranscript",
    "representation": "threeUTRsByTranscript",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = NULL , filter = AnnotationFilterList ( ) )",
    "body": "{   filter -   .processFilterParam (  filter ,  x )   getUTRsByTranscript ( x =  x , what =  \"three\" , columns =  columns , filter =  filter ) } ",
    "filename": "Methods.txt"
  }
}

7.
{
  "old_function": {
    "name": "fiveUTRsByTranscript",
    "representation": "fiveUTRsByTranscript",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = NULL , filter )",
    "body": "{  if (   missing (  filter ) )  {   filter =   list ( ) } else  {   filter -   checkFilter (  filter ) }   return (   getUTRsByTranscript ( x =  x , what =  \"five\" , columns =  columns , filter =  filter ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "fiveUTRsByTranscript",
    "representation": "fiveUTRsByTranscript",
    "signature": "EnsDb",
    "parameters": "function ( x , columns = NULL , filter = AnnotationFilterList ( ) )",
    "body": "{   filter -   .processFilterParam (  filter ,  x )   getUTRsByTranscript ( x =  x , what =  \"five\" , columns =  columns , filter =  filter ) } ",
    "filename": "Methods.txt"
  }
}

8.
{
  "old_function": {
    "name": "transcriptsByOverlaps",
    "representation": "transcriptsByOverlaps",
    "signature": "EnsDb",
    "parameters": "function ( x , ranges , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" ) , columns = listColumns ( x , \"tx\" ) , filter )",
    "body": "{  if (   missing (  ranges ) )   stop (  \"Parameter 'ranges' is missing!\" )  if (   missing (  filter ) )  {   filter -   list ( ) } else  {   filter -   checkFilter (  filter ) }   SLs -   unique (   as.character (   seqnames (  ranges ) ) )   filter -   c (  filter ,   SeqnameFilter (  SLs ) )   return (   subsetByOverlaps (   transcripts (  x , columns =  columns , filter =  filter ) ,  ranges , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "transcriptsByOverlaps",
    "representation": "transcriptsByOverlaps",
    "signature": "EnsDb",
    "parameters": "function ( x , ranges , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" ) , columns = listColumns ( x , \"tx\" ) , filter = AnnotationFilterList ( ) )",
    "body": "{  if (   missing (  ranges ) )   stop (  \"Parameter 'ranges' is missing!\" )   filter -   .processFilterParam (  filter ,  x )   SLs -   unique (   as.character (   seqnames (  ranges ) ) )   filter -   AnnotationFilterList (  filter ,   SeqNameFilter (  SLs ) )   columns -   cleanColumns (  x ,  columns )   subsetByOverlaps (   transcripts (  x , columns =  columns , filter =  filter ) ,  ranges , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) } ",
    "filename": "Methods.txt"
  }
}

9.
{
  "old_function": {
    "name": "exonsByOverlaps",
    "representation": "exonsByOverlaps",
    "signature": "EnsDb",
    "parameters": "function ( x , ranges , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" ) , columns = listColumns ( x , \"exon\" ) , filter )",
    "body": "{  if (   missing (  ranges ) )   stop (  \"Parameter 'ranges' is missing!\" )  if (   missing (  filter ) )  {   filter -   list ( ) } else  {   filter -   checkFilter (  filter ) }   SLs -   unique (   as.character (   seqnames (  ranges ) ) )   filter -   c (  filter ,   SeqnameFilter (  SLs ) )   return (   subsetByOverlaps (   exons (  x , columns =  columns , filter =  filter ) ,  ranges , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) ) } ",
    "filename": "Methods.txt"
  },
  "new_function": {
    "name": "exonsByOverlaps",
    "representation": "exonsByOverlaps",
    "signature": "EnsDb",
    "parameters": "function ( x , ranges , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" ) , columns = listColumns ( x , \"exon\" ) , filter = AnnotationFilterList ( ) )",
    "body": "{  if (   missing (  ranges ) )   stop (  \"Parameter 'ranges' is missing!\" )   filter -   .processFilterParam (  filter ,  x )   SLs -   unique (   as.character (   seqnames (  ranges ) ) )   filter -   AnnotationFilterList (  filter ,   SeqNameFilter (  SLs ) )   columns -   cleanColumns (  x ,  columns )   subsetByOverlaps (   exons (  x , columns =  columns , filter =  filter ) ,  ranges , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) } ",
    "filename": "Methods.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_5 ensembldb_release_3_6

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_5 ensembldb_release_3_6",
    "desc_release_old": "2.0.4",
    "desc_release_new": "2.2.2",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

filter
TxSupportLevelFilter
convertFilter
addFilter
activeFilter
dropFilter


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_6 ensembldb_release_3_7

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_6 ensembldb_release_3_7",
    "desc_release_old": "2.2.2",
    "desc_release_new": "2.4.1",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 10,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

proteinToGenome
proteinToTranscript
genomeToTranscript
transcriptToProtein
genomeToProtein
transcriptToGenome
transcriptToCds
cdsToTranscript
ProteinDomainIdFilter
ProteinDomainSourceFilter


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_7 ensembldb_release_3_8

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_7 ensembldb_release_3_8",
    "desc_release_old": "2.4.1",
    "desc_release_new": "2.6.8",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

intronsByTranscript


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_8 ensembldb_release_3_9

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_8 ensembldb_release_3_9",
    "desc_release_old": "2.6.8",
    "desc_release_new": "2.8.1",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

getGenomeTwoBitFile


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_9 ensembldb_release_3_11

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_9 ensembldb_release_3_11",
    "desc_release_old": "2.8.1",
    "desc_release_new": "2.12.1",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_11 ensembldb_release_3_12

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_11 ensembldb_release_3_12",
    "desc_release_old": "2.12.1",
    "desc_release_new": "2.14.1",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_12 ensembldb_release_3_13

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_12 ensembldb_release_3_13",
    "desc_release_old": "2.14.1",
    "desc_release_new": "2.16.4",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_13 ensembldb_release_3_14

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_13 ensembldb_release_3_14",
    "desc_release_old": "2.16.4",
    "desc_release_new": "2.18.3",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  ensembldb_release_3_14 ensembldb_master

{
    "package": "ensembldb",
    "release_versions": "ensembldb_release_3_14 ensembldb_master",
    "desc_release_old": "2.18.3",
    "desc_release_new": "2.19.8",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

TxExternalNameFilter
TxIsCanonicalFilter


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

