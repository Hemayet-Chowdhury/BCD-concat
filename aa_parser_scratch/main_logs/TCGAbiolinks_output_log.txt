
###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_2 tcgabiolinks_release_3_3

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_2 tcgabiolinks_release_3_3",
    "desc_release_old": "1.0.10",
    "desc_release_new": "2.0.13",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 6,
    "function_additions": 10,
    "parameter_removals": 2,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 7,
    "total_count": 13
}

##########
Functions Removed
##########

TCGAanalyze_copynumber
TCGAquery_Investigate
TCGAquery_Social
TCGAquery_Version
TCGAquery_integrate
TCGAquery_samplesfilter


##########
Functions Added
##########

GDCdownload
GDCprepare
GDCprepare_clinic
GDCquery
GDCquery_Maf
GDCquery_clinic
TCGAanalyze_analyseGRN
TCGAvisualize_oncoprint
getGDCprojects
isServeOK


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "TCGAprepare",
    "representation": "TCGAprepare",
    "parameters": "function ( query , dir = NULL , samples = NULL , type = NULL , save = FALSE , filename = NULL , add.mutation.genes = FALSE , reannotate = FALSE , summarizedExperiment = TRUE , add.subtype = FALSE )",
    "body": "{  if (   is.null (  dir ) )  {   message (  \"Argument dir is NULL. Plese provide the directory\r\n                with the folders to be prepared. \" )   return (  NULL ) }  if (     length (   unique (   query $ Platform ) ) undefined  1 |    length (   unique (   query $ Center ) ) undefined  2 )  { # This case (27k/450k)accepts two platforms  if (   all (   grepl (  \"HumanMethylation[0-9]{2,3}\" ,   unique (   query $ Platform ) ) ) )  {   platform -  \"humanMethylation\" } else  {   message (  \"Sorry! But, for the moment, we can only prepare on type of\r\n                    platform per call\" )   return (  NULL ) } } else  {   platform -   unique (   query $ Platform ) } # Get all files from directory except MANIFEST, README, etc   files -  NULL   dirs -   gsub (  \".tar.gz\" ,  \"\" ,   basename (   query $ deployLocation ) )  for  ( i in   seq_along (  dirs ) )  {   aux -   list.files (   file.path (  dir ,   dirs [  i ] ) , full.names =  TRUE , recursive =  TRUE )   files -   c (  files ,  aux ) }   idx -   grep (  \"MANIFEST|README|CHANGES|DESCRIPTION|DATA_USE\" ,  files )  if (    length (  idx ) undefined  0 )  {   files -   files [  -  idx ] } # Filter by samples  if (  !   is.null (  samples ) )  {   files -   filterFiles (   query [  i , ] ,  samples ,  files )  if (    length (  files ) ==  0 )  {   message (  \"No files for that samples found\" )   return (  NULL ) } }   pb -   txtProgressBar ( min =  0 , max =   length (  files ) , style =  3 )   df -  NULL   rse -  NULL  if (   grepl (  \"humanmethylation\" ,   tolower (  platform ) ) )  {   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , skip =  1 , colClasses =   c (  \"character\" , # Composite Element REF  \"numeric\" , # beta value  \"character\" , # Gene symbol  \"character\" , # Chromosome  \"integer\" ) ) # Genomic coordinate   setnames (  data ,   gsub (  \" \" ,  \"\\\\.\" ,   colnames (  data ) ) )   setnames (  data ,  2 ,   barcode [  i ] )  if (   i ==  1 )  {   setcolorder (  data ,   c (  1 ,   3 :  5 ,  2 ) )   df -  data } else  {   data -   subset (  data , select =   c (  1 ,  2 ) )   df -   merge (  df ,  data , by =  \"Composite.Element.REF\" ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {   gene.GR -   GRanges ( seqnames =   paste0 (  \"chr\" ,   gene.location $ chromosome_name ) , ranges =   IRanges ( start =   gene.location $ start_position , end =   gene.location $ end_position ) , strand =   gene.location $ strand , symbol =   gene.location $ external_gene_name , EntrezID =   gene.location $ entrezgene )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   df $ Chromosome ) , ranges =   IRanges ( start =   df $ Genomic_Coordinate , end =   df $ Genomic_Coordinate ) , probeID =   df $ Composite.Element.REF , Gene_Symbol =   df $ Gene_Symbol )    names (  rowRanges ) -   as.character (   df $ Composite.Element.REF )   colData -   colDataPrepare (    colnames (  df ) [   5 :   ncol (  df ) ] ,  query , add.subtype =  add.subtype )   assay -   data.matrix (   subset (  df , select =   c (   5 :   ncol (  df ) ) ) )  if (  reannotate )  {   message (  \"Reannotating genes Source:http://grch37.ensembl.org/\" )   gene.location -   gene.location [    gene.location $ chromosome_name %in%   c (   1 :  22 ,  \"X\" ,  \"Y\" ) , ]   gene.location -   gene.location [  !   is.na (   gene.location $ entrezgene ) , ]   gene.location -   gene.location [  !   duplicated (   gene.location $ entrezgene ) , ]   gene.GR -   GRanges ( seqnames =   paste0 (  \"chr\" ,   gene.location $ chromosome_name ) , ranges =   IRanges ( start =   gene.location $ start_position , end =   gene.location $ end_position ) , strand =   gene.location $ strand , symbol =   gene.location $ external_gene_name , EntrezID =   gene.location $ entrezgene )   probe.info -  rowRanges   distance -   as.data.frame (   distanceToNearest (  rowRanges ,  gene.GR ) )   gene.order.by.distance -   gene.location [   distance $ subjectHits , ]    gene.order.by.distance $ distance -   as.matrix (   distance $ distance )    rowRanges $ distance -   gene.order.by.distance [ ,   c (  \"distance\" ) ]    rowRanges $ Gene_Symbol -   gene.order.by.distance [ ,   c (  \"external_gene_name\" ) ]    rowRanges $ entrezgene -   gene.order.by.distance [ ,   c (  \"entrezgene\" ) ] }   rse -   SummarizedExperiment ( assays =  assay , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df $ Composite.Element.REF    df $ Composite.Element.REF -  NULL } }  if (   grepl (  \"mda_rppa_core\" ,   tolower (  platform ) ) )  {   message (   paste (  \"Sorry, but for this platform we haven't prepared\" ,  \"the data into a summarizedExperiment object.\" ,  \"\\nBut we will do it soon! The return is a data frame\" ) )   regex -   paste0 (  \"[:alnum:]{8}-[:alnum:]{4}\" ,  \"-[:alnum:]{4}-[:alnum:]{4}-[:alnum:]{12}\" )   uuid -   str_match (  files ,  regex )   map -   mapuuidbarcode (  uuid )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , data.table =  FALSE )   data -   data [  -  1 , ] # removing Composite Element REF   x -   subset (  map ,   uuid ==   uuid [  i ] )     colnames (  data ) [  2 ] -   as.character (   x $ barcode )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =  \"Sample REF\" , all =  TRUE ) }   setTxtProgressBar (  pb ,  i ) }    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL }  if (   grepl (  \"illuminaga_dnaseq\" ,   tolower (  platform ) ) )  {   message (   paste (  \"Sorry, but for this platform we haven't prepared\" ,  \"the data into a summarizedExperiment object.\" ,  \"\\nBut we will do it soon! The return is a data frame of the maf file\" ) )   idx -   grep (  \"maf\" ,  files )  if (    length (  idx ) ==  0 )  {   message (  \"Sorry, we are preparing only maf files\" )   return (  NULL ) }   files -   files [  idx ]  for  ( i in   seq_along (  files ) )  {   data -   read.table (   files [  i ] , fill =  TRUE , comment.char =  \"#\" , header =  TRUE , sep =  \"\\t\" , quote =  \"\" ) # some center has different ways to name the collums   idx.pos -   grep (  \"Start_position\" ,   colnames (  data ) )     colnames (  data ) [  idx.pos ] -  \"Start_Position\"   idx.pos -   grep (  \"End_position\" ,   colnames (  data ) )     colnames (  data ) [  idx.pos ] -  \"End_Position\"  if (   i ==  1 )  {   df -  data } else  {   df -   plyr :: rbind.fill (  df ,  data ) }   setTxtProgressBar (  pb ,  i ) } }  if (   grepl (  \"illuminadnamethylation_oma\" ,  platform , ignore.case =  TRUE ) )  {  for  ( i in   seq_along (  files ) )  {   data -   read.table (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , check.names =  FALSE , comment.char =  \"#\" , fill =  TRUE )   data -   data [  -  1 , ] # removing Composite Element REF  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =  \"Hybridization REF\" ) }   setTxtProgressBar (  pb ,  i ) }    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL }  if (     tolower (  platform ) ==  \"illuminaga_rnaseq\" ||    tolower (  platform ) ==  \"illuminahiseq_rnaseq\" )  {  if (    is.null (  type ) ||  (     type !=  \"exon.quantification\" undefined   type !=  \"spljxn.quantification\" undefined   type !=  \"gene.quantification\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = gene.quantification\\n\" ,  \" = spljxn.quantification\\n\" ,  \" = exon.quantification\\n\" )   message (  msg )   return ( ) }   files -   files [   grep (  type ,  files ) ] # Barcode in the name   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   setnames (  data ,    colnames (  data ) [   2 :   ncol (  data ) ] ,   paste0 (    colnames (  data ) [   2 :   ncol (  data ) ] ,  \"_\" ,   barcode [  i ] ) ) # removing duplicated rows   data -   subset (  data , subset =  (  !   duplicated (   data [ ,  1 , with =  FALSE ] ) ) )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data ,    colnames (  data ) [  1 ] ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {  if (   grepl (  \"gene\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ gene ,  \"\\\\|\" )   GeneID -   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) )    df $ entrezgene -   as.numeric (  GeneID )   merged -   merge (  df ,  gene.location , by =  \"entrezgene\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene )    names (  rowRanges ) -   as.character (   merged $ gene )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   ncol (  df ) ,  3 ) ) ) , median_length_normalized =   data.matrix (   subset (  merged , select =   seq (  4 ,   ncol (  df ) ,  3 ) ) ) , RPKM =   data.matrix (   subset (  merged , select =   seq (  5 ,   ncol (  df ) ,  3 ) ) ) ) } else  if (   grepl (  \"junction\" ,    colnames (  df ) [  1 ] ) )  { # junction example: chr1:12227:+,chr1:12595:+   aux -   strsplit (   df $ junction ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   x -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) )   y -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  4 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  5 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ junction )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   2 :   ncol (  df ) ) ) ) } else  if (   grepl (  \"exon\" ,    colnames (  df ) [  1 ] ) )  { # exon chr1:11874-12227:+   aux -   strsplit (   df $ exon ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   start.end -   strsplit (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) ,  \"-\" )   x -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  1 ] ) ) )   y -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  2 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  3 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ exon )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   seq (  2 ,   ncol (  df ) ,  3 ) ) ) , median_length_normalized =   data.matrix (   subset (  df , select =   seq (  3 ,   ncol (  df ) ,  3 ) ) ) , RPKM =   data.matrix (   subset (  df , select =   seq (  4 ,   ncol (  df ) ,  3 ) ) ) ) }   colData -   colDataPrepare (   as.character (  barcode ) ,  query , add.subtype =  add.subtype )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL } }  if (    tolower (  platform ) ==   tolower (  \"HT_HG-U133A\" ) )  { # Barcode in the mage file  if (   is.vector (  query ) )  {   mage -   getMage (  query ) } else  {   mage -   getMage (   query [  1 , ] ) }  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , skip =  1 , stringsAsFactors =  FALSE , data.table =  FALSE )  if (   i ==  1 )  {   df -  data } else  {   df -   cbind (  df ,   data [ ,  2 ] ) }   setTxtProgressBar (  pb ,  i ) }   names -   sapply (  files ,  function ( x )  {   y -    fread (  x , header =  FALSE , stringsAsFactors =  FALSE , nrows =  1 ) $ V2   idx -   grep (  y ,   mage $ Hybridization.Name )    mage [  idx , ] $ Comment..TCGA.Barcode. } )   setnames (  df ,   2 :   ncol (  df ) ,  names )  if (  summarizedExperiment )  { # TODO create GRanges #df$external_gene_name    df $ external_gene_name -   df $ `Composite Element REF`   merged -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene , alias =   merged $ `Composite Element REF` )    names (  rowRanges ) -   as.character (   merged $ `Composite Element REF` )   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  merged ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   2 +   length (  barcode ) ) ) ) )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } }  if (     tolower (  platform ) ==   tolower (  \"HG-U133_Plus_2\" ) ||   grepl (  \"H-miRNA_8x15K|agilent\" ,  platform , ignore.case =  TRUE ) )  {  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data ,    colnames (  data ) [  1 ] ) } #setTxtProgressBar(pb, i) }   df -   df [  -  1 , ]  if (  summarizedExperiment )  {   message (  \"===================================================================================\" )   message (  \" As we can't map some miRNA to genomic positions this step might loose some rows .\" )   message (  \" Please, for all rows run TCGAprepare with summarizedExperiment=F\" )   message (  \"====================================================================================\" )  if (   grepl (  \"HG-U133_Plus_2|agilent\" ,  platform , ignore.case =  TRUE ) )  {   suppressWarnings (    df $ external_gene_name -   alias2SymbolTable (   df $ `Hybridization REF` ) )   merged -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene , alias =   merged $ `Hybridization REF` )    names (  rowRanges ) -   as.character (   merged $ `Hybridization REF` ) } else  {   microRNA -   as.data.frame (   microRNAs (  TxDb.Hsapiens.UCSC.hg19.knownGene ) )    df $ mirna_id -   tolower (   df $ `Hybridization REF` )   merged -   merge (  df ,  microRNA , by =  \"mirna_id\" )   rowRanges -   GRanges ( seqnames =   merged $ seqnames , ranges =   IRanges ( start =   merged $ start , end =   merged $ end ) , strand =   merged $ strand , mirna_id =   merged $ mirna_id )    names (  rowRanges ) -   as.character (   merged $ mirna_id ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  merged ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   suppressWarnings (   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   2 +   length (  barcode ) ) ) ) ) )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   df -   as.data.frame (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL   df -   data.matrix (  df ) } }  if (   grepl (  \"rnaseqv2\" ,  platform , ignore.case =  TRUE ) )  {  if (    is.null (  type ) ||  (        type !=  \"rsem.genes.results\" undefined   type !=  \"rsem.isoforms.results\" undefined   type !=  \"rsem.genes.normalized_results\" undefined   type !=  \"rsem.isoforms.normalized_results\" undefined   type !=  \"bt.exon_quantification\" undefined   type !=  \"junction_quantification\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = rsem.genes.results\\n\" ,  \" = rsem.isoforms.results\\n\" ,  \" = rsem.genes.normalized_results\\n\" ,  \" = rsem.isoforms.normalized_results\\n\" ,  \" = bt.exon_quantification\\n\" ,  \" = junction_quantification\" )   message (  msg )   return ( ) }   files -   files [   grep (  type ,  files , perl =  TRUE ) ]   regex -   paste0 (  \"[:alnum:]{8}-[:alnum:]{4}\" ,  \"-[:alnum:]{4}-[:alnum:]{4}-[:alnum:]{12}\" )   uuid -   str_match (  files ,  regex )   map -   mapuuidbarcode (  uuid )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   x -   subset (  map ,   uuid ==   uuid [  i ] )  if (  summarizedExperiment )  {   setnames (  data ,    colnames (  data ) [   2 :   ncol (  data ) ] ,   paste0 (    colnames (  data ) [   2 :   ncol (  data ) ] ,  \"_\" ,   x $ barcode ) ) } else  {   setnames (  data ,  2 ,   as.character (   x $ barcode ) ) }  if (   i ==  1 )  {   df -  data } else  {   df -   cbind (  df ,   data [ ,   2 :   ncol (  data ) , with =  FALSE ] ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {  if (   grepl (  \"gene_id\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ gene_id ,  \"\\\\|\" )   GeneID -   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) )    df $ entrezid -   as.numeric (  GeneID )   GeneSymbol -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )    df $ external_gene_name -   as.character (  GeneSymbol )   df -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   df $ chromosome_name ) , ranges =   IRanges ( start =   df $ start_position , end =   df $ end_position ) , strand =   df $ strand , gene_id =   df $ external_gene_name , entrezgene =   df $ entrezid , transcript_id =   subset (  df , select =  5 ) )    names (  rowRanges ) -   as.character (   df $ gene_id )  if (    length (   colnames (  data ) ) undefined  2 )  {   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   grep (  \"raw_count\" ,   colnames (  df ) ) ) ) , scaled_estimate =   data.matrix (   subset (  df , select =   grep (  \"scaled_estimate\" ,   colnames (  df ) ) ) ) ) } else  { # case genes.normalized_results   assays -   SimpleList ( normalized_count =   data.matrix (   subset (  df , select =   grep (  \"normalized_count\" ,   colnames (  df ) ) ) ) ) } } else  if (   grepl (  \"junction\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ junction ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   x -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) )   y -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  4 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  5 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ junction )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   2 :   ncol (  df ) ) ) ) } else  if (   grepl (  \"exon\" ,    colnames (  df ) [  1 ] ) )  { # exon chr1:11874-12227:+   aux -   strsplit (   df $ exon ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   start.end -   strsplit (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) ,  \"-\" )   x -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  1 ] ) ) )   y -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  2 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  3 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ exon )   assays -   SimpleList ( raw_counts =   data.matrix (   df [ ,   grep (  \"raw_count\" ,   colnames (  df ) ) , with =  FALSE ] ) , median_length_normalized =   data.matrix (   df [ ,   grep (  \"median_length\" ,   colnames (  df ) ) , with =  FALSE ] ) , RPKM =   data.matrix (   df [ ,   grep (  \"RPKM\" ,   colnames (  df ) ) , with =  FALSE ] ) ) } else  if (   grepl (  \"isoform\" ,    colnames (  df ) [  1 ] ) )  {   message (  \"TBD\" )   return (  NULL ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  df ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL } }  if (   grepl (  \"illuminahiseq_mirnaseq\" ,  platform , ignore.case =  TRUE ) )  {  if (    is.null (  type ) ||  (    type !=  \"hg19.mirna\" undefined   type !=  \"mirna\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = hg19.mirna\\n = mirna\" )   message (  msg )   return ( ) }  if (   type ==  \"hg19.mirna\" )   pat -  \"(hg19.)mirna\"  if (   type ==  \"mirna\" )   pat -  \"(?   files -   files [   grep (  pat ,  files , perl =  TRUE ) ]  if (    length (  files ) ==  0 )  {   message (  \"No mirna files of that type found\" )   return (  NULL ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   data -   subset (  data , select =   c (   1 :  3 ) )   setnames (  data ,   2 :   ncol (  data ) ,   paste0 (   as.character (   barcode [  i ] ) ,  \".\" ,    colnames (  data ) [   2 :   ncol (  data ) ] ) )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =    colnames (  data ) [  1 ] ) } }   setDF (  df )    rownames (  df ) -   df [ ,  1 ]   df -   df [ ,  -  1 ] }  if (   grepl (  \"bio\" ,  platform , ignore.case =  TRUE ) )  {  if (  !   is.null (  type ) )  {   files -   files [   grep (  type ,  files ) ] }  if (    length (  files ) ==  1 )  {   df -   read.table (  files , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , check.names =  FALSE , comment.char =  \"#\" , fill =  TRUE , quote =  \"\" )   regex -   paste0 (  \"[[:alnum:]]{8}-[[:alnum:]]{4}\" ,  \"-[[:alnum:]]{4}-[[:alnum:]]{4}-[[:alnum:]]{12}\" )  if (   grepl (  \"clinical\" ,  type ) )    colnames (  df ) -   df [  1 , ]   idx -   grepl (  regex ,   df $ bcr_patient_uuid )   df -   df [  idx , ] } else  {   message (  \"We're preaparing for the moment only one clinical file\" )   return (  NULL ) } }  if (   grepl (  \"genome_wide_snp_6\" ,   tolower (  platform ) ) )  {  while (  !  (   type %in%   c (  \"nocnv_hg18\" ,  \"nocnv_hg19\" ,  \"cnv_hg18\" ,  \"cnv_hg19\" ,  \"nocnv_hg18.seg\" ,  \"hg18.seg\" ,  \"hg19.seg\" ,  \"nocnv_hg19.seg\" ) ) )  {   type -   readline (   paste (  \"Which type do you want?\" ,  \"(Options: nocnv_hg19,nocnv_hg18,cnv_hg18,cnv_hg19, cancel)  \" ) )  if (   type ==  \"cancel\" )   return (  NULL ) }  if (    type ==  \"nocnv_hg18\" |   type ==  \"nocnv_hg18.seg\" )   regex -  \"nocnv_hg18\"  if (    type ==  \"cnv_hg18\" |   type ==  \"hg18.seg\" )   regex -  \"[^nocnv_]hg18.seg\"  if (    type ==  \"nocnv_hg19\" |   type ==  \"nocnv_hg19.seg\" )   regex -  \"nocnv_hg19\"  if (    type ==  \"cnv_hg19\" |   type ==  \"hg19.seg\" )   regex -  \"[^nocnv_]hg19.seg\"   files -   files [   grep (  regex ,  files ) ]  if (    length (  files ) ==  0 )  {   message (  \"No files of that type found\" )   return (  NULL ) }   idx -   grep (  regex ,  files )  if (    length (  idx ) undefined  0 )  {   files -   files [  idx ] } else  {   message (  \"No files of that type found\" )   return (  NULL ) }  if (   is.vector (  query ) )  {   mage -   getMage (  query ) } else  {   mage -   getMage (   query [  1 , ] ) }  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , data.table =  FALSE , colClasses =   c (  \"character\" , # ID  \"character\" , # chrom  \"numeric\" , # start  \"numeric\" , # end  \"integer\" , # num_probes  \"numeric\" ) ) # seg mean  if (   i ==  1 )   df -  data  if (   i !=  1 )   df -   rbind (  df ,  data , make.row.names =  FALSE )   setTxtProgressBar (  pb ,  i ) }   mage -   mage [ ,   c (  \"Comment..TCGA.Barcode.\" ,  \"Hybridization.Name\" ) ]   df -   merge (  df ,  mage , by.x =  \"Sample\" , by.y =  \"Hybridization.Name\" , sort =  FALSE )    df [ ,  1 ] -   df [ ,  7 ]    df [ ,  7 ] -  NULL }   close (  pb )  if (  !   is.null (  rse ) )  {   message (  \"Adding metadata to the rse object...\" )   finf -   c ( )   finf -   file.info (  files )    rownames (  finf ) -   basename (   rownames (  finf ) )   finf -   finf [ ,   c (  \"mtime\" ,  \"ctime\" ) ]    metadata (  rse ) -   list ( \"Query:\" =   list (  query ) , \"TCGAprepareParameters\" =   c ( \"dir\" =  dir , \"samples\" =  samples , \"type\" =  type , \"save\" =  save , \"add.mutation.genes\" =  add.mutation.genes , \"filename\" =  filename ) , \"FilesInfo:\" =   list (  finf ) ) }  if (   add.mutation.genes undefined  summarizedExperiment )  {    colData (  rse ) -   DataFrame (   mutation.genes (   unique (   query $ Disease ) ,   colData (  rse ) ) ) }  if (  save )  {   message (  \"Saving the data...\" )  if (   is.null (  filename ) )  {   filename -   paste0 (  platform ,  \"_\" ,   gsub (  \" \" ,  \"_\" ,   Sys.time ( ) ) ,  \".rda\" ) }  if (  !   is.null (  rse ) )  {   save (  rse , file =  filename ) } else  {   save (  df , file =  filename ) }   message (   paste (  \"Data saved in:\" ,  filename ) ) }  if (  !   is.null (  rse ) )  {   return (  rse ) }   return (  df ) } ",
    "filename": "TCGAPrepare.txt"
  },
  "new_function": {
    "name": "TCGAprepare",
    "representation": "TCGAprepare",
    "parameters": "function ( query = NULL , dir = NULL , samples = NULL , type = NULL , save = FALSE , filename = NULL , summarizedExperiment = TRUE )",
    "body": "{   stop (  \"TCGA data has moved from DCC server to GDC server. Please use GDCprepare function\" ) } ",
    "filename": "TCGAPrepare.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( cancer , DFfilt , DFclin , DFsubt , data_Hc2 , cbPalette , filename = NULL )",
    "body": "{    rownames (  DFsubt ) -   DFsubt $ patient    rownames (  DFclin ) -   DFclin $ patient    rownames (  DFfilt ) -   substr (   rownames (  DFfilt ) ,  1 ,  12 )   ans -   hclust (   ddist -   dist (  DFfilt ) , method =  \"ward.D2\" )   hhc -    data_Hc2 [[  4 ] ] $ consensusTree   consensusClusters -    data_Hc2 [[  4 ] ] $ consensusClass   sampleOrder -   consensusClusters [   hhc $ order ]   consensusClusters -   as.factor (     data_Hc2 [[  4 ] ] $ clrs [[  1 ] ] )    names (  consensusClusters ) -   attr (  ddist ,  \"Labels\" )    names (  consensusClusters ) -   substr (   names (  consensusClusters ) ,  1 ,  12 ) #DFclin   DFclin_merged -   cbind (  DFclin ,   matrix (  0 ,   nrow (  DFclin ) ,   ncol (  DFsubt ) ) )     colnames (  DFclin_merged ) [   (   (    ncol (  DFclin_merged ) -   ncol (  DFsubt ) ) +  1 ) :   ncol (  DFclin_merged ) ] -   colnames (  DFsubt )    rownames (  DFclin_merged ) -   DFclin_merged $ bcr_patient_barcode  for  ( i in   1 :   ncol (  DFsubt ) )  {    DFsubt [ ,  i ] -   as.character (   DFsubt [ ,  i ] ) }  for  ( i in   1 :   nrow (  DFsubt ) )  {   curSample -    DFsubt $ patient [  i ]  for  ( j in   1 :   ncol (  DFsubt ) )  {   curColumn -    colnames (  DFsubt ) [  j ]    DFclin_merged [  curSample ,  curColumn ] -   DFsubt [  curSample ,  curColumn ] } } # adding information about gropus from consensus Cluster in clinical data   DFclin_merged -   cbind (  DFclin_merged , groupsHC =   matrix (  0 ,   nrow (  DFclin_merged ) ,  1 ) )    rownames (  DFclin_merged ) -   DFclin_merged $ bcr_patient_barcode  for  ( i in   1 :   nrow (  DFclin_merged ) )  {   currSmp -    DFclin_merged $ bcr_patient_barcode [  i ]    DFclin_merged [  currSmp ,  \"groupsHC\" ] -   as.character (   consensusClusters [  currSmp ] ) }   groupsColors -   levels (   as.factor (   DFclin_merged $ groupsHC ) )  for  ( j in   1 :   length (   table (   DFclin_merged $ groupsHC ) ) )  {   curCol -   groupsColors [  j ]    DFclin_merged [    DFclin_merged $ groupsHC ==  curCol ,  \"groupsHC\" ] -   paste0 (  \"EC\" ,  j ) }   DFfilt -   DFfilt [   rownames (  DFclin_merged ) , ]   orderCL -   as.character (   substr (   names (  sampleOrder ) ,  1 ,  12 ) )   orderCL -   intersect (  orderCL ,   rownames (  DFfilt ) )   GE -   t (   .quantileNormalization (   t (  DFfilt ) ) )    rownames (  GE ) -   substr (   rownames (  GE ) ,  1 ,  12 )   oGE -   GE [  orderCL , ] #ordering according cluster   DFclin_merged -   DFclin_merged [  orderCL , ] # histology   HISTOLOGY -   DFclin_merged [ ,  \"histological_type\" ]    names (  HISTOLOGY ) -   rownames (  DFclin_merged )   HISTOLOGY -   HISTOLOGY [   rownames (  GE ) ]   HISTOLOGY.col -   rep (  \"white\" ,   length (  HISTOLOGY ) )    HISTOLOGY.col [   HISTOLOGY ==  \"Astrocytoma\" ] -  \"red\"    HISTOLOGY.col [   HISTOLOGY ==  \"glioblastoma\" ] -  \"purple\"    HISTOLOGY.col [   HISTOLOGY ==  \"Oligoastrocytoma\" ] -  \"cyan\"    HISTOLOGY.col [   HISTOLOGY ==  \"Oligodendroglioma\" ] -  \"green3\"    names (  HISTOLOGY.col ) -   names (  HISTOLOGY )   oHISTOLOGY.col -   HISTOLOGY.col [  orderCL ] #subtype   SUBTYPE -   DFclin_merged [ ,  \"IDH.1p19q.Subtype\" ]    names (  SUBTYPE ) -   rownames (  DFclin_merged )   SUBTYPE -   SUBTYPE [   rownames (  GE ) ]   SUBTYPE.col -   rep (  \"white\" ,   length (  SUBTYPE ) )    SUBTYPE.col [   SUBTYPE ==  \"IDHmut-codel\" ] -  \"cyan\"    SUBTYPE.col [   SUBTYPE ==  \"IDHmut-non-codel\" ] -  \"tomato\"    SUBTYPE.col [   SUBTYPE ==  \"IDHwt\" ] -  \"gold\"    names (  SUBTYPE.col ) -   names (  SUBTYPE )   oSUBTYPE.col -   SUBTYPE.col [  orderCL ] #clusters CNCluster   CNC -   DFclin_merged [ ,  \"CNCluster\" ]    names (  CNC ) -   rownames (  DFclin_merged )   CNC -   CNC [   rownames (  GE ) ]   CNC.col -   rep (  \"white\" ,   length (  CNC ) )    names (  CNC.col ) -   names (  CNC )    CNC.col [   CNC ==  \"C1\" ] -  \"green\"    CNC.col [   CNC ==  \"C2\" ] -  \"red\"    CNC.col [   CNC ==  \"C3\" ] -  \"purple\"   oCNC.col -   CNC.col [  orderCL ] #clusters COCluster   COC -   DFclin_merged [ ,  \"COCCluster\" ]    names (  COC ) -   rownames (  DFclin_merged )   COC -   COC [   rownames (  GE ) ]   COC.col -   rep (  \"white\" ,   length (  COC ) )    names (  COC.col ) -   names (  COC )    COC.col [   COC ==  \"coc1\" ] -  \"green\"    COC.col [   COC ==  \"coc2\" ] -  \"red\"    COC.col [   COC ==  \"coc3\" ] -  \"purple\"   oCOC.col -   COC.col [  orderCL ] #clusters ONCOluster   ONCO -   DFclin_merged [ ,  \"OncosignCluster\" ]    names (  ONCO ) -   rownames (  DFclin_merged )   ONCO -   ONCO [   rownames (  GE ) ]   ONCO.col -   rep (  \"white\" ,   length (  ONCO ) )    names (  ONCO.col ) -   names (  ONCO )    ONCO.col [   ONCO ==  \"OSC1\" ] -  \"green\"    ONCO.col [   ONCO ==  \"OSC2\" ] -  \"red\"    ONCO.col [   ONCO ==  \"OSC3\" ] -  \"purple\"    ONCO.col [   ONCO ==  \"OSC4\" ] -  \"orange\"    ONCO.col [   ONCO ==  \"Unclassified\" ] -  \"gray\"   oONCO.col -   ONCO.col [  orderCL ]   oConsensus -   as.character (   consensusClusters [   hhc $ order ] ) #oConsensus   names (   consensusClusters [   hhc $ order ] ) #source(\"heatmap.plus.R\")   cc.col -   matrix (   c (  oHISTOLOGY.col ,  oSUBTYPE.col ,  oCNC.col ,  oCOC.col ,  oONCO.col ,   as.character (  oConsensus ) ) , nrow =   nrow (  oGE ) , ncol =  6 )    colnames (  cc.col ) -   c (  \"Histology\" ,  \"Subtype\" ,  \"CNCluster\" ,  \"COCCluster\" ,  \"OncosignCluster\" ,  \"Expression Cluster\" )   cc.col -   as.data.frame (  cc.col )    rownames (  cc.col ) -  orderCL   cc.col -   cc.col [   order (   cc.col $ `Expression Cluster` ) , ]   cc.col -   as.matrix (  cc.col )   oGE -   oGE [   rownames (  cc.col ) , ]  if (  !  (   is.null (    dev.list ( ) [  \"RStudioGD\" ] ) ) )  {   dev.off ( ) }   curDate -   as.character (    unlist (   strsplit (   gsub (  \" \" ,  \"_h\" ,   gsub (  \"-\" ,  \"_\" ,   as.character (   Sys.time ( ) ) ) ) ,  \":\" ) ) [  1 ] )   pdf ( file =   paste0 (  curDate ,  \"_\" ,  cancer ,  \"_heatmap_with_subtypes_withHeatmapPlus.pdf\" ) )   .heatmap.plus.sm (   t (  oGE ) , na.rm =  TRUE , scale =  \"none\" , #RowSideColor=probe.cc, #ColSideColors=cc.col, col =   gplots :: greenred (  75 ) , key =  FALSE , #changed symkey =  FALSE , density.info =  \"none\" , trace =  \"none\" , Rowv =  FALSE , Colv =  NA , cexRow =  1 , cexCol =  1.6 , keysize =  2 , dendrogram =  \"none\" , main =  \"Heatmap from consensus cluster\" , labRow =  NA , labCol =  NA , #labCol=NA )   dev.off ( ) } ",
    "filename": "TCGAvisualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( data , col.metadata , row.metadata , col.colors = NULL , row.colors = NULL , show_column_names = FALSE , show_row_names = FALSE , cluster_rows = FALSE , cluster_columns = FALSE , sortCol , extrems = NULL , rownames.size = 12 , title = NULL , color.levels = NULL , values.label = NULL , filename = \"heatmap.pdf\" , width = 10 , height = 10 , type = \"expression\" , scale = \"none\" , heatmap.legend.color.bar = \"continuous\" )",
    "body": "{ # STEP 1 add columns labels (top of heatmap)   ha -  NULL  if (  !   missing (  col.metadata ) )  {  if (  !   is.null (  col.metadata ) )  {   id -  NULL  if (   \"patient\" %in%   colnames (  col.metadata ) )  {   id -  \"patient\"   size -  12 }  if (   \"barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  28 )   size -  28 }  if (   \"bcr_patient_barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"bcr_patient_barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  12 )   size -  12 }  if (   \"sample\" %in%   colnames (  col.metadata ) )  {   id -  \"sample\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  16 )   size -  16 }  if (   is.null (  id ) )  {   message (  \"=============== INNPUT ERROR =================\" )   message (  \"I'm expecting one of these columns:\" )   message (  \" = )   message (  \"    Has the complete barcode (TCGA-AA-3833-01A-01D-0904-05)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the sample barcode (TCGA-AA-3833-01A)\" )   message (  \"-----------------------------------------------\" )   message (  \"Obs: The complete barcode is the recommended one, as the others might lead to errors\" )   return (  NULL ) }   stopifnot (    nchar (    as.character (   col.metadata [ ,  id ] ) [  1 ] ) ==  size )   message (   paste0 (  \"Reorganizing: col.metadata order should be the same of the data object\" ) )   df -   col.metadata [   match (   substr (   colnames (  data ) ,  1 ,  size ) ,   col.metadata [ ,  id ] ) , ]    df [ ,  id ] -  NULL   duplicated.samples -   any (   sapply (   col.metadata [ ,  id ] ,  function ( x )  {    length (   grep (  x ,   col.metadata [ ,  id ] ) ) undefined  1 } ) )  if (  duplicated.samples )  {   warning (  \"Some samples are from the same patient, this might lead to the wrong upper annotation\" ) }  if (  !   missing (  sortCol ) )  {   message (   paste0 (  \"Sorting columns based on column: \" ,  sortCol ) )   column_order -   order (   df [ ,  sortCol ] ) }  if (   is.null (  col.colors ) )  {   ha -   HeatmapAnnotation ( df =  df ) } else  {   ha -   HeatmapAnnotation ( df =  df , col =  col.colors ) } } } # STEP 2 Create heatmap  if (   is.null (  color.levels ) )  {  if (   type ==  \"expression\" )   color.levels -   c (  \"green\" ,  \"white\" ,  \"red\" )  if (   type ==  \"methylation\" )   color.levels -   c (  \"blue\" ,  \"white\" ,  \"red\" ) } # If we want to show differences between genes, it is good to make Z-score by samples # (force each sample to have zero mean and standard deviation=1). # If we want to show differences between samples, it is good to make Z-score by genes # (force each gene to have zero mean and standard deviation=1).  if (   scale ==  \"row\" )  {   message (  \"Calculating z-scores for the rows....\" )   data -   t (   scale (   t (  data ) ) )   all.na -   apply (  data ,  1 ,  function ( x )   all (   is.na (  x ) ) )   data -   data [  !  all.na , ] } else  if (   scale ==  \"col\" )  {   message (  \"Calculiating z-scores for the columns....\" )   data -   scale (  data ) }  if (   is.null (  extrems ) )  {  if (    min (  data ) undefined  0 )  {   extrems -   c (   min (  data ) ,  0 ,   max (  data ) ) } else  {   extrems -   c (  0 ,    max (  data ) /  2 ,   max (  data ) ) } }  if (   type ==  \"expression\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels )  if (   type ==  \"methylation\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels ) # Creating plot title  if (   is.null (  title ) )  {  if (   type ==  \"methylation\" )   title -  \"DNA methylation heatmap\"  if (   type ==  \"expression\" )   title -  \"Expression heatmap\" } # Change label type   heatmap_legend_param -   list ( )  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"methylation\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param )  if (  !   scale %in%   c (  \"row\" ,  \"col\" ) )   heatmap_legend_param -   list ( color_bar =  \"continuous\" , at =   c (  0 ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  1 ) , legend_height =   unit (  3 ,  \"cm\" ) , labels =   c (  \"0.0 (hypomethylated)\" ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  \"1.0 (hypermethylated)\" ) ) }  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"expression\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param ) } # Change label reference  if (   is.null (  values.label ) )  {  if (   type ==  \"methylation\" )   values.label -  \"DNA methylation level\"  if (   type ==  \"expression\" )   values.label -  \"Expression\" }  if (   !   missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (    missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , show_row_names =  show_row_names , row_names_gp =   gpar ( fontsize =  rownames.size ) , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (  !   missing (  sortCol ) )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title ) } else  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } # STEP 3 row labels (right side)  if (  !   missing (  row.metadata ) )  {  if (  !   is.null (  row.metadata ) )  {  for  ( i in   1 :   ncol (  row.metadata ) )  {  if (   !   missing (  row.colors ) undefined  !   is.null (   row.colors [[    colnames (  row.metadata ) [  i ] ] ] ) )  {   color -   row.colors [[    colnames (  row.metadata ) [  i ] ] ]   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE , col =  color ) } else  {   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE ) }   heatmap -   add_heatmap (  heatmap ,  x ) } } }  if (  !   is.null (  filename ) )  {  if (    file_ext (  filename ) ==  \"png\" )   png (  filename , width =  width , height =  height )  if (    file_ext (  filename ) ==  \"pdf\" )   pdf (  filename , width =  width , height =  height )   draw (  heatmap )   dev.off ( ) } else  {   draw (  heatmap ) } } ",
    "filename": "TCGAvisualize.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "TCGAvisualize_meanMethylation",
    "representation": "TCGAvisualize_meanMethylation",
    "parameters": "function ( data , groupCol = NULL , subgroupCol = NULL , shapes = NULL , print.pvalue = FALSE , filename = \"groupMeanMet.pdf\" , ylab = expression ( paste ( \"Mean DNA methylation (\" , beta , \"-values)\" ) ) , xlab = NULL , title = \"Mean DNA methylation\" , labels = NULL , group.legend = NULL , subgroup.legend = NULL , color = NULL )",
    "body": "{   .e -   environment ( )   mean -   colMeans (   assay (  data ) , na.rm =  TRUE )  if (   is.null (  groupCol ) )  {   groups -   rep (  \"Patient\" ,   length (  mean ) ) } else  {   groups -    colData (  data ) [ ,  groupCol ] }  if (   is.null (  subgroupCol ) )  {   subgroups -  NULL } else  {   subgroups -    colData (  data ) [ ,  subgroupCol ] }  if (  !   is.null (  subgroupCol ) )  {   df -   data.frame ( mean =  mean , groups =  groups , subgroups =  subgroups ) } else  {   df -   data.frame ( mean =  mean , groups =  groups ) }  for  ( i in   unique (   df $ groups ) )  {   message (   paste (  \"Mean group \" ,  i ,  \":\" ,   mean (    subset (  df ,   groups ==  i ) $ mean ) ) ) }  if (   is.null (  color ) )  {   color -   rainbow (   length (   unique (  groups ) ) ) } #comb2by2 #                  2, #                 levels(droplevels(df$groups)))   comb2by2 -   t (   combn (   levels (   droplevels (   df $ groups ) ) ,  2 ) )  for  ( i in   1 :   nrow (  comb2by2 ) )  {   try (  {    aux -    t.test (   mean ~  groups , data =   subset (  df , subset =    df $ groups %in%   comb2by2 [  i , ] ) ) $ p.value ;   message (   paste (  \"P-value:\" ,   paste0 (   comb2by2 [  i , ] , collapse =  \"-\" ) ,  \"=\" ,  aux ) ) } , silent =  TRUE ) }  if (   print.pvalue undefined    length (   levels (   droplevels (   df $ groups ) ) ) ==  2 )  {   pvalue -    t.test (   mean ~  groups , data =  df ) $ p.value } else  {   print.pvalue -  FALSE } # Plot for methylation analysis Axis x: LGm clusters Axis y: # mean methylation   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  df , subset =  (    df $ groups ==  x ) ) ) ,  \")\" ) }  if (   is.null (  group.legend ) )  {   group.legend -  groupCol }  if (   is.null (  subgroup.legend ) )  {   subgroup.legend -  subgroupCol }  if (   is.null (  labels ) )  {   labels -   levels (   factor (   df $ groups ) )   labels -   sapply (  labels ,  label.add.n ) }   p -    ggplot (  df ,   aes (   factor (   df $ groups ) ,   df $ mean ) , environment =  .e ) +   geom_boxplot (   aes ( fill =   factor (   df $ groups ) ) , notchwidth =  0.25 , outlier.shape =  NA )  if (  !   is.null (  subgroupCol ) )  {   p -   p +   geom_jitter (   aes ( shape =  subgroups , size =  subgroups ) , position =   position_jitter ( width =  0.1 ) , size =  3 ) } else  {   p -   p +   geom_jitter ( position =   position_jitter ( width =  0.1 ) , size =  3 ) }   p -   p +   scale_fill_manual ( values =  color , labels =  labels , name =  group.legend )   p -   p +   scale_x_discrete ( breaks =  labels , labels =  labels )   p -        p +   ylab (  ylab ) +   xlab (  xlab ) +   labs ( title =  title ) +   labs ( shape =  subgroup.legend , color =  group.legend ) +   theme_bw ( ) +   theme ( axis.title.x =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.x =   element_text ( angle =  90 , vjust =  0.5 , size =  16 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.y =   element_text ( size =  16 ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  22 ) , panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) )  if (  !   is.null (  shapes ) )  {   p -   p +   scale_shape_manual ( values =  shapes ) }  if (  print.pvalue )  {   p -   p +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  3 , label =   paste0 (  \"P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) } # saving box plot to analyse it   ggsave (  p , filename =  filename , width =  10 , height =  10 , dpi =  600 )   message (   paste (  \"Plot saved in: \" ,   file.path (   getwd ( ) ,  filename ) ) ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_meanMethylation",
    "representation": "TCGAvisualize_meanMethylation",
    "parameters": "function ( data , groupCol = NULL , subgroupCol = NULL , shapes = NULL , print.pvalue = FALSE , plot.jitter = TRUE , jitter.size = 3 , filename = \"groupMeanMet.pdf\" , ylab = expression ( paste ( \"Mean DNA methylation (\" , beta , \"-values)\" ) ) , xlab = NULL , title = \"Mean DNA methylation\" , labels = NULL , group.legend = NULL , subgroup.legend = NULL , color = NULL , y.limits = NULL , sort , order , legend.position = \"top\" , legend.title.position = \"top\" , legend.ncols = 3 , add.axis.x.text = FALSE , width = 10 , height = 10 , dpi = 600 , axis.text.x.angle = 90 )",
    "body": "{   .e -   environment ( )   mean -   colMeans (   assay (  data ) , na.rm =  TRUE )  if (   is.null (  groupCol ) )  {   groups -   rep (  \"Patient\" ,   length (  mean ) ) } else  {  if (  !  (   groupCol %in%   colnames (   colData (  data ) ) ) )   stop (  \"groupCol not found in the object\" )   groups -    colData (  data ) [ ,  groupCol ] }  if (   is.null (  subgroupCol ) )  {   subgroups -  NULL } else  {  if (  !  (   subgroupCol %in%   colnames (   colData (  data ) ) ) )   stop (  \"subgroupCol not found in the object\" )   subgroups -    colData (  data ) [ ,  subgroupCol ] }  if (  !   is.null (  subgroupCol ) )  {   df -   data.frame ( mean =  mean , groups =  groups , subgroups =  subgroups ) } else  {   df -   data.frame ( mean =  mean , groups =  groups ) }   message (  \"==================== DATA Summary ====================\" )   data.summary -   ddply (  df ,   . (  groups ) ,  summarize , Mean =   mean (  mean ) , Median =   median (  mean ) , Max =   max (  mean ) , Min =   min (  mean ) )   print (   kable (  data.summary ) )   message (  \"==================== END DATA Summary ====================\" ) #comb2by2 #                  2, #                 levels(droplevels(df$groups)))   groups -   levels (   droplevels (   df $ groups ) )   mat.pvalue -   matrix ( ncol =   length (  groups ) , nrow =   length (  groups ) , dimnames =   list (  groups ,  groups ) )  if (    length (  groups ) undefined  1 )  {   comb2by2 -   t (   combn (   levels (   droplevels (   df $ groups ) ) ,  2 ) )  for  ( i in   1 :   nrow (  comb2by2 ) )  {   try (  {    aux -    t.test (   mean ~  groups , data =   subset (  df , subset =    df $ groups %in%   comb2by2 [  i , ] ) ) $ p.value ;    mat.pvalue [   comb2by2 [  i ,  1 ] ,   comb2by2 [  i ,  2 ] ] -  aux    mat.pvalue [   comb2by2 [  i ,  2 ] ,   comb2by2 [  i ,  1 ] ] -  aux } , silent =  TRUE ) }   message (  \"==================== T test results ====================\" )   print (   kable (  mat.pvalue ) )   message (  \"==================== END T test results ====================\" ) }  if (   print.pvalue undefined    length (   levels (   droplevels (   df $ groups ) ) ) ==  2 )  {   pvalue -    t.test (   mean ~  groups , data =  df ) $ p.value } else  {   print.pvalue -  FALSE } # Plot for methylation analysis Axis x: LGm clusters Axis y: # mean methylation   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  df , subset =  (    df $ groups ==  x ) ) ) ,  \")\" ) }  if (   is.null (  group.legend ) )  {   group.legend -  groupCol }  if (   is.null (  subgroup.legend ) )  {   subgroup.legend -  subgroupCol }  if (   missing (  sort ) )  {  if (   missing (  order ) )  {   x -   factor (   df $ groups ) } else  {   x -   factor (   df $ groups , levels =  order ) } } else  if (   sort ==  \"mean.asc\" )  {   x -   reorder (   df $ groups ,   df $ mean , FUN =  \"mean\" ) } else  if (   sort ==  \"mean.desc\" )  {   x -   reorder (   df $ groups ,  -   df $ mean , FUN =  \"mean\" ) } else  if (   sort ==  \"median.asc\" )  {   x -   reorder (   df $ groups ,   df $ mean , FUN =  \"median\" ) } else  if (   sort ==  \"median.desc\" )  {   x -   reorder (   df $ groups ,  -   df $ mean , FUN =  \"median\" ) }  if (   is.null (  labels ) )  {   labels -   levels (  x )   labels -   sapply (  labels ,  label.add.n ) }  if (   is.null (  color ) )  {   color -   rainbow (   length (  labels ) )   color -   color [  (   match (   levels (  x ) ,   levels (   factor (   df $ groups ) ) ) ) ] }   p -    ggplot (  df ,   aes (  x ,   df $ mean ) , environment =  .e ) +   geom_boxplot (   aes ( fill =  x ) , notchwidth =  0.25 , outlier.shape =  NA )  if (  plot.jitter )  {  if (  !   is.null (  subgroupCol ) )  {   p -   p +   geom_jitter (   aes ( shape =  subgroups , size =  subgroups ) , position =   position_jitter ( width =  0.1 ) , size =  jitter.size ) } else  {   p -   p +   geom_jitter ( position =   position_jitter ( width =  0.1 ) , size =  jitter.size ) } }  if (  add.axis.x.text )  {   axis.text.x -   element_text ( angle =  axis.text.x.angle , vjust =  0.5 , size =  16 ) } else  {   axis.text.x -   element_blank ( ) }   p -   p +   scale_fill_manual ( values =  color , labels =  labels , name =  group.legend )   p -   p +   scale_x_discrete ( limits =   levels (  x ) )   p -         p +   ylab (  ylab ) +   xlab (  xlab ) +   labs ( title =  title ) +   labs ( shape =  subgroup.legend , color =  group.legend ) +   theme_bw ( ) +   theme ( axis.title.x =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.x =  axis.text.x , axis.title.y =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.y =   element_text ( size =  16 ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  22 ) , panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  legend.position , legend.key =   element_rect ( colour =  'white' ) ) +   guides ( fill =   guide_legend ( ncol =  legend.ncols , title.position =  legend.title.position , title.hjust =  0.5 ) )  if (  !   is.null (  shapes ) )  {   p -   p +   scale_shape_manual ( values =  shapes ) }  if (  print.pvalue )  {   p -   p +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  5 , label =   paste0 (  \"P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) }  if (  !   is.null (  y.limits ) )  {   p -   p +   expand_limits ( x =  0 , y =  y.limits ) } # saving box plot to analyse it  if (  !   is.null (  filename ) )  {   ggsave (  p , filename =  filename , width =  width , height =  height , dpi =  dpi )   message (   paste (  \"Plot saved in: \" ,   file.path (   getwd ( ) ,  filename ) ) ) } else  {   return (  p ) } } ",
    "filename": "methylation.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_survival",
    "representation": "TCGAanalyze_survival",
    "parameters": "function ( data , clusterCol = NULL , legend = \"Legend\" , labels = NULL , cutoff = 0 , main = \"Kaplan-Meier Overall Survival Curves\" , ylab = \"Probability of survival\" , xlab = \"Time since diagnosis (days)\" , filename = \"survival.pdf\" , color = NULL , height = 8 , width = 12 , print.value = TRUE )",
    "body": "{   .e -   environment ( )  if (   is.null (  color ) )  {   color -   rainbow (   length (   unique (   data [ ,  clusterCol ] ) ) ) }   group -  NULL  if (   is.null (  clusterCol ) )  {   message (  \"Please provide the clusterCol argument\" )   return (  NULL ) }   notDead -   which (    data $ days_to_death ==  \"[Not Applicable]\" )  if (    length (  notDead ) undefined  0 )  {     data [  notDead , ] $ days_to_death -    data [  notDead , ] $ days_to_last_followup } # create a column to be used with survival package, info need # to be TRUE(DEAD)/FALSE (ALIVE)    data $ s -  (    data $ vital_status ==  \"Dead\" ) # Column with groups    data $ type -   as.factor (   data [ ,  clusterCol ] ) # create the formula for survival analysis   f.m -   formula (    Surv (   as.numeric (   data $ days_to_death ) , event =   data $ s ) ~   data $ type )   fit -   survfit (  f.m , data =  data ) # calculating p-value   pvalue -     summary (   coxph (    Surv (   as.numeric (   data $ days_to_death ) , event =   data $ s ) ~   data $ type ) ) $ logtest [  3 ]   surv -   ggsurv (  fit , CI =  \"def\" , plot.cens =  FALSE , surv.col =  \"gg.def\" , cens.col =  \"red\" , lty.est =  1 , lty.ci =  2 , cens.shape =  3 , back.white =  TRUE , xlab =  xlab , ylab =  ylab , main =  main )  if (  print.value )  {   surv -   surv +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  6 , label =   paste0 (  \"Log-Rank P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) }  if (   cutoff !=  0 )  {   surv -   surv +   ggplot2 :: coord_cartesian ( xlim =   c (  0 ,  cutoff ) ) }   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  data ,    data [ ,  clusterCol ] ==  x ) ) ,  \")\" ) }  if (   is.null (  labels ) )  {   labels -   sapply (   levels (   data $ type ) ,  label.add.n ) }   surv -   surv +   scale_colour_manual ( name =  legend , labels =  labels , values =  color )   surv -   surv +   geom_point (   aes ( colour =  group ) , shape =  3 , size =  2 )   surv -      surv +   guides ( linetype =  FALSE ) +   scale_y_continuous ( labels =  scales :: percent ) +   theme_bw ( ) +   theme ( #panel.border = element_blank(), panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , panel.border =   element_rect ( colour =  \"black\" , size =  1.5 ) , legend.key =   element_rect ( colour =  'white' ) , legend.justification =   c (  1 ,  1 ) , #axis.line = element_line(colour = \"black\"), legend.background =   element_rect ( colour =  \"black\" ) , #linetype = \"dashed\"), #legend.background = element_rect(colour = \"white\"), legend.position =   c (  1 ,  1 ) , plot.title =   element_text ( size =  20 ) , legend.text =   element_text ( size =  16 ) , legend.title =   element_text ( size =  16 ) , axis.text =   element_text ( size =  16 ) , axis.title.x =   element_text ( size =  16 ) , #legend.position=\"top\", axis.title.y =   element_text ( size =  16 ) )   ggsave (  surv , filename =  filename , width =  width , height =  height , dpi =  600 ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_survival",
    "representation": "TCGAanalyze_survival",
    "parameters": "function ( data , clusterCol = NULL , legend = \"Legend\" , labels = NULL , cutoff = 0 , main = \"Kaplan-Meier Overall Survival Curves\" , ylab = \"Probability of survival\" , xlab = \"Time since diagnosis (days)\" , filename = \"survival.pdf\" , color = NULL , height = 8 , width = 12 , dpi = 300 , legend.position = \"inside\" , legend.title.position = \"top\" , legend.ncols = 1 , add.legend = TRUE , print.value = TRUE , add.points = TRUE )",
    "body": "{   .e -   environment ( )  if (  !   all (    c (  \"vital_status\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ) %in%   colnames (  data ) ) )   stop (  \"Columns vital_status, days_to_death and  days_to_last_follow_up should be in data frame\" )  if (   is.null (  color ) )  {   color -   rainbow (   length (   unique (   data [ ,  clusterCol ] ) ) ) }   group -  NULL  if (   is.null (  clusterCol ) )  {   message (  \"Please provide the clusterCol argument\" )   return (  NULL ) }   notDead -   is.na (   data $ days_to_death )  if (   any (   notDead ==  TRUE ) )  {    data [  notDead ,  \"days_to_death\" ] -   data [  notDead ,  \"days_to_last_follow_up\" ] } # create a column to be used with survival package, info need # to be TRUE(DEAD)/FALSE (ALIVE)    data $ s -   grepl (  \"dead\" ,   data $ vital_status , ignore.case =  TRUE ) # Column with groups    data $ type -   as.factor (   data [ ,  clusterCol ] ) # create the formula for survival analysis   f.m -   formula (    Surv (   as.numeric (   data $ days_to_death ) , event =   data $ s ) ~   data $ type )   fit -   survfit (  f.m , data =  data ) # calculating p-value   pvalue -     summary (   coxph (    Surv (   as.numeric (   data $ days_to_death ) , event =   data $ s ) ~   data $ type ) ) $ logtest [  3 ]   surv -   ggsurv (  fit , CI =  \"def\" , plot.cens =  FALSE , surv.col =  \"gg.def\" , cens.col =  \"red\" , lty.est =  1 , lty.ci =  2 , cens.shape =  3 , back.white =  TRUE , xlab =  xlab , ylab =  ylab , main =  main )  if (  print.value )  {   surv -   surv +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  6 , label =   paste0 (  \"Log-Rank P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) }  if (   cutoff !=  0 )  {   surv -   surv +   ggplot2 :: coord_cartesian ( xlim =   c (  0 ,  cutoff ) ) }   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  data ,    data [ ,  clusterCol ] ==  x ) ) ,  \")\" ) }  if (   is.null (  labels ) )  {   labels -   sapply (   levels (   data $ type ) ,  label.add.n ) }   surv -   surv +   scale_colour_manual ( name =  legend , labels =  labels , values =  color )  if (  add.points )  {   surv -   surv +   geom_point (   aes ( colour =  group ) , shape =  3 , size =  2 ) }   surv -     surv +   guides ( linetype =  FALSE ) +   scale_y_continuous ( labels =  scales :: percent ) +   theme_base ( )  if (   add.legend ==  TRUE )  {  if (   legend.position ==  \"inside\" )  {   surv -   surv +   theme ( legend.justification =   c (  1 ,  1 ) , legend.background =   element_rect ( colour =  \"black\" ) , legend.position =   c (  1 ,  1 ) ) } else  {   surv -   surv +   theme ( legend.position =  legend.position ) }   surv -   surv +   guides ( color =   guide_legend ( override.aes =   list ( size =  3 ) ) , fill =   guide_legend ( ncol =  legend.ncols , title.position =  legend.title.position , title.hjust =  0.5 ) ) }  if (   add.legend ==  FALSE )  {   surv -    surv +   geom_text_repel ( data =   ddply (   surv $ data ,   . (  group ) ,  function ( x )   x [   nrow (  x ) , ] ) ,   aes ( label =  group , color =   factor (  group ) ) , segment.color =  '#555555' , segment.size =  0.0 , size =  3 , show.legend =  FALSE ) +   theme ( legend.position =  \"none\" ) }  if (  !   is.null (  filename ) )  {   ggsave (  surv , filename =  filename , width =  width , height =  height , dpi =  dpi ) } else  {   return (  surv ) } } ",
    "filename": "methylation.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAvisualize_meanMethylation",
    "representation": "TCGAvisualize_meanMethylation",
    "parameters": "function ( data , groupCol = NULL , subgroupCol = NULL , shapes = NULL , print.pvalue = FALSE , filename = \"groupMeanMet.pdf\" , ylab = expression ( paste ( \"Mean DNA methylation (\" , beta , \"-values)\" ) ) , xlab = NULL , title = \"Mean DNA methylation\" , labels = NULL , group.legend = NULL , subgroup.legend = NULL , color = NULL )",
    "body": "{   .e -   environment ( )   mean -   colMeans (   assay (  data ) , na.rm =  TRUE )  if (   is.null (  groupCol ) )  {   groups -   rep (  \"Patient\" ,   length (  mean ) ) } else  {   groups -    colData (  data ) [ ,  groupCol ] }  if (   is.null (  subgroupCol ) )  {   subgroups -  NULL } else  {   subgroups -    colData (  data ) [ ,  subgroupCol ] }  if (  !   is.null (  subgroupCol ) )  {   df -   data.frame ( mean =  mean , groups =  groups , subgroups =  subgroups ) } else  {   df -   data.frame ( mean =  mean , groups =  groups ) }  for  ( i in   unique (   df $ groups ) )  {   message (   paste (  \"Mean group \" ,  i ,  \":\" ,   mean (    subset (  df ,   groups ==  i ) $ mean ) ) ) }  if (   is.null (  color ) )  {   color -   rainbow (   length (   unique (  groups ) ) ) } #comb2by2 #                  2, #                 levels(droplevels(df$groups)))   comb2by2 -   t (   combn (   levels (   droplevels (   df $ groups ) ) ,  2 ) )  for  ( i in   1 :   nrow (  comb2by2 ) )  {   try (  {    aux -    t.test (   mean ~  groups , data =   subset (  df , subset =    df $ groups %in%   comb2by2 [  i , ] ) ) $ p.value ;   message (   paste (  \"P-value:\" ,   paste0 (   comb2by2 [  i , ] , collapse =  \"-\" ) ,  \"=\" ,  aux ) ) } , silent =  TRUE ) }  if (   print.pvalue undefined    length (   levels (   droplevels (   df $ groups ) ) ) ==  2 )  {   pvalue -    t.test (   mean ~  groups , data =  df ) $ p.value } else  {   print.pvalue -  FALSE } # Plot for methylation analysis Axis x: LGm clusters Axis y: # mean methylation   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  df , subset =  (    df $ groups ==  x ) ) ) ,  \")\" ) }  if (   is.null (  group.legend ) )  {   group.legend -  groupCol }  if (   is.null (  subgroup.legend ) )  {   subgroup.legend -  subgroupCol }  if (   is.null (  labels ) )  {   labels -   levels (   factor (   df $ groups ) )   labels -   sapply (  labels ,  label.add.n ) }   p -    ggplot (  df ,   aes (   factor (   df $ groups ) ,   df $ mean ) , environment =  .e ) +   geom_boxplot (   aes ( fill =   factor (   df $ groups ) ) , notchwidth =  0.25 , outlier.shape =  NA )  if (  !   is.null (  subgroupCol ) )  {   p -   p +   geom_jitter (   aes ( shape =  subgroups , size =  subgroups ) , position =   position_jitter ( width =  0.1 ) , size =  3 ) } else  {   p -   p +   geom_jitter ( position =   position_jitter ( width =  0.1 ) , size =  3 ) }   p -   p +   scale_fill_manual ( values =  color , labels =  labels , name =  group.legend )   p -   p +   scale_x_discrete ( breaks =  labels , labels =  labels )   p -        p +   ylab (  ylab ) +   xlab (  xlab ) +   labs ( title =  title ) +   labs ( shape =  subgroup.legend , color =  group.legend ) +   theme_bw ( ) +   theme ( axis.title.x =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.x =   element_text ( angle =  90 , vjust =  0.5 , size =  16 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.y =   element_text ( size =  16 ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  22 ) , panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) )  if (  !   is.null (  shapes ) )  {   p -   p +   scale_shape_manual ( values =  shapes ) }  if (  print.pvalue )  {   p -   p +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  3 , label =   paste0 (  \"P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) } # saving box plot to analyse it   ggsave (  p , filename =  filename , width =  10 , height =  10 , dpi =  600 )   message (   paste (  \"Plot saved in: \" ,   file.path (   getwd ( ) ,  filename ) ) ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_meanMethylation",
    "representation": "TCGAvisualize_meanMethylation",
    "parameters": "function ( data , groupCol = NULL , subgroupCol = NULL , shapes = NULL , print.pvalue = FALSE , plot.jitter = TRUE , jitter.size = 3 , filename = \"groupMeanMet.pdf\" , ylab = expression ( paste ( \"Mean DNA methylation (\" , beta , \"-values)\" ) ) , xlab = NULL , title = \"Mean DNA methylation\" , labels = NULL , group.legend = NULL , subgroup.legend = NULL , color = NULL , y.limits = NULL , sort , order , legend.position = \"top\" , legend.title.position = \"top\" , legend.ncols = 3 , add.axis.x.text = FALSE , width = 10 , height = 10 , dpi = 600 , axis.text.x.angle = 90 )",
    "body": "{   .e -   environment ( )   mean -   colMeans (   assay (  data ) , na.rm =  TRUE )  if (   is.null (  groupCol ) )  {   groups -   rep (  \"Patient\" ,   length (  mean ) ) } else  {  if (  !  (   groupCol %in%   colnames (   colData (  data ) ) ) )   stop (  \"groupCol not found in the object\" )   groups -    colData (  data ) [ ,  groupCol ] }  if (   is.null (  subgroupCol ) )  {   subgroups -  NULL } else  {  if (  !  (   subgroupCol %in%   colnames (   colData (  data ) ) ) )   stop (  \"subgroupCol not found in the object\" )   subgroups -    colData (  data ) [ ,  subgroupCol ] }  if (  !   is.null (  subgroupCol ) )  {   df -   data.frame ( mean =  mean , groups =  groups , subgroups =  subgroups ) } else  {   df -   data.frame ( mean =  mean , groups =  groups ) }   message (  \"==================== DATA Summary ====================\" )   data.summary -   ddply (  df ,   . (  groups ) ,  summarize , Mean =   mean (  mean ) , Median =   median (  mean ) , Max =   max (  mean ) , Min =   min (  mean ) )   print (   kable (  data.summary ) )   message (  \"==================== END DATA Summary ====================\" ) #comb2by2 #                  2, #                 levels(droplevels(df$groups)))   groups -   levels (   droplevels (   df $ groups ) )   mat.pvalue -   matrix ( ncol =   length (  groups ) , nrow =   length (  groups ) , dimnames =   list (  groups ,  groups ) )  if (    length (  groups ) undefined  1 )  {   comb2by2 -   t (   combn (   levels (   droplevels (   df $ groups ) ) ,  2 ) )  for  ( i in   1 :   nrow (  comb2by2 ) )  {   try (  {    aux -    t.test (   mean ~  groups , data =   subset (  df , subset =    df $ groups %in%   comb2by2 [  i , ] ) ) $ p.value ;    mat.pvalue [   comb2by2 [  i ,  1 ] ,   comb2by2 [  i ,  2 ] ] -  aux    mat.pvalue [   comb2by2 [  i ,  2 ] ,   comb2by2 [  i ,  1 ] ] -  aux } , silent =  TRUE ) }   message (  \"==================== T test results ====================\" )   print (   kable (  mat.pvalue ) )   message (  \"==================== END T test results ====================\" ) }  if (   print.pvalue undefined    length (   levels (   droplevels (   df $ groups ) ) ) ==  2 )  {   pvalue -    t.test (   mean ~  groups , data =  df ) $ p.value } else  {   print.pvalue -  FALSE } # Plot for methylation analysis Axis x: LGm clusters Axis y: # mean methylation   label.add.n -  function ( x )  {   paste0 (  x ,  \" (n = \" ,   nrow (   subset (  df , subset =  (    df $ groups ==  x ) ) ) ,  \")\" ) }  if (   is.null (  group.legend ) )  {   group.legend -  groupCol }  if (   is.null (  subgroup.legend ) )  {   subgroup.legend -  subgroupCol }  if (   missing (  sort ) )  {  if (   missing (  order ) )  {   x -   factor (   df $ groups ) } else  {   x -   factor (   df $ groups , levels =  order ) } } else  if (   sort ==  \"mean.asc\" )  {   x -   reorder (   df $ groups ,   df $ mean , FUN =  \"mean\" ) } else  if (   sort ==  \"mean.desc\" )  {   x -   reorder (   df $ groups ,  -   df $ mean , FUN =  \"mean\" ) } else  if (   sort ==  \"median.asc\" )  {   x -   reorder (   df $ groups ,   df $ mean , FUN =  \"median\" ) } else  if (   sort ==  \"median.desc\" )  {   x -   reorder (   df $ groups ,  -   df $ mean , FUN =  \"median\" ) }  if (   is.null (  labels ) )  {   labels -   levels (  x )   labels -   sapply (  labels ,  label.add.n ) }  if (   is.null (  color ) )  {   color -   rainbow (   length (  labels ) )   color -   color [  (   match (   levels (  x ) ,   levels (   factor (   df $ groups ) ) ) ) ] }   p -    ggplot (  df ,   aes (  x ,   df $ mean ) , environment =  .e ) +   geom_boxplot (   aes ( fill =  x ) , notchwidth =  0.25 , outlier.shape =  NA )  if (  plot.jitter )  {  if (  !   is.null (  subgroupCol ) )  {   p -   p +   geom_jitter (   aes ( shape =  subgroups , size =  subgroups ) , position =   position_jitter ( width =  0.1 ) , size =  jitter.size ) } else  {   p -   p +   geom_jitter ( position =   position_jitter ( width =  0.1 ) , size =  jitter.size ) } }  if (  add.axis.x.text )  {   axis.text.x -   element_text ( angle =  axis.text.x.angle , vjust =  0.5 , size =  16 ) } else  {   axis.text.x -   element_blank ( ) }   p -   p +   scale_fill_manual ( values =  color , labels =  labels , name =  group.legend )   p -   p +   scale_x_discrete ( limits =   levels (  x ) )   p -         p +   ylab (  ylab ) +   xlab (  xlab ) +   labs ( title =  title ) +   labs ( shape =  subgroup.legend , color =  group.legend ) +   theme_bw ( ) +   theme ( axis.title.x =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.x =  axis.text.x , axis.title.y =   element_text ( face =  \"bold\" , size =  20 ) , axis.text.y =   element_text ( size =  16 ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  22 ) , panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  legend.position , legend.key =   element_rect ( colour =  'white' ) ) +   guides ( fill =   guide_legend ( ncol =  legend.ncols , title.position =  legend.title.position , title.hjust =  0.5 ) )  if (  !   is.null (  shapes ) )  {   p -   p +   scale_shape_manual ( values =  shapes ) }  if (  print.pvalue )  {   p -   p +   annotate (  \"text\" , x =  -  Inf , y =  -  Inf , hjust =  -  0.1 , vjust =  -  1.0 , size =  5 , label =   paste0 (  \"P-value = \" ,   format (  pvalue , scientific =  TRUE , digits =  2 ) ) ) }  if (  !   is.null (  y.limits ) )  {   p -   p +   expand_limits ( x =  0 , y =  y.limits ) } # saving box plot to analyse it  if (  !   is.null (  filename ) )  {   ggsave (  p , filename =  filename , width =  width , height =  height , dpi =  dpi )   message (   paste (  \"Plot saved in: \" ,   file.path (   getwd ( ) ,  filename ) ) ) } else  {   return (  p ) } } ",
    "filename": "methylation.txt"
  }
}

2.
{
  "old_function": {
    "name": "TCGAVisualize_volcano",
    "representation": "TCGAVisualize_volcano",
    "parameters": "function ( x , y , filename = \"volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = NULL , title = NULL , legend = NULL , label = NULL , xlim = NULL , ylim = NULL , color = c ( \"black\" , \"red\" , \"green\" ) , names = NULL , x.cut = 0 , y.cut = 0.01 , height = 5 , width = 10 )",
    "body": "{  if (  !   is.null (  names ) )  {  if (   all (   grepl (  \"\\\\|\" ,  names ) ) )  {   names -   strsplit (  names ,  \"\\\\|\" )   names -   unlist (   lapply (  names ,  function ( x )   x [  1 ] ) ) } }   .e -   environment ( )   threshold -   rep (  \"1\" ,   length (  x ) )    names (  color ) -   as.character (   1 :  3 )  if (   is.null (  label ) )  {   label =   c ( \"1\" =  \"Not Significant\" , \"2\" =  \"Up regulared\" , \"3\" =  \"Down regulated\" ) } else  {    names (  label ) -   as.character (   1 :  3 ) } # get significant data   sig -   y undefined  y.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated/up regulated samples compared to old state   up -   x undefined  x.cut    up [   is.na (  up ) ] -  FALSE  if (   any (   up undefined  sig ) )    threshold [   up undefined  sig ] -  \"2\" # hypomethylated/ down regulated samples compared to old state   down -   x undefined  (  -  x.cut )    down [   is.na (  down ) ] -  FALSE  if (   any (   down undefined  sig ) )    threshold [   down undefined  sig ] -  \"3\"   df -   data.frame ( x =  x , y =  y , threshold =  threshold ) # Plot a volcano plot   p -             ggplot ( data =  df ,   aes ( x =  x , y =   -  1 *   log10 (  y ) , colour =  threshold ) , environment =  .e ) +   geom_point ( ) +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   geom_vline (   aes ( xintercept =  -  x.cut ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  x.cut ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =   -  1 *   log10 (  y.cut ) ) , colour =  \"black\" , linetype =  \"dashed\" ) +   scale_color_manual ( breaks =   as.character (   1 :  3 ) , values =  color , labels =  label , name =  legend ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) ) # Label points with the textxy function from the calibrate plot  if (  !   is.null (  names ) )  {   idx -   (   up undefined  sig ) |  (   down undefined  sig )   p -   p +   annotate (  \"text\" , x =   x [  idx ] , y =   -  1.1 *   log10 (   y [  idx ] ) , label =   names [  idx ] , size =  2.0 , alpha =  .6 ) }   ggsave (  p , filename =  filename , width =  width , height =  height , dpi =  600 ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAVisualize_volcano",
    "representation": "TCGAVisualize_volcano",
    "parameters": "function ( x , y , filename = \"volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = NULL , title = NULL , legend = NULL , label = NULL , xlim = NULL , ylim = NULL , color = c ( \"black\" , \"red\" , \"green\" ) , names = NULL , names.fill = TRUE , show.names = \"significant\" , x.cut = 0 , y.cut = 0.01 , height = 5 , width = 10 , highlight = NULL , highlight.color = \"orange\" , names.size = 4 , dpi = 300 )",
    "body": "{  if (  !   is.null (  names ) )  {  if (   all (   grepl (  \"\\\\|\" ,  names ) ) )  {   names -   strsplit (  names ,  \"\\\\|\" )   names -   unlist (   lapply (  names ,  function ( x )   x [  1 ] ) ) } }   .e -   environment ( )   threshold -   rep (  \"1\" ,   length (  x ) )    names (  color ) -   as.character (   1 :  3 )  if (   is.null (  label ) )  {   label =   c ( \"1\" =  \"Not Significant\" , \"2\" =  \"Up regulated\" , \"3\" =  \"Down regulated\" ) } else  {    names (  label ) -   as.character (   1 :  3 ) } # get significant data   sig -   y undefined  y.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated/up regulated samples compared to old state   up -   x undefined  x.cut    up [   is.na (  up ) ] -  FALSE  if (   any (   up undefined  sig ) )    threshold [   up undefined  sig ] -  \"2\" # hypomethylated/ down regulated samples compared to old state   down -   x undefined  (  -  x.cut )    down [   is.na (  down ) ] -  FALSE  if (   any (   down undefined  sig ) )    threshold [   down undefined  sig ] -  \"3\"  if (  !   is.null (  highlight ) )  {   idx -   which (   names %in%  highlight )  if (    length (  idx ) undefined  0 )  {   print (  idx )    threshold [   which (   names %in%  highlight ) ] -  \"4\"   color -   c (  color ,  highlight.color )    names (  color ) -   as.character (   1 :  4 ) } }   df -   data.frame ( x =  x , y =  y , threshold =  threshold ) # As last color should be the highlighthed, we need to order all the vectors  if (  !   is.null (  highlight ) )  {   order.idx -   order (   df $ threshold )   down -   down [  order.idx ]   sig -   sig [  order.idx ]   up -   up [  order.idx ]   df -   df [  order.idx , ]   names -   names [  order.idx ] } # Plot a volcano plot   p -             ggplot ( data =  df ,   aes ( x =  x , y =   -  1 *   log10 (  y ) , colour =  threshold ) , environment =  .e ) +   geom_point ( ) +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   geom_vline (   aes ( xintercept =  -  x.cut ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  x.cut ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =   -  1 *   log10 (  y.cut ) ) , colour =  \"black\" , linetype =  \"dashed\" ) +   scale_color_manual ( breaks =   as.numeric (   names (  label ) ) , values =  color , labels =  label , name =  legend ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , legend.text =   element_text ( size =  10 ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) ) # Label points with the textxy function from the calibrate plot  if (  !   is.null (  names ) )  { # With the names the user can highlight the significant genes, up and down # or the ones highlighted  if (   show.names ==  \"significant\" )  {   idx -   (   up undefined  sig ) |  (   down undefined  sig )   important -   c (  \"2\" ,  \"3\" ) } else  if (   show.names ==  \"highlighted\" )  {  if (  !   is.null (  highlight ) )  {   idx -  (   names %in%  highlight )   important -   c (  \"4\" ) } else  {   message (  \"Missing highlight argument\" )   return (  NULL ) } } else  if (   show.names ==  \"both\" )  {  if (  !   is.null (  highlight ) )  {   idx -    (   up undefined  sig ) |  (   down undefined  sig ) |  (   names %in%  highlight )   important -   c (  \"2\" ,  \"3\" ,  \"4\" ) } else  {   message (  \"Missing highlight argument\" )   return (  NULL ) } } else  {   message (  \"Wrong highlight argument\" )   return (  NULL ) }  if (   any (   threshold %in%  important ) )  {  if (  names.fill )  {   p -    p +   geom_label_repel ( data =   subset (  df ,   threshold %in%  important ) ,   aes ( label =   names [  idx ] , fill =  threshold ) , size =  names.size , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =   color [   as.numeric (  important ) ] ) } else  {   p -   p +   geom_text_repel ( data =   subset (  df ,   threshold %in%  important ) ,   aes ( label =   names [  idx ] ) , size =  names.size , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } } }  if (  !   is.null (  filename ) )  {   ggsave (  p , filename =  filename , width =  width , height =  height , dpi =  dpi ) } else  {   return (  p ) } } ",
    "filename": "methylation.txt"
  }
}

3.
{
  "old_function": {
    "name": "TCGAanalyze_DMR",
    "representation": "TCGAanalyze_DMR",
    "parameters": "function ( data , groupCol = NULL , group1 = NULL , group2 = NULL , plot.filename = \"methylation_volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = expression ( paste ( \"DNA Methylation difference (\" , beta , \"-values)\" ) ) , title = NULL , legend = \"Legend\" , color = c ( \"black\" , \"red\" , \"darkgreen\" ) , label = NULL , xlim = NULL , ylim = NULL , p.cut = 0.01 , probe.names = FALSE , diffmean.cut = 0.2 , paired = FALSE , adj.method = \"BH\" , overwrite = FALSE , cores = 1 , save = TRUE , filename = NULL )",
    "body": "{   .e -   environment ( )    names (  color ) -   as.character (   1 :  3 )  if (   is.null (  groupCol ) )  {   message (  \"Please, set the groupCol parameter\" )   return (  NULL ) }  if (      length (   unique (    colData (  data ) [ ,  groupCol ] ) ) !=  2 undefined   is.null (  group1 ) undefined   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) } else  if (     length (   unique (    colData (  data ) [ ,  groupCol ] ) ) ==  2 undefined  (    is.null (  group1 ) ||   is.null (  group2 ) ) )  {   group1 -    unique (    colData (  data ) [ ,  groupCol ] ) [  1 ]   group2 -    unique (    colData (  data ) [ ,  groupCol ] ) [  2 ] } else  {   message (   paste0 (  \"Group1:\" ,  group1 ) )   message (   paste0 (  \"Group2:\" ,  group2 ) ) } # defining title and label if not specified by the user  if (   is.null (  title ) )  {   title -   paste (  \"Volcano plot\" ,  \"(\" ,  group2 ,  \"vs\" ,  group1 ,  \")\" ) }  if (   is.null (  label ) )  {   label -   c (  \"Not Significant\" ,  \"Hypermethylated\" ,  \"Hypomethylated\" )    label [   2 :  3 ] -   paste (   label [   2 :  3 ] ,  \"in\" ,  group2 ) }   diffcol -   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" )  if (   !  (   diffcol %in%   colnames (   values (   rowRanges (  data ) ) ) ) ||  overwrite )  {   data -   diffmean (  data ,  groupCol , group1 =  group1 , group2 =  group2 )  if (  !  (   diffcol %in%   colnames (   values (   rowRanges (  data ) ) ) ) )   stop (  \"Error!\" ) }   pcol -   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" )  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )  {   pcol -   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) }  if (   !  (   pcol %in%   colnames (   values (  data ) ) ) |  overwrite )  {   data -   calculate.pvalues (  data ,  groupCol ,  group1 ,  group2 , paired =  paired , method =  adj.method , cores =  cores ) # An error should not happen, if it happens (probably due to an incorret # user input) we will stop  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )   stop (  \"Error!\" ) }   log -   paste0 (  \"TCGAanalyze_DMR.\" ,  group1 ,  \".\" ,  group2 )   assign (  log ,   c ( \"groupCol\" =  groupCol , \"group1\" =  group1 , \"group2\" =  group2 , \"plot.filename\" =  plot.filename , \"xlim\" =  xlim , \"ylim\" =  ylim , \"p.cut\" =  p.cut , \"diffmean.cut\" =  diffmean.cut , \"paired\" =  \"paired\" , \"adj.method\" =  adj.method ) )     metadata (  data ) [[  log ] ] -  (   eval (   as.symbol (  log ) ) )   statuscol -   paste (  \"status\" ,  group1 ,  group2 , sep =  \".\" )   statuscol2 -   paste (  \"status\" ,  group2 ,  group1 , sep =  \".\" )     values (  data ) [ ,  statuscol ] -  \"Not Significant\"     values (  data ) [ ,  statuscol2 ] -  \"Not Significant\" # get significant data   sig -     values (  data ) [ ,  pcol ] undefined  p.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated samples compared to old state   hyper -     values (  data ) [ ,  diffcol ] undefined  diffmean.cut    hyper [   is.na (  hyper ) ] -  FALSE  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol ] -  \"Hypermethylated\"  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol2 ] -  \"Hypomethylated\" # hypomethylated samples compared to old state   hypo -     values (  data ) [ ,  diffcol ] undefined  (  -  diffmean.cut )    hypo [   is.na (  hypo ) ] -  FALSE  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol ] -  \"Hypomethylated\"  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol2 ] -  \"Hypermethylated\" # Plot a volcano plot   names -  NULL  if (  probe.names )   names -    values (  data ) $ probeID   TCGAVisualize_volcano ( x =    values (  data ) [ ,  diffcol ] , y =    values (  data ) [ ,  pcol ] , filename =  plot.filename , ylab =  ylab , xlab =  xlab , title =  title , legend =  legend , label =  label , names =  names , x.cut =  diffmean.cut , y.cut =  p.cut )  if (   is.null (  filename ) )   filename -   paste (  groupCol ,  group1 ,  group2 ,  \"rda\" , sep =  \".\" )  if (  save )   save (  data , file =  filename )   return (  data ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_DMR",
    "representation": "TCGAanalyze_DMR",
    "parameters": "function ( data , groupCol = NULL , group1 = NULL , group2 = NULL , plot.filename = \"methylation_volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = expression ( paste ( \"DNA Methylation difference (\" , beta , \"-values)\" ) ) , title = NULL , legend = \"Legend\" , color = c ( \"black\" , \"red\" , \"darkgreen\" ) , label = NULL , xlim = NULL , ylim = NULL , p.cut = 0.01 , probe.names = FALSE , diffmean.cut = 0.2 , paired = FALSE , adj.method = \"BH\" , overwrite = FALSE , cores = 1 , save = TRUE , save.directory = \".\" , filename = NULL )",
    "body": "{   .e -   environment ( )    names (  color ) -   as.character (   1 :  3 ) # Check if object is a summarized Experiment  if (    class (  data ) !=   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   stop (   paste0 (  \"Sorry, but I'm expecting a Summarized Experiment object, but I got a: \" ,   class (  data ) ) ) } # Check if object has NAs  if (   any (   is.na (   assay (  data ) ) ) )  {   stop (   paste0 (  \"Sorry, but we found some NA in your data, please either remove/or replace them\" ) ) }  if (   is.null (  groupCol ) )  {   message (  \"Please, set the groupCol parameter\" )   return (  NULL ) }  if (  !  (   groupCol %in%   colnames (   colData (  data ) ) ) )  {   stop (   paste0 (  \"column \" ,  groupCol ,  \" not found in the object\" ) ) }  if (      length (   unique (    colData (  data ) [ ,  groupCol ] ) ) !=  2 undefined   is.null (  group1 ) undefined   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) } else  if (     length (   unique (    colData (  data ) [ ,  groupCol ] ) ) ==  2 undefined  (    is.null (  group1 ) ||   is.null (  group2 ) ) )  {   group1 -    unique (    colData (  data ) [ ,  groupCol ] ) [  1 ]   group2 -    unique (    colData (  data ) [ ,  groupCol ] ) [  2 ] } else  {   message (   paste0 (  \"Group1:\" ,  group1 ) )   message (   paste0 (  \"Group2:\" ,  group2 ) ) } # Check if groups has at least one sample  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group1 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group1 ,  \" has no samples\" ) ) }  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group2 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group2 ,  \" has no samples\" ) ) } # defining title and label if not specified by the user  if (   is.null (  title ) )  {   title -   paste (  \"Volcano plot\" ,  \"(\" ,  group2 ,  \"vs\" ,  group1 ,  \")\" ) }  if (   is.null (  label ) )  {   label -   c (  \"Not Significant\" ,  \"Hypermethylated\" ,  \"Hypomethylated\" )    label [   2 :  3 ] -   paste (   label [   2 :  3 ] ,  \"in\" ,  group2 ) }   diffcol -   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" )  if (   !  (   diffcol %in%   colnames (   values (  data ) ) ) ||  overwrite )  {   data -   diffmean (  data ,  groupCol , group1 =  group1 , group2 =  group2 , save =  save )  if (  !  (   diffcol %in%   colnames (   values (   rowRanges (  data ) ) ) ) )  {   stop (   paste0 (  \"Error! Not found \" ,  diffcol ) ) } }   pcol -   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" )  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )  {   pcol -   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) }  if (   !  (   pcol %in%   colnames (   values (  data ) ) ) |  overwrite )  {   data -   calculate.pvalues (  data ,  groupCol ,  group1 ,  group2 , paired =  paired , method =  adj.method , cores =  cores , save =  save ) # An error should not happen, if it happens (probably due to an incorret # user input) we will stop  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )   stop (   paste0 (  \"Error! Not found \" ,  pcol ) ) }   log -   paste0 (  \"TCGAanalyze_DMR.\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,  \".\" ,   gsub (  \" \" ,  \".\" ,  group2 ) )   assign (  log ,   c ( \"groupCol\" =  groupCol , \"group1\" =   gsub (  \" \" ,  \".\" ,  group1 ) , \"group2\" =   gsub (  \" \" ,  \".\" ,  group2 ) , \"plot.filename\" =  plot.filename , \"xlim\" =  xlim , \"ylim\" =  ylim , \"p.cut\" =  p.cut , \"diffmean.cut\" =  diffmean.cut , \"paired\" =  \"paired\" , \"adj.method\" =  adj.method ) )     metadata (  data ) [[  log ] ] -  (   eval (   as.symbol (  log ) ) )   statuscol -   paste (  \"status\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" )   statuscol2 -   paste (  \"status\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" )     values (  data ) [ ,  statuscol ] -  \"Not Significant\"     values (  data ) [ ,  statuscol2 ] -  \"Not Significant\" # get significant data   sig -     values (  data ) [ ,  pcol ] undefined  p.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated samples compared to old state   hyper -     values (  data ) [ ,  diffcol ] undefined  diffmean.cut    hyper [   is.na (  hyper ) ] -  FALSE  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol ] -  \"Hypermethylated\"  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol2 ] -  \"Hypomethylated\" # hypomethylated samples compared to old state   hypo -     values (  data ) [ ,  diffcol ] undefined  (  -  diffmean.cut )    hypo [   is.na (  hypo ) ] -  FALSE  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol ] -  \"Hypomethylated\"  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol2 ] -  \"Hypermethylated\" # Plot a volcano plot   names -  NULL  if (  probe.names )   names -    values (  data ) $ probeID  if (   plot.filename !=  FALSE )  {   TCGAVisualize_volcano ( x =    values (  data ) [ ,  diffcol ] , y =    values (  data ) [ ,  pcol ] , filename =  plot.filename , ylab =  ylab , xlab =  xlab , title =  title , legend =  legend , label =  label , names =  names , x.cut =  diffmean.cut , y.cut =  p.cut ) }  if (  save )  { # saving results into a csv file   csv -   paste0 (   paste (  \"DMR_results\" ,   gsub (  \"_\" ,  \".\" ,  groupCol ) ,   gsub (  \" |_\" ,  \".\" ,  group1 ) ,   gsub (  \" |_\" ,  \".\" ,  group2 ) ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".csv\" )   csv -   file.path (  save.directory ,  csv )   message (   paste0 (  \"Saving the results also in a csv file:\" ) ,  csv )   df -   values (  data )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group2 )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol2 ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group1 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group2 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol2 ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group1 ) # get metadata not created by this function   idx -   grep (  \"mean|status|value\" ,   colnames (  df ) , invert =  TRUE )   write.csv2 (   df [ ,   c (    colnames (  df ) [  idx ] ,   paste (  \"mean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"mean\" ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"p.value\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,  statuscol ,   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"p.value\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,  statuscol2 ) ] , file =  csv )  if (   is.null (  filename ) )  {   filename -   paste0 (   paste (   gsub (  \"_\" ,  \".\" ,  groupCol ) ,   gsub (  \" |_\" ,  \".\" ,  group1 ) ,   gsub (  \" |_\" ,  \".\" ,  group2 ) ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".rda\" )   filename -   file.path (  save.directory ,  filename ) } # saving results into R object   save (  data , file =  filename ) }   return (  data ) } ",
    "filename": "methylation.txt"
  }
}

4.
{
  "old_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , names = FALSE , filename = \"starburst.pdf\" , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL )",
    "body": "{   .e -   environment ( )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) } # Preparing methylation   pcol -   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" )  if (  !  (   pcol %in%   colnames (   values (  met ) ) ) )  {   pcol -   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) }  if (  !  (   pcol %in%   colnames (   values (  met ) ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) }   met -   as.data.frame (   rowRanges (  met ) )   aux -   strsplit (   row.names (  exp ) ,  \"\\\\|\" )    exp $ Gene_Symbol -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   volcano -   merge (  met ,  exp , by =  \"Gene_Symbol\" )    volcano $ ID -   paste (   volcano $ Gene_Symbol ,   volcano $ probeID , sep =  \".\" ) # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ]   diffcol -   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ] # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hipermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr ) # Group 2:up regulated and hypomethylated   a -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   a.sig -   subset (  a ,     abs (   a [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   a $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   b.sig -   subset (  b ,     abs (   b [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   b $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 5: hypermethylated   d -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr ) # Group 6: upregulated   e -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 7: downregulated   f -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 8: upregulated and hypermethylated   g -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr )   g.sig -   subset (  g ,     abs (   g [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   g $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr )   h.sig -   subset (  h ,     abs (   h [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   h $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [  idx ,  \"starburst.status\" ] -   state [  i ] } }   size -   rep (  2 ,  4 )   shape -   as.character (   rep (  2 ,  4 ) )   volcano_normal -  volcano   significant -  NULL   s -   list (  a.sig ,  b.sig ,  g.sig ,  h.sig )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.size\" ] -   size [  i ]    volcano [  idx ,  \"shape\" ] -   shape [  i ]   significant -   rbind (  significant ,   volcano [  idx , ] ) } } ## starburst plot   p -    ggplot ( data =  volcano_normal , environment =  .e ,   aes ( x =   volcano_normal $ meFDR2 , y =   volcano_normal $ geFDR2 , colour =   volcano_normal $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (  !   is.null (  significant ) )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show_guide =  FALSE ) }  if (   names ==  TRUE )  {   message (  \"Adding names to genes\" )   s -   list (  a.sig ,  b.sig ,  g.sig ,  h.sig )  for  ( i in  s )  {  if (    nrow (  i ) undefined  0 )  {   p -   p +   annotate (  \"text\" , x =   i $ meFDR2 , y =   1.1 *  (   i $ geFDR2 ) , label =   i $ Gene_Symbol , size =  4.0 , alpha =  .6 ) } } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")   ggsave ( filename =  filename , width =  14 , height =  10 , dpi =  600 ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   subset (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{   .e -   environment ( )   group1 -   gsub (  \" \" ,  \".\" ,  group1 )   group2 -   gsub (  \" \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # somehow the merge changes the names with - to .   pcol -   gsub (  \" |-\" ,  \".\" ,  pcol )   aux -   strsplit (   row.names (  exp ) ,  \"\\\\|\" )    exp $ Gene_Symbol -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   volcano -   merge (  met ,  exp , by =  \"Gene_Symbol\" )    volcano $ ID -   paste (   volcano $ Gene_Symbol ,   volcano $ probeID , sep =  \".\" ) # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ]   diffcol -   gsub (  \" |-\" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hipermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr ) # Group 2:up regulated and hypomethylated   a -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   a.sig -   subset (  a ,     abs (   a [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   a $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   b.sig -   subset (  b ,     abs (   b [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   b $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 5: hypermethylated   d -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr ) # Group 6: upregulated   e -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 7: downregulated   f -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 8: upregulated and hypermethylated   g -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr )   g.sig -   subset (  g ,     abs (   g [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   g $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr )   h.sig -   subset (  h ,     abs (   h [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   h $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [  idx ,  \"starburst.status\" ] -   state [  i ] } }   size -   rep (  2 ,  4 )   shape -   as.character (   rep (  2 ,  4 ) )   volcano_normal -  volcano   significant -  NULL   s -   list (  a.sig ,  b.sig ,  g.sig ,  h.sig )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.size\" ] -   size [  i ]    volcano [  idx ,  \"shape\" ] -   shape [  i ]   significant -   rbind (  significant ,   volcano [  idx , ] ) } } ## starburst plot   p -    ggplot ( data =  volcano_normal , environment =  .e ,   aes ( x =   volcano_normal $ meFDR2 , y =   volcano_normal $ geFDR2 , colour =   volcano_normal $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_Symbol , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_Symbol , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   subset (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  }
}

5.
{
  "old_function": {
    "name": "TCGAprepare",
    "representation": "TCGAprepare",
    "parameters": "function ( query , dir = NULL , samples = NULL , type = NULL , save = FALSE , filename = NULL , add.mutation.genes = FALSE , reannotate = FALSE , summarizedExperiment = TRUE , add.subtype = FALSE )",
    "body": "{  if (   is.null (  dir ) )  {   message (  \"Argument dir is NULL. Plese provide the directory\r\n                with the folders to be prepared. \" )   return (  NULL ) }  if (     length (   unique (   query $ Platform ) ) undefined  1 |    length (   unique (   query $ Center ) ) undefined  2 )  { # This case (27k/450k)accepts two platforms  if (   all (   grepl (  \"HumanMethylation[0-9]{2,3}\" ,   unique (   query $ Platform ) ) ) )  {   platform -  \"humanMethylation\" } else  {   message (  \"Sorry! But, for the moment, we can only prepare on type of\r\n                    platform per call\" )   return (  NULL ) } } else  {   platform -   unique (   query $ Platform ) } # Get all files from directory except MANIFEST, README, etc   files -  NULL   dirs -   gsub (  \".tar.gz\" ,  \"\" ,   basename (   query $ deployLocation ) )  for  ( i in   seq_along (  dirs ) )  {   aux -   list.files (   file.path (  dir ,   dirs [  i ] ) , full.names =  TRUE , recursive =  TRUE )   files -   c (  files ,  aux ) }   idx -   grep (  \"MANIFEST|README|CHANGES|DESCRIPTION|DATA_USE\" ,  files )  if (    length (  idx ) undefined  0 )  {   files -   files [  -  idx ] } # Filter by samples  if (  !   is.null (  samples ) )  {   files -   filterFiles (   query [  i , ] ,  samples ,  files )  if (    length (  files ) ==  0 )  {   message (  \"No files for that samples found\" )   return (  NULL ) } }   pb -   txtProgressBar ( min =  0 , max =   length (  files ) , style =  3 )   df -  NULL   rse -  NULL  if (   grepl (  \"humanmethylation\" ,   tolower (  platform ) ) )  {   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , skip =  1 , colClasses =   c (  \"character\" , # Composite Element REF  \"numeric\" , # beta value  \"character\" , # Gene symbol  \"character\" , # Chromosome  \"integer\" ) ) # Genomic coordinate   setnames (  data ,   gsub (  \" \" ,  \"\\\\.\" ,   colnames (  data ) ) )   setnames (  data ,  2 ,   barcode [  i ] )  if (   i ==  1 )  {   setcolorder (  data ,   c (  1 ,   3 :  5 ,  2 ) )   df -  data } else  {   data -   subset (  data , select =   c (  1 ,  2 ) )   df -   merge (  df ,  data , by =  \"Composite.Element.REF\" ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {   gene.GR -   GRanges ( seqnames =   paste0 (  \"chr\" ,   gene.location $ chromosome_name ) , ranges =   IRanges ( start =   gene.location $ start_position , end =   gene.location $ end_position ) , strand =   gene.location $ strand , symbol =   gene.location $ external_gene_name , EntrezID =   gene.location $ entrezgene )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   df $ Chromosome ) , ranges =   IRanges ( start =   df $ Genomic_Coordinate , end =   df $ Genomic_Coordinate ) , probeID =   df $ Composite.Element.REF , Gene_Symbol =   df $ Gene_Symbol )    names (  rowRanges ) -   as.character (   df $ Composite.Element.REF )   colData -   colDataPrepare (    colnames (  df ) [   5 :   ncol (  df ) ] ,  query , add.subtype =  add.subtype )   assay -   data.matrix (   subset (  df , select =   c (   5 :   ncol (  df ) ) ) )  if (  reannotate )  {   message (  \"Reannotating genes Source:http://grch37.ensembl.org/\" )   gene.location -   gene.location [    gene.location $ chromosome_name %in%   c (   1 :  22 ,  \"X\" ,  \"Y\" ) , ]   gene.location -   gene.location [  !   is.na (   gene.location $ entrezgene ) , ]   gene.location -   gene.location [  !   duplicated (   gene.location $ entrezgene ) , ]   gene.GR -   GRanges ( seqnames =   paste0 (  \"chr\" ,   gene.location $ chromosome_name ) , ranges =   IRanges ( start =   gene.location $ start_position , end =   gene.location $ end_position ) , strand =   gene.location $ strand , symbol =   gene.location $ external_gene_name , EntrezID =   gene.location $ entrezgene )   probe.info -  rowRanges   distance -   as.data.frame (   distanceToNearest (  rowRanges ,  gene.GR ) )   gene.order.by.distance -   gene.location [   distance $ subjectHits , ]    gene.order.by.distance $ distance -   as.matrix (   distance $ distance )    rowRanges $ distance -   gene.order.by.distance [ ,   c (  \"distance\" ) ]    rowRanges $ Gene_Symbol -   gene.order.by.distance [ ,   c (  \"external_gene_name\" ) ]    rowRanges $ entrezgene -   gene.order.by.distance [ ,   c (  \"entrezgene\" ) ] }   rse -   SummarizedExperiment ( assays =  assay , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df $ Composite.Element.REF    df $ Composite.Element.REF -  NULL } }  if (   grepl (  \"mda_rppa_core\" ,   tolower (  platform ) ) )  {   message (   paste (  \"Sorry, but for this platform we haven't prepared\" ,  \"the data into a summarizedExperiment object.\" ,  \"\\nBut we will do it soon! The return is a data frame\" ) )   regex -   paste0 (  \"[:alnum:]{8}-[:alnum:]{4}\" ,  \"-[:alnum:]{4}-[:alnum:]{4}-[:alnum:]{12}\" )   uuid -   str_match (  files ,  regex )   map -   mapuuidbarcode (  uuid )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , data.table =  FALSE )   data -   data [  -  1 , ] # removing Composite Element REF   x -   subset (  map ,   uuid ==   uuid [  i ] )     colnames (  data ) [  2 ] -   as.character (   x $ barcode )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =  \"Sample REF\" , all =  TRUE ) }   setTxtProgressBar (  pb ,  i ) }    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL }  if (   grepl (  \"illuminaga_dnaseq\" ,   tolower (  platform ) ) )  {   message (   paste (  \"Sorry, but for this platform we haven't prepared\" ,  \"the data into a summarizedExperiment object.\" ,  \"\\nBut we will do it soon! The return is a data frame of the maf file\" ) )   idx -   grep (  \"maf\" ,  files )  if (    length (  idx ) ==  0 )  {   message (  \"Sorry, we are preparing only maf files\" )   return (  NULL ) }   files -   files [  idx ]  for  ( i in   seq_along (  files ) )  {   data -   read.table (   files [  i ] , fill =  TRUE , comment.char =  \"#\" , header =  TRUE , sep =  \"\\t\" , quote =  \"\" ) # some center has different ways to name the collums   idx.pos -   grep (  \"Start_position\" ,   colnames (  data ) )     colnames (  data ) [  idx.pos ] -  \"Start_Position\"   idx.pos -   grep (  \"End_position\" ,   colnames (  data ) )     colnames (  data ) [  idx.pos ] -  \"End_Position\"  if (   i ==  1 )  {   df -  data } else  {   df -   plyr :: rbind.fill (  df ,  data ) }   setTxtProgressBar (  pb ,  i ) } }  if (   grepl (  \"illuminadnamethylation_oma\" ,  platform , ignore.case =  TRUE ) )  {  for  ( i in   seq_along (  files ) )  {   data -   read.table (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , check.names =  FALSE , comment.char =  \"#\" , fill =  TRUE )   data -   data [  -  1 , ] # removing Composite Element REF  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =  \"Hybridization REF\" ) }   setTxtProgressBar (  pb ,  i ) }    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL }  if (     tolower (  platform ) ==  \"illuminaga_rnaseq\" ||    tolower (  platform ) ==  \"illuminahiseq_rnaseq\" )  {  if (    is.null (  type ) ||  (     type !=  \"exon.quantification\" undefined   type !=  \"spljxn.quantification\" undefined   type !=  \"gene.quantification\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = gene.quantification\\n\" ,  \" = spljxn.quantification\\n\" ,  \" = exon.quantification\\n\" )   message (  msg )   return ( ) }   files -   files [   grep (  type ,  files ) ] # Barcode in the name   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   setnames (  data ,    colnames (  data ) [   2 :   ncol (  data ) ] ,   paste0 (    colnames (  data ) [   2 :   ncol (  data ) ] ,  \"_\" ,   barcode [  i ] ) ) # removing duplicated rows   data -   subset (  data , subset =  (  !   duplicated (   data [ ,  1 , with =  FALSE ] ) ) )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data ,    colnames (  data ) [  1 ] ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {  if (   grepl (  \"gene\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ gene ,  \"\\\\|\" )   GeneID -   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) )    df $ entrezgene -   as.numeric (  GeneID )   merged -   merge (  df ,  gene.location , by =  \"entrezgene\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene )    names (  rowRanges ) -   as.character (   merged $ gene )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   ncol (  df ) ,  3 ) ) ) , median_length_normalized =   data.matrix (   subset (  merged , select =   seq (  4 ,   ncol (  df ) ,  3 ) ) ) , RPKM =   data.matrix (   subset (  merged , select =   seq (  5 ,   ncol (  df ) ,  3 ) ) ) ) } else  if (   grepl (  \"junction\" ,    colnames (  df ) [  1 ] ) )  { # junction example: chr1:12227:+,chr1:12595:+   aux -   strsplit (   df $ junction ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   x -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) )   y -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  4 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  5 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ junction )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   2 :   ncol (  df ) ) ) ) } else  if (   grepl (  \"exon\" ,    colnames (  df ) [  1 ] ) )  { # exon chr1:11874-12227:+   aux -   strsplit (   df $ exon ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   start.end -   strsplit (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) ,  \"-\" )   x -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  1 ] ) ) )   y -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  2 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  3 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ exon )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   seq (  2 ,   ncol (  df ) ,  3 ) ) ) , median_length_normalized =   data.matrix (   subset (  df , select =   seq (  3 ,   ncol (  df ) ,  3 ) ) ) , RPKM =   data.matrix (   subset (  df , select =   seq (  4 ,   ncol (  df ) ,  3 ) ) ) ) }   colData -   colDataPrepare (   as.character (  barcode ) ,  query , add.subtype =  add.subtype )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL } }  if (    tolower (  platform ) ==   tolower (  \"HT_HG-U133A\" ) )  { # Barcode in the mage file  if (   is.vector (  query ) )  {   mage -   getMage (  query ) } else  {   mage -   getMage (   query [  1 , ] ) }  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , skip =  1 , stringsAsFactors =  FALSE , data.table =  FALSE )  if (   i ==  1 )  {   df -  data } else  {   df -   cbind (  df ,   data [ ,  2 ] ) }   setTxtProgressBar (  pb ,  i ) }   names -   sapply (  files ,  function ( x )  {   y -    fread (  x , header =  FALSE , stringsAsFactors =  FALSE , nrows =  1 ) $ V2   idx -   grep (  y ,   mage $ Hybridization.Name )    mage [  idx , ] $ Comment..TCGA.Barcode. } )   setnames (  df ,   2 :   ncol (  df ) ,  names )  if (  summarizedExperiment )  { # TODO create GRanges #df$external_gene_name    df $ external_gene_name -   df $ `Composite Element REF`   merged -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene , alias =   merged $ `Composite Element REF` )    names (  rowRanges ) -   as.character (   merged $ `Composite Element REF` )   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  merged ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   2 +   length (  barcode ) ) ) ) )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } }  if (     tolower (  platform ) ==   tolower (  \"HG-U133_Plus_2\" ) ||   grepl (  \"H-miRNA_8x15K|agilent\" ,  platform , ignore.case =  TRUE ) )  {  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data ,    colnames (  data ) [  1 ] ) } #setTxtProgressBar(pb, i) }   df -   df [  -  1 , ]  if (  summarizedExperiment )  {   message (  \"===================================================================================\" )   message (  \" As we can't map some miRNA to genomic positions this step might loose some rows .\" )   message (  \" Please, for all rows run TCGAprepare with summarizedExperiment=F\" )   message (  \"====================================================================================\" )  if (   grepl (  \"HG-U133_Plus_2|agilent\" ,  platform , ignore.case =  TRUE ) )  {   suppressWarnings (    df $ external_gene_name -   alias2SymbolTable (   df $ `Hybridization REF` ) )   merged -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   merged $ chromosome_name ) , ranges =   IRanges ( start =   merged $ start_position , end =   merged $ end_position ) , strand =   merged $ strand , gene_id =   merged $ external_gene_name , entrezgene =   merged $ entrezgene , alias =   merged $ `Hybridization REF` )    names (  rowRanges ) -   as.character (   merged $ `Hybridization REF` ) } else  {   microRNA -   as.data.frame (   microRNAs (  TxDb.Hsapiens.UCSC.hg19.knownGene ) )    df $ mirna_id -   tolower (   df $ `Hybridization REF` )   merged -   merge (  df ,  microRNA , by =  \"mirna_id\" )   rowRanges -   GRanges ( seqnames =   merged $ seqnames , ranges =   IRanges ( start =   merged $ start , end =   merged $ end ) , strand =   merged $ strand , mirna_id =   merged $ mirna_id )    names (  rowRanges ) -   as.character (   merged $ mirna_id ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  merged ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   suppressWarnings (   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  merged , select =   seq (  3 ,   2 +   length (  barcode ) ) ) ) ) )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   df -   as.data.frame (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL   df -   data.matrix (  df ) } }  if (   grepl (  \"rnaseqv2\" ,  platform , ignore.case =  TRUE ) )  {  if (    is.null (  type ) ||  (        type !=  \"rsem.genes.results\" undefined   type !=  \"rsem.isoforms.results\" undefined   type !=  \"rsem.genes.normalized_results\" undefined   type !=  \"rsem.isoforms.normalized_results\" undefined   type !=  \"bt.exon_quantification\" undefined   type !=  \"junction_quantification\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = rsem.genes.results\\n\" ,  \" = rsem.isoforms.results\\n\" ,  \" = rsem.genes.normalized_results\\n\" ,  \" = rsem.isoforms.normalized_results\\n\" ,  \" = bt.exon_quantification\\n\" ,  \" = junction_quantification\" )   message (  msg )   return ( ) }   files -   files [   grep (  type ,  files , perl =  TRUE ) ]   regex -   paste0 (  \"[:alnum:]{8}-[:alnum:]{4}\" ,  \"-[:alnum:]{4}-[:alnum:]{4}-[:alnum:]{12}\" )   uuid -   str_match (  files ,  regex )   map -   mapuuidbarcode (  uuid )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   x -   subset (  map ,   uuid ==   uuid [  i ] )  if (  summarizedExperiment )  {   setnames (  data ,    colnames (  data ) [   2 :   ncol (  data ) ] ,   paste0 (    colnames (  data ) [   2 :   ncol (  data ) ] ,  \"_\" ,   x $ barcode ) ) } else  {   setnames (  data ,  2 ,   as.character (   x $ barcode ) ) }  if (   i ==  1 )  {   df -  data } else  {   df -   cbind (  df ,   data [ ,   2 :   ncol (  data ) , with =  FALSE ] ) }   setTxtProgressBar (  pb ,  i ) }  if (  summarizedExperiment )  {  if (   grepl (  \"gene_id\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ gene_id ,  \"\\\\|\" )   GeneID -   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) )    df $ entrezid -   as.numeric (  GeneID )   GeneSymbol -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )    df $ external_gene_name -   as.character (  GeneSymbol )   df -   merge (  df ,  gene.location , by =  \"external_gene_name\" )   rowRanges -   GRanges ( seqnames =   paste0 (  \"chr\" ,   df $ chromosome_name ) , ranges =   IRanges ( start =   df $ start_position , end =   df $ end_position ) , strand =   df $ strand , gene_id =   df $ external_gene_name , entrezgene =   df $ entrezid , transcript_id =   subset (  df , select =  5 ) )    names (  rowRanges ) -   as.character (   df $ gene_id )  if (    length (   colnames (  data ) ) undefined  2 )  {   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   grep (  \"raw_count\" ,   colnames (  df ) ) ) ) , scaled_estimate =   data.matrix (   subset (  df , select =   grep (  \"scaled_estimate\" ,   colnames (  df ) ) ) ) ) } else  { # case genes.normalized_results   assays -   SimpleList ( normalized_count =   data.matrix (   subset (  df , select =   grep (  \"normalized_count\" ,   colnames (  df ) ) ) ) ) } } else  if (   grepl (  \"junction\" ,    colnames (  df ) [  1 ] ) )  {   aux -   strsplit (   df $ junction ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   x -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) )   y -   as.numeric (   unlist (   lapply (  aux ,  function ( x )   x [  4 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  5 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ junction )   assays -   SimpleList ( raw_counts =   data.matrix (   subset (  df , select =   2 :   ncol (  df ) ) ) ) } else  if (   grepl (  \"exon\" ,    colnames (  df ) [  1 ] ) )  { # exon chr1:11874-12227:+   aux -   strsplit (   df $ exon ,  \":\" )   name -   unlist (   lapply (  aux ,  function ( x )   x [  1 ] ) )   start.end -   strsplit (   unlist (   lapply (  aux ,  function ( x )   x [  2 ] ) ) ,  \"-\" )   x -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  1 ] ) ) )   y -   as.numeric (   unlist (   lapply (  start.end ,  function ( x )   x [  2 ] ) ) )   start -   apply (   data.frame (  x ,  y ) ,  1 ,  min )   end -   apply (   data.frame (  x ,  y ) ,  1 ,  max )   strand -   unlist (   lapply (  aux ,  function ( x )   x [  3 ] ) )   rowRanges -   GRanges ( seqnames =  name , ranges =   IRanges ( start =  start , end =  end ) , strand =  strand )    names (  rowRanges ) -   as.character (   df $ exon )   assays -   SimpleList ( raw_counts =   data.matrix (   df [ ,   grep (  \"raw_count\" ,   colnames (  df ) ) , with =  FALSE ] ) , median_length_normalized =   data.matrix (   df [ ,   grep (  \"median_length\" ,   colnames (  df ) ) , with =  FALSE ] ) , RPKM =   data.matrix (   df [ ,   grep (  \"RPKM\" ,   colnames (  df ) ) , with =  FALSE ] ) ) } else  if (   grepl (  \"isoform\" ,    colnames (  df ) [  1 ] ) )  {   message (  \"TBD\" )   return (  NULL ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   unique (   unlist (   str_match_all (   colnames (  df ) ,  regex ) ) )   colData -   colDataPrepare (  barcode ,  query , add.subtype =  add.subtype )   rse -   SummarizedExperiment ( assays =  assays , rowRanges =  rowRanges , colData =  colData ) } else  {   setDF (  df )    rownames (  df ) -   df [ ,  1 ]    df [ ,  1 ] -  NULL } }  if (   grepl (  \"illuminahiseq_mirnaseq\" ,  platform , ignore.case =  TRUE ) )  {  if (    is.null (  type ) ||  (    type !=  \"hg19.mirna\" undefined   type !=  \"mirna\" ) )  {   msg -   paste0 (  \"Plase select a type. \\n Possibilities:\\n\" ,  \" = hg19.mirna\\n = mirna\" )   message (  msg )   return ( ) }  if (   type ==  \"hg19.mirna\" )   pat -  \"(hg19.)mirna\"  if (   type ==  \"mirna\" )   pat -  \"(?   files -   files [   grep (  pat ,  files , perl =  TRUE ) ]  if (    length (  files ) ==  0 )  {   message (  \"No mirna files of that type found\" )   return (  NULL ) }   regex -   paste0 (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}\" ,  \"-[:alnum:]{3}-[:alnum:]{3}-[:alnum:]{4}-[:alnum:]{2}\" )   barcode -   str_match (  files ,  regex )  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE )   data -   subset (  data , select =   c (   1 :  3 ) )   setnames (  data ,   2 :   ncol (  data ) ,   paste0 (   as.character (   barcode [  i ] ) ,  \".\" ,    colnames (  data ) [   2 :   ncol (  data ) ] ) )  if (   i ==  1 )  {   df -  data } else  {   df -   merge (  df ,  data , by =    colnames (  data ) [  1 ] ) } }   setDF (  df )    rownames (  df ) -   df [ ,  1 ]   df -   df [ ,  -  1 ] }  if (   grepl (  \"bio\" ,  platform , ignore.case =  TRUE ) )  {  if (  !   is.null (  type ) )  {   files -   files [   grep (  type ,  files ) ] }  if (    length (  files ) ==  1 )  {   df -   read.table (  files , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , check.names =  FALSE , comment.char =  \"#\" , fill =  TRUE , quote =  \"\" )   regex -   paste0 (  \"[[:alnum:]]{8}-[[:alnum:]]{4}\" ,  \"-[[:alnum:]]{4}-[[:alnum:]]{4}-[[:alnum:]]{12}\" )  if (   grepl (  \"clinical\" ,  type ) )    colnames (  df ) -   df [  1 , ]   idx -   grepl (  regex ,   df $ bcr_patient_uuid )   df -   df [  idx , ] } else  {   message (  \"We're preaparing for the moment only one clinical file\" )   return (  NULL ) } }  if (   grepl (  \"genome_wide_snp_6\" ,   tolower (  platform ) ) )  {  while (  !  (   type %in%   c (  \"nocnv_hg18\" ,  \"nocnv_hg19\" ,  \"cnv_hg18\" ,  \"cnv_hg19\" ,  \"nocnv_hg18.seg\" ,  \"hg18.seg\" ,  \"hg19.seg\" ,  \"nocnv_hg19.seg\" ) ) )  {   type -   readline (   paste (  \"Which type do you want?\" ,  \"(Options: nocnv_hg19,nocnv_hg18,cnv_hg18,cnv_hg19, cancel)  \" ) )  if (   type ==  \"cancel\" )   return (  NULL ) }  if (    type ==  \"nocnv_hg18\" |   type ==  \"nocnv_hg18.seg\" )   regex -  \"nocnv_hg18\"  if (    type ==  \"cnv_hg18\" |   type ==  \"hg18.seg\" )   regex -  \"[^nocnv_]hg18.seg\"  if (    type ==  \"nocnv_hg19\" |   type ==  \"nocnv_hg19.seg\" )   regex -  \"nocnv_hg19\"  if (    type ==  \"cnv_hg19\" |   type ==  \"hg19.seg\" )   regex -  \"[^nocnv_]hg19.seg\"   files -   files [   grep (  regex ,  files ) ]  if (    length (  files ) ==  0 )  {   message (  \"No files of that type found\" )   return (  NULL ) }   idx -   grep (  regex ,  files )  if (    length (  idx ) undefined  0 )  {   files -   files [  idx ] } else  {   message (  \"No files of that type found\" )   return (  NULL ) }  if (   is.vector (  query ) )  {   mage -   getMage (  query ) } else  {   mage -   getMage (   query [  1 , ] ) }  for  ( i in   seq_along (  files ) )  {   data -   fread (   files [  i ] , header =  TRUE , sep =  \"\\t\" , stringsAsFactors =  FALSE , data.table =  FALSE , colClasses =   c (  \"character\" , # ID  \"character\" , # chrom  \"numeric\" , # start  \"numeric\" , # end  \"integer\" , # num_probes  \"numeric\" ) ) # seg mean  if (   i ==  1 )   df -  data  if (   i !=  1 )   df -   rbind (  df ,  data , make.row.names =  FALSE )   setTxtProgressBar (  pb ,  i ) }   mage -   mage [ ,   c (  \"Comment..TCGA.Barcode.\" ,  \"Hybridization.Name\" ) ]   df -   merge (  df ,  mage , by.x =  \"Sample\" , by.y =  \"Hybridization.Name\" , sort =  FALSE )    df [ ,  1 ] -   df [ ,  7 ]    df [ ,  7 ] -  NULL }   close (  pb )  if (  !   is.null (  rse ) )  {   message (  \"Adding metadata to the rse object...\" )   finf -   c ( )   finf -   file.info (  files )    rownames (  finf ) -   basename (   rownames (  finf ) )   finf -   finf [ ,   c (  \"mtime\" ,  \"ctime\" ) ]    metadata (  rse ) -   list ( \"Query:\" =   list (  query ) , \"TCGAprepareParameters\" =   c ( \"dir\" =  dir , \"samples\" =  samples , \"type\" =  type , \"save\" =  save , \"add.mutation.genes\" =  add.mutation.genes , \"filename\" =  filename ) , \"FilesInfo:\" =   list (  finf ) ) }  if (   add.mutation.genes undefined  summarizedExperiment )  {    colData (  rse ) -   DataFrame (   mutation.genes (   unique (   query $ Disease ) ,   colData (  rse ) ) ) }  if (  save )  {   message (  \"Saving the data...\" )  if (   is.null (  filename ) )  {   filename -   paste0 (  platform ,  \"_\" ,   gsub (  \" \" ,  \"_\" ,   Sys.time ( ) ) ,  \".rda\" ) }  if (  !   is.null (  rse ) )  {   save (  rse , file =  filename ) } else  {   save (  df , file =  filename ) }   message (   paste (  \"Data saved in:\" ,  filename ) ) }  if (  !   is.null (  rse ) )  {   return (  rse ) }   return (  df ) } ",
    "filename": "TCGAPrepare.txt"
  },
  "new_function": {
    "name": "TCGAprepare",
    "representation": "TCGAprepare",
    "parameters": "function ( query = NULL , dir = NULL , samples = NULL , type = NULL , save = FALSE , filename = NULL , summarizedExperiment = TRUE )",
    "body": "{   stop (  \"TCGA data has moved from DCC server to GDC server. Please use GDCprepare function\" ) } ",
    "filename": "TCGAPrepare.txt"
  }
}

6.
{
  "old_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( cancer , DFfilt , DFclin , DFsubt , data_Hc2 , cbPalette , filename = NULL )",
    "body": "{    rownames (  DFsubt ) -   DFsubt $ patient    rownames (  DFclin ) -   DFclin $ patient    rownames (  DFfilt ) -   substr (   rownames (  DFfilt ) ,  1 ,  12 )   ans -   hclust (   ddist -   dist (  DFfilt ) , method =  \"ward.D2\" )   hhc -    data_Hc2 [[  4 ] ] $ consensusTree   consensusClusters -    data_Hc2 [[  4 ] ] $ consensusClass   sampleOrder -   consensusClusters [   hhc $ order ]   consensusClusters -   as.factor (     data_Hc2 [[  4 ] ] $ clrs [[  1 ] ] )    names (  consensusClusters ) -   attr (  ddist ,  \"Labels\" )    names (  consensusClusters ) -   substr (   names (  consensusClusters ) ,  1 ,  12 ) #DFclin   DFclin_merged -   cbind (  DFclin ,   matrix (  0 ,   nrow (  DFclin ) ,   ncol (  DFsubt ) ) )     colnames (  DFclin_merged ) [   (   (    ncol (  DFclin_merged ) -   ncol (  DFsubt ) ) +  1 ) :   ncol (  DFclin_merged ) ] -   colnames (  DFsubt )    rownames (  DFclin_merged ) -   DFclin_merged $ bcr_patient_barcode  for  ( i in   1 :   ncol (  DFsubt ) )  {    DFsubt [ ,  i ] -   as.character (   DFsubt [ ,  i ] ) }  for  ( i in   1 :   nrow (  DFsubt ) )  {   curSample -    DFsubt $ patient [  i ]  for  ( j in   1 :   ncol (  DFsubt ) )  {   curColumn -    colnames (  DFsubt ) [  j ]    DFclin_merged [  curSample ,  curColumn ] -   DFsubt [  curSample ,  curColumn ] } } # adding information about gropus from consensus Cluster in clinical data   DFclin_merged -   cbind (  DFclin_merged , groupsHC =   matrix (  0 ,   nrow (  DFclin_merged ) ,  1 ) )    rownames (  DFclin_merged ) -   DFclin_merged $ bcr_patient_barcode  for  ( i in   1 :   nrow (  DFclin_merged ) )  {   currSmp -    DFclin_merged $ bcr_patient_barcode [  i ]    DFclin_merged [  currSmp ,  \"groupsHC\" ] -   as.character (   consensusClusters [  currSmp ] ) }   groupsColors -   levels (   as.factor (   DFclin_merged $ groupsHC ) )  for  ( j in   1 :   length (   table (   DFclin_merged $ groupsHC ) ) )  {   curCol -   groupsColors [  j ]    DFclin_merged [    DFclin_merged $ groupsHC ==  curCol ,  \"groupsHC\" ] -   paste0 (  \"EC\" ,  j ) }   DFfilt -   DFfilt [   rownames (  DFclin_merged ) , ]   orderCL -   as.character (   substr (   names (  sampleOrder ) ,  1 ,  12 ) )   orderCL -   intersect (  orderCL ,   rownames (  DFfilt ) )   GE -   t (   .quantileNormalization (   t (  DFfilt ) ) )    rownames (  GE ) -   substr (   rownames (  GE ) ,  1 ,  12 )   oGE -   GE [  orderCL , ] #ordering according cluster   DFclin_merged -   DFclin_merged [  orderCL , ] # histology   HISTOLOGY -   DFclin_merged [ ,  \"histological_type\" ]    names (  HISTOLOGY ) -   rownames (  DFclin_merged )   HISTOLOGY -   HISTOLOGY [   rownames (  GE ) ]   HISTOLOGY.col -   rep (  \"white\" ,   length (  HISTOLOGY ) )    HISTOLOGY.col [   HISTOLOGY ==  \"Astrocytoma\" ] -  \"red\"    HISTOLOGY.col [   HISTOLOGY ==  \"glioblastoma\" ] -  \"purple\"    HISTOLOGY.col [   HISTOLOGY ==  \"Oligoastrocytoma\" ] -  \"cyan\"    HISTOLOGY.col [   HISTOLOGY ==  \"Oligodendroglioma\" ] -  \"green3\"    names (  HISTOLOGY.col ) -   names (  HISTOLOGY )   oHISTOLOGY.col -   HISTOLOGY.col [  orderCL ] #subtype   SUBTYPE -   DFclin_merged [ ,  \"IDH.1p19q.Subtype\" ]    names (  SUBTYPE ) -   rownames (  DFclin_merged )   SUBTYPE -   SUBTYPE [   rownames (  GE ) ]   SUBTYPE.col -   rep (  \"white\" ,   length (  SUBTYPE ) )    SUBTYPE.col [   SUBTYPE ==  \"IDHmut-codel\" ] -  \"cyan\"    SUBTYPE.col [   SUBTYPE ==  \"IDHmut-non-codel\" ] -  \"tomato\"    SUBTYPE.col [   SUBTYPE ==  \"IDHwt\" ] -  \"gold\"    names (  SUBTYPE.col ) -   names (  SUBTYPE )   oSUBTYPE.col -   SUBTYPE.col [  orderCL ] #clusters CNCluster   CNC -   DFclin_merged [ ,  \"CNCluster\" ]    names (  CNC ) -   rownames (  DFclin_merged )   CNC -   CNC [   rownames (  GE ) ]   CNC.col -   rep (  \"white\" ,   length (  CNC ) )    names (  CNC.col ) -   names (  CNC )    CNC.col [   CNC ==  \"C1\" ] -  \"green\"    CNC.col [   CNC ==  \"C2\" ] -  \"red\"    CNC.col [   CNC ==  \"C3\" ] -  \"purple\"   oCNC.col -   CNC.col [  orderCL ] #clusters COCluster   COC -   DFclin_merged [ ,  \"COCCluster\" ]    names (  COC ) -   rownames (  DFclin_merged )   COC -   COC [   rownames (  GE ) ]   COC.col -   rep (  \"white\" ,   length (  COC ) )    names (  COC.col ) -   names (  COC )    COC.col [   COC ==  \"coc1\" ] -  \"green\"    COC.col [   COC ==  \"coc2\" ] -  \"red\"    COC.col [   COC ==  \"coc3\" ] -  \"purple\"   oCOC.col -   COC.col [  orderCL ] #clusters ONCOluster   ONCO -   DFclin_merged [ ,  \"OncosignCluster\" ]    names (  ONCO ) -   rownames (  DFclin_merged )   ONCO -   ONCO [   rownames (  GE ) ]   ONCO.col -   rep (  \"white\" ,   length (  ONCO ) )    names (  ONCO.col ) -   names (  ONCO )    ONCO.col [   ONCO ==  \"OSC1\" ] -  \"green\"    ONCO.col [   ONCO ==  \"OSC2\" ] -  \"red\"    ONCO.col [   ONCO ==  \"OSC3\" ] -  \"purple\"    ONCO.col [   ONCO ==  \"OSC4\" ] -  \"orange\"    ONCO.col [   ONCO ==  \"Unclassified\" ] -  \"gray\"   oONCO.col -   ONCO.col [  orderCL ]   oConsensus -   as.character (   consensusClusters [   hhc $ order ] ) #oConsensus   names (   consensusClusters [   hhc $ order ] ) #source(\"heatmap.plus.R\")   cc.col -   matrix (   c (  oHISTOLOGY.col ,  oSUBTYPE.col ,  oCNC.col ,  oCOC.col ,  oONCO.col ,   as.character (  oConsensus ) ) , nrow =   nrow (  oGE ) , ncol =  6 )    colnames (  cc.col ) -   c (  \"Histology\" ,  \"Subtype\" ,  \"CNCluster\" ,  \"COCCluster\" ,  \"OncosignCluster\" ,  \"Expression Cluster\" )   cc.col -   as.data.frame (  cc.col )    rownames (  cc.col ) -  orderCL   cc.col -   cc.col [   order (   cc.col $ `Expression Cluster` ) , ]   cc.col -   as.matrix (  cc.col )   oGE -   oGE [   rownames (  cc.col ) , ]  if (  !  (   is.null (    dev.list ( ) [  \"RStudioGD\" ] ) ) )  {   dev.off ( ) }   curDate -   as.character (    unlist (   strsplit (   gsub (  \" \" ,  \"_h\" ,   gsub (  \"-\" ,  \"_\" ,   as.character (   Sys.time ( ) ) ) ) ,  \":\" ) ) [  1 ] )   pdf ( file =   paste0 (  curDate ,  \"_\" ,  cancer ,  \"_heatmap_with_subtypes_withHeatmapPlus.pdf\" ) )   .heatmap.plus.sm (   t (  oGE ) , na.rm =  TRUE , scale =  \"none\" , #RowSideColor=probe.cc, #ColSideColors=cc.col, col =   gplots :: greenred (  75 ) , key =  FALSE , #changed symkey =  FALSE , density.info =  \"none\" , trace =  \"none\" , Rowv =  FALSE , Colv =  NA , cexRow =  1 , cexCol =  1.6 , keysize =  2 , dendrogram =  \"none\" , main =  \"Heatmap from consensus cluster\" , labRow =  NA , labCol =  NA , #labCol=NA )   dev.off ( ) } ",
    "filename": "TCGAvisualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( data , col.metadata , row.metadata , col.colors = NULL , row.colors = NULL , show_column_names = FALSE , show_row_names = FALSE , cluster_rows = FALSE , cluster_columns = FALSE , sortCol , extrems = NULL , rownames.size = 12 , title = NULL , color.levels = NULL , values.label = NULL , filename = \"heatmap.pdf\" , width = 10 , height = 10 , type = \"expression\" , scale = \"none\" , heatmap.legend.color.bar = \"continuous\" )",
    "body": "{ # STEP 1 add columns labels (top of heatmap)   ha -  NULL  if (  !   missing (  col.metadata ) )  {  if (  !   is.null (  col.metadata ) )  {   id -  NULL  if (   \"patient\" %in%   colnames (  col.metadata ) )  {   id -  \"patient\"   size -  12 }  if (   \"barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  28 )   size -  28 }  if (   \"bcr_patient_barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"bcr_patient_barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  12 )   size -  12 }  if (   \"sample\" %in%   colnames (  col.metadata ) )  {   id -  \"sample\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  16 )   size -  16 }  if (   is.null (  id ) )  {   message (  \"=============== INNPUT ERROR =================\" )   message (  \"I'm expecting one of these columns:\" )   message (  \" = )   message (  \"    Has the complete barcode (TCGA-AA-3833-01A-01D-0904-05)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the sample barcode (TCGA-AA-3833-01A)\" )   message (  \"-----------------------------------------------\" )   message (  \"Obs: The complete barcode is the recommended one, as the others might lead to errors\" )   return (  NULL ) }   stopifnot (    nchar (    as.character (   col.metadata [ ,  id ] ) [  1 ] ) ==  size )   message (   paste0 (  \"Reorganizing: col.metadata order should be the same of the data object\" ) )   df -   col.metadata [   match (   substr (   colnames (  data ) ,  1 ,  size ) ,   col.metadata [ ,  id ] ) , ]    df [ ,  id ] -  NULL   duplicated.samples -   any (   sapply (   col.metadata [ ,  id ] ,  function ( x )  {    length (   grep (  x ,   col.metadata [ ,  id ] ) ) undefined  1 } ) )  if (  duplicated.samples )  {   warning (  \"Some samples are from the same patient, this might lead to the wrong upper annotation\" ) }  if (  !   missing (  sortCol ) )  {   message (   paste0 (  \"Sorting columns based on column: \" ,  sortCol ) )   column_order -   order (   df [ ,  sortCol ] ) }  if (   is.null (  col.colors ) )  {   ha -   HeatmapAnnotation ( df =  df ) } else  {   ha -   HeatmapAnnotation ( df =  df , col =  col.colors ) } } } # STEP 2 Create heatmap  if (   is.null (  color.levels ) )  {  if (   type ==  \"expression\" )   color.levels -   c (  \"green\" ,  \"white\" ,  \"red\" )  if (   type ==  \"methylation\" )   color.levels -   c (  \"blue\" ,  \"white\" ,  \"red\" ) } # If we want to show differences between genes, it is good to make Z-score by samples # (force each sample to have zero mean and standard deviation=1). # If we want to show differences between samples, it is good to make Z-score by genes # (force each gene to have zero mean and standard deviation=1).  if (   scale ==  \"row\" )  {   message (  \"Calculating z-scores for the rows....\" )   data -   t (   scale (   t (  data ) ) )   all.na -   apply (  data ,  1 ,  function ( x )   all (   is.na (  x ) ) )   data -   data [  !  all.na , ] } else  if (   scale ==  \"col\" )  {   message (  \"Calculiating z-scores for the columns....\" )   data -   scale (  data ) }  if (   is.null (  extrems ) )  {  if (    min (  data ) undefined  0 )  {   extrems -   c (   min (  data ) ,  0 ,   max (  data ) ) } else  {   extrems -   c (  0 ,    max (  data ) /  2 ,   max (  data ) ) } }  if (   type ==  \"expression\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels )  if (   type ==  \"methylation\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels ) # Creating plot title  if (   is.null (  title ) )  {  if (   type ==  \"methylation\" )   title -  \"DNA methylation heatmap\"  if (   type ==  \"expression\" )   title -  \"Expression heatmap\" } # Change label type   heatmap_legend_param -   list ( )  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"methylation\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param )  if (  !   scale %in%   c (  \"row\" ,  \"col\" ) )   heatmap_legend_param -   list ( color_bar =  \"continuous\" , at =   c (  0 ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  1 ) , legend_height =   unit (  3 ,  \"cm\" ) , labels =   c (  \"0.0 (hypomethylated)\" ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  \"1.0 (hypermethylated)\" ) ) }  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"expression\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param ) } # Change label reference  if (   is.null (  values.label ) )  {  if (   type ==  \"methylation\" )   values.label -  \"DNA methylation level\"  if (   type ==  \"expression\" )   values.label -  \"Expression\" }  if (   !   missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (    missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , show_row_names =  show_row_names , row_names_gp =   gpar ( fontsize =  rownames.size ) , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (  !   missing (  sortCol ) )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title ) } else  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , bottom_annotation_height =   unit (  3 ,  \"cm\" ) , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } # STEP 3 row labels (right side)  if (  !   missing (  row.metadata ) )  {  if (  !   is.null (  row.metadata ) )  {  for  ( i in   1 :   ncol (  row.metadata ) )  {  if (   !   missing (  row.colors ) undefined  !   is.null (   row.colors [[    colnames (  row.metadata ) [  i ] ] ] ) )  {   color -   row.colors [[    colnames (  row.metadata ) [  i ] ] ]   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE , col =  color ) } else  {   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE ) }   heatmap -   add_heatmap (  heatmap ,  x ) } } }  if (  !   is.null (  filename ) )  {  if (    file_ext (  filename ) ==  \"png\" )   png (  filename , width =  width , height =  height )  if (    file_ext (  filename ) ==  \"pdf\" )   pdf (  filename , width =  width , height =  height )   draw (  heatmap )   dev.off ( ) } else  {   draw (  heatmap ) } } ",
    "filename": "TCGAvisualize.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_3 tcgabiolinks_release_3_4

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_3 tcgabiolinks_release_3_4",
    "desc_release_old": "2.0.13",
    "desc_release_new": "2.2.10",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 6,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 2,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 4,
    "total_count": 10
}

##########
Functions Removed
##########

TCGAdownload
TCGAprepare
TCGAquery
TCGAquery_clinic
TCGAquery_clinicFilt
TCGAquery_maf


##########
Functions Added
##########

TCGAanalyze_Pathview
TCGAanalyze_networkInference
getResults


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 )",
    "body": "{   samplesNT -   TCGAquery_SampleTypes (   colnames (  dataGE ) , typesample =   c (  \"NT\" ) )   samplesTP -   TCGAquery_SampleTypes (   colnames (  dataGE ) , typesample =   c (  \"TP\" ) )   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist )   dataCancer -   dataGE [  Genelist ,  samplesTP ]   dataNormal -   dataGE [  Genelist ,  samplesNT ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) )    cfu [   which (    cfu $ vital_status ==  \"Alive\" ) ,  \"days_to_death\" ] -  \"-Inf\"    cfu [   which (    cfu $ vital_status ==  \"Dead\" ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE   Survresult -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) )  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  { #print(i)   cat (   paste (  (   ngenes -  i ) ,  \".\" , sep =  \"\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (    is.na (  mRNAselected_values_ordered_top ) !=  1 )  {   numberOfSamples -   nrow (   as.matrix (  mRNAselected_values_ordered ) )   lastelementTOP -   round (   numberOfSamples /  3 )   firstelementDOWN -   numberOfSamples -  lastelementTOP   samples_top_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   1 :  (   lastelementTOP -  1 ) ] ) )   samples_down_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   (   firstelementDOWN +  1 ) :  numberOfSamples ] ) )   samples_UNCHANGED_mRNA_selected -   rownames (   as.matrix (   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ) )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ] #if( followUpLevel == TRUE) #{ # samplesTop_over_followUplevel #  cfu_onlyTOP # samplesDown_over_followUplevel #cfu_onlyDOWN #print(paste(\"Processing ... with followUP level #  } # else { #  print(paste(\"Processing ... without followUP level and\", nrow(as.matrix(cfu)),\"clinical samples\")) #}   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered # print(dim(cfu)) # } #end else with all samples   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] ) #ttime   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 } #print(paste(\"deaths =\",deads_complete))    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (  mRNAselected_values_normal )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (  dataCancer_onlyTop_sample_mRNASelected )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (  dataCancer_onlyDown_sample_mRNASelected )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] ) #ttime[!status]    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   length (  ttime ) #plot(survfit(ttime ~ 1)) #plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)), rep(\"unchanged\", nrow(cfu_onlyUNCHANGED)))), col = c(\"red\", \"green\",\"grey\")) #   plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)))), col = c(\"red\", \"green\"),main= mRNAselected)   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) #miRselected_surv_results_pvalue    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue #print(paste(i,\"....\",mRNAselected,\"pvalue=\",tabSurv_pvalue))  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ]   return (  tabSurvKM ) } ",
    "filename": "TCGAanalyze.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 , group1 , group2 )",
    "body": "{   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist )   dataCancer -   dataGE [  Genelist ,  group2 ]   dataNormal -   dataGE [  Genelist ,  group1 ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]  if (   \"days_to_last_followup\" %in%   colnames (  cfu ) )     colnames (  cfu ) [   grep (  \"days_to_last_followup\" ,   colnames (  cfu ) ) ] -  \"days_to_last_follow_up\"   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) )    cfu [   which (    cfu $ vital_status ==  \"Alive\" ) ,  \"days_to_death\" ] -  \"-Inf\"    cfu [   which (    cfu $ vital_status ==  \"Dead\" ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE   Survresult -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) )  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  { #print(i)   cat (   paste (  (   ngenes -  i ) ,  \".\" , sep =  \"\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (    is.na (  mRNAselected_values_ordered_top ) !=  1 )  {   numberOfSamples -   nrow (   as.matrix (  mRNAselected_values_ordered ) )   lastelementTOP -   round (   numberOfSamples /  3 )   firstelementDOWN -   numberOfSamples -  lastelementTOP   samples_top_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   1 :  (   lastelementTOP -  1 ) ] ) )   samples_down_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   (   firstelementDOWN +  1 ) :  numberOfSamples ] ) )   samples_UNCHANGED_mRNA_selected -   rownames (   as.matrix (   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ) )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ] #if( followUpLevel == TRUE) #{ # samplesTop_over_followUplevel #  cfu_onlyTOP # samplesDown_over_followUplevel #cfu_onlyDOWN #print(paste(\"Processing ... with followUP level #  } # else { #  print(paste(\"Processing ... without followUP level and\", nrow(as.matrix(cfu)),\"clinical samples\")) #}   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered # print(dim(cfu)) # } #end else with all samples   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] ) #ttime   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 } #print(paste(\"deaths =\",deads_complete))    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (  mRNAselected_values_normal )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (  dataCancer_onlyTop_sample_mRNASelected )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (  dataCancer_onlyDown_sample_mRNASelected )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] ) #ttime[!status]    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   length (  ttime ) #plot(survfit(ttime ~ 1)) #plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)), rep(\"unchanged\", nrow(cfu_onlyUNCHANGED)))), col = c(\"red\", \"green\",\"grey\")) #   plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)))), col = c(\"red\", \"green\"),main= mRNAselected)   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) #miRselected_surv_results_pvalue    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue #print(paste(i,\"....\",mRNAselected,\"pvalue=\",tabSurv_pvalue))  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ] #'  group1 #'  group2    colnames (  tabSurvKM ) -   gsub (  \"Cancer\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Tumor\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Normal\" ,  \"Group1\" ,   colnames (  tabSurvKM ) )   return (  tabSurvKM ) } ",
    "filename": "analyze.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAvisualize_PCA",
    "representation": "TCGAvisualize_PCA",
    "parameters": "function ( dataFilt , dataDEGsFiltLevel , ntopgenes )",
    "body": "{   ComparisonSelected -  \"Normal vs Tumor\"   TitlePlot -   paste0 (  \"PCA \" ,  \"top \" ,  ntopgenes ,  \" Up and down diff.expr genes between \" ,  ComparisonSelected )   dataFilt -   dataFilt [  !   duplicated (   GenesCutID (   rownames (  dataFilt ) ) ) , ]    rownames (  dataFilt ) -   GenesCutID (   rownames (  dataFilt ) )   Genelist -    rownames (  dataDEGsFiltLevel ) [   1 :  ntopgenes ]   commonGenes -   intersect (  Genelist ,   rownames (  dataFilt ) )   expr2 -   dataFilt [  commonGenes , ]   color1 -  \"blue\"   color2 -  \"red\" # selection of normal samples \"NT\"   samplesNT -   TCGAquery_SampleTypes (   colnames (  dataFilt ) , typesample =   c (  \"NT\" ) ) # selection of tumor samples \"TP\"   samplesTP -   TCGAquery_SampleTypes (   colnames (  dataFilt ) , typesample =   c (  \"TP\" ) )   nsample1 -   length (  samplesNT )   nsample2 -   length (  samplesTP ) #sampleColors #sampleColors #                     length(samplesTP)))   sampleColors -   c (   rep (  \"blue\" ,   length (  samplesNT ) ) ,   rep (  \"red\" ,   length (  samplesTP ) ) )    names (  sampleColors ) -   colnames (  expr2 )   cancer.pca -   stats :: prcomp (   t (  expr2 ) , cor =  TRUE )   g -   ggbiplot (  cancer.pca , obs.scale =  1 , var.scale =  1 , groups =  sampleColors , ellipse =  TRUE , circle =  FALSE )   g -   g +   scale_colour_manual ( name =  \"\" , values =   c ( \"blue\" =  \"blue\" , \"red\" =  \"red\" ) )   with (  g ,   g -   g +   geom_point (   aes ( colour =  sampleColors ) , size =  3 ) ) #shape = tabClusterNew$Study)   g -   g +   theme ( legend.direction =  'horizontal' , legend.position =  'top' )   g -   g +   ggtitle (  TitlePlot )   print (  g )   return (  cancer.pca ) } ",
    "filename": "TCGAvisualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_PCA",
    "representation": "TCGAvisualize_PCA",
    "parameters": "function ( dataFilt , dataDEGsFiltLevel , ntopgenes , group1 , group2 )",
    "body": "{   ComparisonSelected -  \"Normal vs Tumor\"   TitlePlot -   paste0 (  \"PCA \" ,  \"top \" ,  ntopgenes ,  \" Up and down diff.expr genes between \" ,  ComparisonSelected )   dataFilt -   dataFilt [  !   duplicated (   GenesCutID (   rownames (  dataFilt ) ) ) , ]    rownames (  dataFilt ) -   GenesCutID (   rownames (  dataFilt ) )   Genelist -    rownames (  dataDEGsFiltLevel ) [   1 :  ntopgenes ]   commonGenes -   intersect (  Genelist ,   rownames (  dataFilt ) )   expr2 -   dataFilt [  commonGenes , ]   color1 -  \"blue\"   color2 -  \"red\"   nsample1 -   length (  group1 )   nsample2 -   length (  group2 ) #sampleColors #sampleColors #                     length(group2)))   sampleColors -   c (   rep (  \"blue\" ,   length (  group1 ) ) ,   rep (  \"red\" ,   length (  group2 ) ) )    names (  sampleColors ) -   colnames (  expr2 )   cancer.pca -   stats :: prcomp (   t (  expr2 ) , cor =  TRUE )   g -   ggbiplot (  cancer.pca , obs.scale =  1 , var.scale =  1 , groups =  sampleColors , ellipse =  TRUE , circle =  FALSE )   g -   g +   scale_colour_manual ( name =  \"\" , values =   c ( \"blue\" =  \"blue\" , \"red\" =  \"red\" ) )   with (  g ,   g -   g +   geom_point (   aes ( colour =  sampleColors ) , size =  3 ) ) #shape = tabClusterNew$Study)   g -   g +   theme ( legend.direction =  'horizontal' , legend.position =  'top' )   g -   g +   ggtitle (  TitlePlot )   print (  g )   return (  cancer.pca ) } ",
    "filename": "visualize.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_DMR",
    "representation": "TCGAanalyze_DMR",
    "parameters": "function ( data , groupCol = NULL , group1 = NULL , group2 = NULL , plot.filename = \"methylation_volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = expression ( paste ( \"DNA Methylation difference (\" , beta , \"-values)\" ) ) , title = NULL , legend = \"Legend\" , color = c ( \"black\" , \"red\" , \"darkgreen\" ) , label = NULL , xlim = NULL , ylim = NULL , p.cut = 0.01 , probe.names = FALSE , diffmean.cut = 0.2 , paired = FALSE , adj.method = \"BH\" , overwrite = FALSE , cores = 1 , save = TRUE , save.directory = \".\" , filename = NULL )",
    "body": "{   .e -   environment ( )    names (  color ) -   as.character (   1 :  3 ) # Check if object is a summarized Experiment  if (    class (  data ) !=   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   stop (   paste0 (  \"Sorry, but I'm expecting a Summarized Experiment object, but I got a: \" ,   class (  data ) ) ) } # Check if object has NAs  if (   any (   is.na (   assay (  data ) ) ) )  {   stop (   paste0 (  \"Sorry, but we found some NA in your data, please either remove/or replace them\" ) ) }  if (   is.null (  groupCol ) )  {   message (  \"Please, set the groupCol parameter\" )   return (  NULL ) }  if (  !  (   groupCol %in%   colnames (   colData (  data ) ) ) )  {   stop (   paste0 (  \"column \" ,  groupCol ,  \" not found in the object\" ) ) }  if (      length (   unique (    colData (  data ) [ ,  groupCol ] ) ) !=  2 undefined   is.null (  group1 ) undefined   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) } else  if (     length (   unique (    colData (  data ) [ ,  groupCol ] ) ) ==  2 undefined  (    is.null (  group1 ) ||   is.null (  group2 ) ) )  {   group1 -    unique (    colData (  data ) [ ,  groupCol ] ) [  1 ]   group2 -    unique (    colData (  data ) [ ,  groupCol ] ) [  2 ] } else  {   message (   paste0 (  \"Group1:\" ,  group1 ) )   message (   paste0 (  \"Group2:\" ,  group2 ) ) } # Check if groups has at least one sample  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group1 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group1 ,  \" has no samples\" ) ) }  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group2 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group2 ,  \" has no samples\" ) ) } # defining title and label if not specified by the user  if (   is.null (  title ) )  {   title -   paste (  \"Volcano plot\" ,  \"(\" ,  group2 ,  \"vs\" ,  group1 ,  \")\" ) }  if (   is.null (  label ) )  {   label -   c (  \"Not Significant\" ,  \"Hypermethylated\" ,  \"Hypomethylated\" )    label [   2 :  3 ] -   paste (   label [   2 :  3 ] ,  \"in\" ,  group2 ) }   diffcol -   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" )  if (   !  (   diffcol %in%   colnames (   values (  data ) ) ) ||  overwrite )  {   data -   diffmean (  data ,  groupCol , group1 =  group1 , group2 =  group2 , save =  save )  if (  !  (   diffcol %in%   colnames (   values (   rowRanges (  data ) ) ) ) )  {   stop (   paste0 (  \"Error! Not found \" ,  diffcol ) ) } }   pcol -   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" )  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )  {   pcol -   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) }  if (   !  (   pcol %in%   colnames (   values (  data ) ) ) |  overwrite )  {   data -   calculate.pvalues (  data ,  groupCol ,  group1 ,  group2 , paired =  paired , method =  adj.method , cores =  cores , save =  save ) # An error should not happen, if it happens (probably due to an incorret # user input) we will stop  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )   stop (   paste0 (  \"Error! Not found \" ,  pcol ) ) }   log -   paste0 (  \"TCGAanalyze_DMR.\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,  \".\" ,   gsub (  \" \" ,  \".\" ,  group2 ) )   assign (  log ,   c ( \"groupCol\" =  groupCol , \"group1\" =   gsub (  \" \" ,  \".\" ,  group1 ) , \"group2\" =   gsub (  \" \" ,  \".\" ,  group2 ) , \"plot.filename\" =  plot.filename , \"xlim\" =  xlim , \"ylim\" =  ylim , \"p.cut\" =  p.cut , \"diffmean.cut\" =  diffmean.cut , \"paired\" =  \"paired\" , \"adj.method\" =  adj.method ) )     metadata (  data ) [[  log ] ] -  (   eval (   as.symbol (  log ) ) )   statuscol -   paste (  \"status\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" )   statuscol2 -   paste (  \"status\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" )     values (  data ) [ ,  statuscol ] -  \"Not Significant\"     values (  data ) [ ,  statuscol2 ] -  \"Not Significant\" # get significant data   sig -     values (  data ) [ ,  pcol ] undefined  p.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated samples compared to old state   hyper -     values (  data ) [ ,  diffcol ] undefined  diffmean.cut    hyper [   is.na (  hyper ) ] -  FALSE  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol ] -  \"Hypermethylated\"  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol2 ] -  \"Hypomethylated\" # hypomethylated samples compared to old state   hypo -     values (  data ) [ ,  diffcol ] undefined  (  -  diffmean.cut )    hypo [   is.na (  hypo ) ] -  FALSE  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol ] -  \"Hypomethylated\"  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol2 ] -  \"Hypermethylated\" # Plot a volcano plot   names -  NULL  if (  probe.names )   names -    values (  data ) $ probeID  if (   plot.filename !=  FALSE )  {   TCGAVisualize_volcano ( x =    values (  data ) [ ,  diffcol ] , y =    values (  data ) [ ,  pcol ] , filename =  plot.filename , ylab =  ylab , xlab =  xlab , title =  title , legend =  legend , label =  label , names =  names , x.cut =  diffmean.cut , y.cut =  p.cut ) }  if (  save )  { # saving results into a csv file   csv -   paste0 (   paste (  \"DMR_results\" ,   gsub (  \"_\" ,  \".\" ,  groupCol ) ,   gsub (  \" |_\" ,  \".\" ,  group1 ) ,   gsub (  \" |_\" ,  \".\" ,  group2 ) ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".csv\" )   csv -   file.path (  save.directory ,  csv )   message (   paste0 (  \"Saving the results also in a csv file:\" ) ,  csv )   df -   values (  data )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group2 )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol2 ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group1 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group2 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol2 ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group1 ) # get metadata not created by this function   idx -   grep (  \"mean|status|value\" ,   colnames (  df ) , invert =  TRUE )   write.csv2 (   df [ ,   c (    colnames (  df ) [  idx ] ,   paste (  \"mean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"mean\" ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"p.value\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,   gsub (  \" \" ,  \".\" ,  group2 ) , sep =  \".\" ) ,  statuscol ,   paste (  \"diffmean\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"p.value\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,   gsub (  \" \" ,  \".\" ,  group2 ) ,   gsub (  \" \" ,  \".\" ,  group1 ) , sep =  \".\" ) ,  statuscol2 ) ] , file =  csv )  if (   is.null (  filename ) )  {   filename -   paste0 (   paste (   gsub (  \"_\" ,  \".\" ,  groupCol ) ,   gsub (  \" |_\" ,  \".\" ,  group1 ) ,   gsub (  \" |_\" ,  \".\" ,  group2 ) ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".rda\" )   filename -   file.path (  save.directory ,  filename ) } # saving results into R object   save (  data , file =  filename ) }   return (  data ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_DMR",
    "representation": "TCGAanalyze_DMR",
    "parameters": "function ( data , groupCol = NULL , group1 = NULL , group2 = NULL , calculate.pvalues.probes = \"all\" , plot.filename = \"methylation_volcano.pdf\" , ylab = expression ( paste ( - Log [ 10 ] , \" (FDR corrected -P values)\" ) ) , xlab = expression ( paste ( \"DNA Methylation difference (\" , beta , \"-values)\" ) ) , title = NULL , legend = \"Legend\" , color = c ( \"black\" , \"red\" , \"darkgreen\" ) , label = NULL , xlim = NULL , ylim = NULL , p.cut = 0.01 , probe.names = FALSE , diffmean.cut = 0.2 , paired = FALSE , adj.method = \"BH\" , overwrite = FALSE , cores = 1 , save = TRUE , save.directory = \".\" , filename = NULL )",
    "body": "{   .e -   environment ( )    names (  color ) -   as.character (   1 :  3 ) # Check if object is a summarized Experiment  if (    class (  data ) !=   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   stop (   paste0 (  \"Sorry, but I'm expecting a Summarized Experiment object, but I got a: \" ,   class (  data ) ) ) } # Check if object has NAs for all samples  if (   any (    rowSums (  !   is.na (   assay (  data ) ) ) ==  0 ) )  {   stop (   paste0 (  \"Sorry, but we found some probes with NA for all samples in your data, please either remove/or replace them\" ) ) }  if (   is.null (  groupCol ) )  {   message (  \"Please, set the groupCol parameter\" )   return (  NULL ) }  if (  !  (   groupCol %in%   colnames (   colData (  data ) ) ) )  {   stop (   paste0 (  \"column \" ,  groupCol ,  \" not found in the object\" ) ) }  if (      length (   unique (    colData (  data ) [ ,  groupCol ] ) ) !=  2 undefined   is.null (  group1 ) undefined   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) } else  if (     length (   unique (    colData (  data ) [ ,  groupCol ] ) ) ==  2 undefined  (    is.null (  group1 ) ||   is.null (  group2 ) ) )  {   group1 -    unique (    colData (  data ) [ ,  groupCol ] ) [  1 ]   group2 -    unique (    colData (  data ) [ ,  groupCol ] ) [  2 ] } else  {   message (   paste0 (  \"Group1:\" ,  group1 ) )   message (   paste0 (  \"Group2:\" ,  group2 ) ) } # Check if groups has at least one sample  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group1 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group1 ,  \" has no samples\" ) ) }  if (  !   any (     colData (  data ) [ ,  groupCol ] ==  group2 , na.rm =  TRUE ) )  {   stop (   paste0 (  \"Sorry, but \" ,  group2 ,  \" has no samples\" ) ) } # defining title and label if not specified by the user  if (   is.null (  title ) )  {   title -   paste (  \"Volcano plot\" ,  \"(\" ,  group2 ,  \"vs\" ,  group1 ,  \")\" ) }  if (   is.null (  label ) )  {   label -   c (  \"Not Significant\" ,  \"Hypermethylated\" ,  \"Hypomethylated\" )    label [   2 :  3 ] -   paste (   label [   2 :  3 ] ,  \"in\" ,  group2 ) }   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )   diffcol -   paste (  \"diffmean\" ,  group1.col ,  group2.col , sep =  \".\" )  if (   !  (   diffcol %in%   colnames (   values (  data ) ) ) ||  overwrite )  {   data -   diffmean (  data ,  groupCol , group1 =  group1 , group2 =  group2 , save =  save )  if (  !  (   diffcol %in%   colnames (   values (   rowRanges (  data ) ) ) ) )  {   stop (   paste0 (  \"Error! Not found \" ,  diffcol ) ) } }   pcol -   paste (  \"p.value.adj\" ,  group2.col ,  group1.col , sep =  \".\" )  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )  {   pcol -   paste (  \"p.value.adj\" ,  group1.col ,  group2.col , sep =  \".\" ) }  if (   !  (   pcol %in%   colnames (   values (  data ) ) ) |  overwrite )  {  if (   calculate.pvalues.probes ==  \"all\" )  {   suppressWarnings (  {   data -   calculate.pvalues (  data ,  groupCol ,  group1 ,  group2 , paired =  paired , method =  adj.method , cores =  cores , save =  save ) } ) } else  if (   calculate.pvalues.probes ==  \"differential\" )  {   message (   paste0 (  \"Caculating p-values only for probes with a difference of mean methylation equal or higher than \" ,  diffmean.cut ) )   print (  diffcol )   print (   colnames (   values (  data ) ) )   diff.probes -    abs (    values (  data ) [ ,  diffcol ] ) undefined  diffmean.cut   nb -   length (   which (   diff.probes ==  TRUE ) )  if (   nb ==  0 )  {   warning (  \"No probes differenly methylated\" )   return (  NULL ) }   print (   paste0 (  \"Number of probes differenly methylated: \" ,  nb ) )   data -   calculate.pvalues (   data [  diff.probes , ] ,  groupCol ,  group1 ,  group2 , paired =  paired , method =  adj.method , cores =  cores , save =  save ) } # An error should not happen, if it happens (probably due to an incorret # user input) we will stop  if (  !  (   pcol %in%   colnames (   values (  data ) ) ) )   stop (   paste0 (  \"Error! Not found \" ,  pcol ) ) }   log -   paste0 (  \"TCGAanalyze_DMR.\" ,   gsub (  \" \" ,  \".\" ,  group1 ) ,  \".\" ,   gsub (  \" \" ,  \".\" ,  group2 ) )   assign (  log ,   c ( \"groupCol\" =  groupCol , \"group1\" =  group1.col , \"group2\" =  group2.col , \"plot.filename\" =  plot.filename , \"xlim\" =  xlim , \"ylim\" =  ylim , \"p.cut\" =  p.cut , \"diffmean.cut\" =  diffmean.cut , \"paired\" =  \"paired\" , \"adj.method\" =  adj.method ) )     metadata (  data ) [[  log ] ] -  (   eval (   as.symbol (  log ) ) )   statuscol -   paste (  \"status\" ,  group1.col ,  group2.col , sep =  \".\" )   statuscol2 -   paste (  \"status\" ,  group2.col ,  group1.col , sep =  \".\" )     values (  data ) [ ,  statuscol ] -  \"Not Significant\"     values (  data ) [ ,  statuscol2 ] -  \"Not Significant\" # get significant data   sig -     values (  data ) [ ,  pcol ] undefined  p.cut    sig [   is.na (  sig ) ] -  FALSE # hypermethylated samples compared to old state   hyper -     values (  data ) [ ,  diffcol ] undefined  diffmean.cut    hyper [   is.na (  hyper ) ] -  FALSE  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol ] -  \"Hypermethylated\"  if (   any (   hyper undefined  sig ) )     values (  data ) [   hyper undefined  sig ,  statuscol2 ] -  \"Hypomethylated\" # hypomethylated samples compared to old state   hypo -     values (  data ) [ ,  diffcol ] undefined  (  -  diffmean.cut )    hypo [   is.na (  hypo ) ] -  FALSE  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol ] -  \"Hypomethylated\"  if (   any (   hypo undefined  sig ) )     values (  data ) [   hypo undefined  sig ,  statuscol2 ] -  \"Hypermethylated\" # Plot a volcano plot   names -  NULL  if (  probe.names )   names -    values (  data ) $ probeID  if (   plot.filename !=  FALSE )  {   TCGAVisualize_volcano ( x =    values (  data ) [ ,  diffcol ] , y =    values (  data ) [ ,  pcol ] , filename =  plot.filename , ylab =  ylab , xlab =  xlab , title =  title , legend =  legend , label =  label , names =  names , x.cut =  diffmean.cut , y.cut =  p.cut ) }  if (  save )  { # saving results into a csv file   csv -   paste0 (   paste (  \"DMR_results\" ,   gsub (  \"_\" ,  \".\" ,  groupCol ) ,  group1.col ,  group2.col ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".csv\" )   dir.create (  save.directory , showWarnings =  FALSE , recursive =  TRUE )   csv -   file.path (  save.directory ,  csv )   message (   paste0 (  \"Saving the results also in a csv file: \" ) ,  csv )   df -   values (  data )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group2 )  if (   any (   hyper undefined  sig ) )    df [   hyper undefined  sig ,  statuscol2 ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group1 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol ] -   paste (  \"Hypomethylated\" ,  \"in\" ,  group2 )  if (   any (   hypo undefined  sig ) )    df [   hypo undefined  sig ,  statuscol2 ] -   paste (  \"Hypermethylated\" ,  \"in\" ,  group1 ) # get metadata not created by this function   idx -   grep (  \"mean|status|value\" ,   colnames (  df ) , invert =  TRUE )   write_csv (   as.data.frame (   df [ ,   c (    colnames (  df ) [  idx ] ,   paste (  \"mean\" ,  group1.col , sep =  \".\" ) ,   paste (  \"mean\" ,  group2.col , sep =  \".\" ) ,   paste (  \"diffmean\" ,  group1.col ,  group2.col , sep =  \".\" ) ,   paste (  \"p.value\" ,  group1.col ,  group2.col , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,  group1.col ,  group2.col , sep =  \".\" ) ,  statuscol ,   paste (  \"diffmean\" ,  group2.col ,  group1.col , sep =  \".\" ) ,   paste (  \"p.value\" ,  group2.col ,  group1.col , sep =  \".\" ) ,   paste (  \"p.value.adj\" ,  group2.col ,  group1.col , sep =  \".\" ) ,  statuscol2 ) ] ) , path =  csv )  if (   is.null (  filename ) )  {   filename -   paste0 (   paste (   gsub (  \"_\" ,  \".\" ,  groupCol ) ,  group1.col ,  group2.col ,  \"pcut\" ,  p.cut ,  \"meancut\" ,  diffmean.cut , sep =  \"_\" ) ,  \".rda\" )   filename -   file.path (  save.directory ,  filename ) } # saving results into R object   save (  data , file =  filename ) }   return (  data ) } ",
    "filename": "methylation.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 )",
    "body": "{   samplesNT -   TCGAquery_SampleTypes (   colnames (  dataGE ) , typesample =   c (  \"NT\" ) )   samplesTP -   TCGAquery_SampleTypes (   colnames (  dataGE ) , typesample =   c (  \"TP\" ) )   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist )   dataCancer -   dataGE [  Genelist ,  samplesTP ]   dataNormal -   dataGE [  Genelist ,  samplesNT ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) )    cfu [   which (    cfu $ vital_status ==  \"Alive\" ) ,  \"days_to_death\" ] -  \"-Inf\"    cfu [   which (    cfu $ vital_status ==  \"Dead\" ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE   Survresult -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) )  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  { #print(i)   cat (   paste (  (   ngenes -  i ) ,  \".\" , sep =  \"\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (    is.na (  mRNAselected_values_ordered_top ) !=  1 )  {   numberOfSamples -   nrow (   as.matrix (  mRNAselected_values_ordered ) )   lastelementTOP -   round (   numberOfSamples /  3 )   firstelementDOWN -   numberOfSamples -  lastelementTOP   samples_top_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   1 :  (   lastelementTOP -  1 ) ] ) )   samples_down_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   (   firstelementDOWN +  1 ) :  numberOfSamples ] ) )   samples_UNCHANGED_mRNA_selected -   rownames (   as.matrix (   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ) )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ] #if( followUpLevel == TRUE) #{ # samplesTop_over_followUplevel #  cfu_onlyTOP # samplesDown_over_followUplevel #cfu_onlyDOWN #print(paste(\"Processing ... with followUP level #  } # else { #  print(paste(\"Processing ... without followUP level and\", nrow(as.matrix(cfu)),\"clinical samples\")) #}   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered # print(dim(cfu)) # } #end else with all samples   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] ) #ttime   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 } #print(paste(\"deaths =\",deads_complete))    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (  mRNAselected_values_normal )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (  dataCancer_onlyTop_sample_mRNASelected )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (  dataCancer_onlyDown_sample_mRNASelected )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] ) #ttime[!status]    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   length (  ttime ) #plot(survfit(ttime ~ 1)) #plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)), rep(\"unchanged\", nrow(cfu_onlyUNCHANGED)))), col = c(\"red\", \"green\",\"grey\")) #   plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)))), col = c(\"red\", \"green\"),main= mRNAselected)   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) #miRselected_surv_results_pvalue    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue #print(paste(i,\"....\",mRNAselected,\"pvalue=\",tabSurv_pvalue))  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ]   return (  tabSurvKM ) } ",
    "filename": "TCGAanalyze.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 , group1 , group2 )",
    "body": "{   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist )   dataCancer -   dataGE [  Genelist ,  group2 ]   dataNormal -   dataGE [  Genelist ,  group1 ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]  if (   \"days_to_last_followup\" %in%   colnames (  cfu ) )     colnames (  cfu ) [   grep (  \"days_to_last_followup\" ,   colnames (  cfu ) ) ] -  \"days_to_last_follow_up\"   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) )    cfu [   which (    cfu $ vital_status ==  \"Alive\" ) ,  \"days_to_death\" ] -  \"-Inf\"    cfu [   which (    cfu $ vital_status ==  \"Dead\" ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE   Survresult -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) )  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  { #print(i)   cat (   paste (  (   ngenes -  i ) ,  \".\" , sep =  \"\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (  mRNAselected_values_ordered ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (    is.na (  mRNAselected_values_ordered_top ) !=  1 )  {   numberOfSamples -   nrow (   as.matrix (  mRNAselected_values_ordered ) )   lastelementTOP -   round (   numberOfSamples /  3 )   firstelementDOWN -   numberOfSamples -  lastelementTOP   samples_top_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   1 :  (   lastelementTOP -  1 ) ] ) )   samples_down_mRNA_selected -   rownames (   as.matrix (   mRNAselected_values_ordered [   (   firstelementDOWN +  1 ) :  numberOfSamples ] ) )   samples_UNCHANGED_mRNA_selected -   rownames (   as.matrix (   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ) )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ] #if( followUpLevel == TRUE) #{ # samplesTop_over_followUplevel #  cfu_onlyTOP # samplesDown_over_followUplevel #cfu_onlyDOWN #print(paste(\"Processing ... with followUP level #  } # else { #  print(paste(\"Processing ... without followUP level and\", nrow(as.matrix(cfu)),\"clinical samples\")) #}   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered # print(dim(cfu)) # } #end else with all samples   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] ) #ttime   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 } #print(paste(\"deaths =\",deads_complete))    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (  mRNAselected_values_normal )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (  dataCancer_onlyTop_sample_mRNASelected )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (  dataCancer_onlyDown_sample_mRNASelected )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] ) #ttime[!status]    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   length (  ttime ) #plot(survfit(ttime ~ 1)) #plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)), rep(\"unchanged\", nrow(cfu_onlyUNCHANGED)))), col = c(\"red\", \"green\",\"grey\")) #   plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)))), col = c(\"red\", \"green\"),main= mRNAselected)   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) #miRselected_surv_results_pvalue    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue #print(paste(i,\"....\",mRNAselected,\"pvalue=\",tabSurv_pvalue))  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ] #'  group1 #'  group2    colnames (  tabSurvKM ) -   gsub (  \"Cancer\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Tumor\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Normal\" ,  \"Group1\" ,   colnames (  tabSurvKM ) )   return (  tabSurvKM ) } ",
    "filename": "analyze.txt"
  }
}

2.
{
  "old_function": {
    "name": "TCGAvisualize_PCA",
    "representation": "TCGAvisualize_PCA",
    "parameters": "function ( dataFilt , dataDEGsFiltLevel , ntopgenes )",
    "body": "{   ComparisonSelected -  \"Normal vs Tumor\"   TitlePlot -   paste0 (  \"PCA \" ,  \"top \" ,  ntopgenes ,  \" Up and down diff.expr genes between \" ,  ComparisonSelected )   dataFilt -   dataFilt [  !   duplicated (   GenesCutID (   rownames (  dataFilt ) ) ) , ]    rownames (  dataFilt ) -   GenesCutID (   rownames (  dataFilt ) )   Genelist -    rownames (  dataDEGsFiltLevel ) [   1 :  ntopgenes ]   commonGenes -   intersect (  Genelist ,   rownames (  dataFilt ) )   expr2 -   dataFilt [  commonGenes , ]   color1 -  \"blue\"   color2 -  \"red\" # selection of normal samples \"NT\"   samplesNT -   TCGAquery_SampleTypes (   colnames (  dataFilt ) , typesample =   c (  \"NT\" ) ) # selection of tumor samples \"TP\"   samplesTP -   TCGAquery_SampleTypes (   colnames (  dataFilt ) , typesample =   c (  \"TP\" ) )   nsample1 -   length (  samplesNT )   nsample2 -   length (  samplesTP ) #sampleColors #sampleColors #                     length(samplesTP)))   sampleColors -   c (   rep (  \"blue\" ,   length (  samplesNT ) ) ,   rep (  \"red\" ,   length (  samplesTP ) ) )    names (  sampleColors ) -   colnames (  expr2 )   cancer.pca -   stats :: prcomp (   t (  expr2 ) , cor =  TRUE )   g -   ggbiplot (  cancer.pca , obs.scale =  1 , var.scale =  1 , groups =  sampleColors , ellipse =  TRUE , circle =  FALSE )   g -   g +   scale_colour_manual ( name =  \"\" , values =   c ( \"blue\" =  \"blue\" , \"red\" =  \"red\" ) )   with (  g ,   g -   g +   geom_point (   aes ( colour =  sampleColors ) , size =  3 ) ) #shape = tabClusterNew$Study)   g -   g +   theme ( legend.direction =  'horizontal' , legend.position =  'top' )   g -   g +   ggtitle (  TitlePlot )   print (  g )   return (  cancer.pca ) } ",
    "filename": "TCGAvisualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_PCA",
    "representation": "TCGAvisualize_PCA",
    "parameters": "function ( dataFilt , dataDEGsFiltLevel , ntopgenes , group1 , group2 )",
    "body": "{   ComparisonSelected -  \"Normal vs Tumor\"   TitlePlot -   paste0 (  \"PCA \" ,  \"top \" ,  ntopgenes ,  \" Up and down diff.expr genes between \" ,  ComparisonSelected )   dataFilt -   dataFilt [  !   duplicated (   GenesCutID (   rownames (  dataFilt ) ) ) , ]    rownames (  dataFilt ) -   GenesCutID (   rownames (  dataFilt ) )   Genelist -    rownames (  dataDEGsFiltLevel ) [   1 :  ntopgenes ]   commonGenes -   intersect (  Genelist ,   rownames (  dataFilt ) )   expr2 -   dataFilt [  commonGenes , ]   color1 -  \"blue\"   color2 -  \"red\"   nsample1 -   length (  group1 )   nsample2 -   length (  group2 ) #sampleColors #sampleColors #                     length(group2)))   sampleColors -   c (   rep (  \"blue\" ,   length (  group1 ) ) ,   rep (  \"red\" ,   length (  group2 ) ) )    names (  sampleColors ) -   colnames (  expr2 )   cancer.pca -   stats :: prcomp (   t (  expr2 ) , cor =  TRUE )   g -   ggbiplot (  cancer.pca , obs.scale =  1 , var.scale =  1 , groups =  sampleColors , ellipse =  TRUE , circle =  FALSE )   g -   g +   scale_colour_manual ( name =  \"\" , values =   c ( \"blue\" =  \"blue\" , \"red\" =  \"red\" ) )   with (  g ,   g -   g +   geom_point (   aes ( colour =  sampleColors ) , size =  3 ) ) #shape = tabClusterNew$Study)   g -   g +   theme ( legend.direction =  'horizontal' , legend.position =  'top' )   g -   g +   ggtitle (  TitlePlot )   print (  g )   return (  cancer.pca ) } ",
    "filename": "visualize.txt"
  }
}

3.
{
  "old_function": {
    "name": "TCGAvisualize_oncoprint",
    "representation": "TCGAvisualize_oncoprint",
    "parameters": "function ( mut , genes , filename , color , annotation.position = \"bottom\" , annotation , height , width = 10 , rm.empty.columns = FALSE , show.column.names = FALSE , show.row.barplot = TRUE , label.title = \"Mutation\" , label.font.size = 16 , rows.font.size = 16 , dist.col = 0.5 , dist.row = 0.5 , row.order = FALSE , heatmap.legend.side = \"bottom\" , annotation.legend.side = \"bottom\" )",
    "body": "{  if (   missing (  mut ) )   stop (  \"Missing mut argument\" )   mut -   setDT (  mut )    mut $ value -  1    mut $ Hugo_Symbol -   as.character (   mut $ Hugo_Symbol )  if (   !   missing (  genes ) undefined  !   is.null (  genes ) )   mut -   subset (  mut ,    mut $ Hugo_Symbol %in%  genes )  if (  !  rm.empty.columns )  {   mat -   dcast (  mut ,    Tumor_Sample_Barcode +  Hugo_Symbol ~  Variant_Type , value.var =  \"value\" , fill =  0 , drop =  FALSE ) } else  {   mat -   dcast (  mut ,    Tumor_Sample_Barcode +  Hugo_Symbol ~  Variant_Type , value.var =  \"value\" , fill =  0 , drop =  TRUE ) } # mutation in the file   columns -    colnames (  mat ) [  -   c (   1 :  2 ) ] # value will be a collum with all the mutations    mat $ value -  \"\"  for  ( i in  columns )  {    mat [ ,  i ] -   replace (   mat [ ,  i , with =  FALSE ] ,    mat [ ,  i , with =  FALSE ] undefined  0 ,   paste0 (  i ,  \";\" ) )    mat [ ,  i ] -   replace (   mat [ ,  i , with =  FALSE ] ,    mat [ ,  i , with =  FALSE ] ==  0 ,  \"\" )   mat [ ,   value :=   paste0 (  value ,   get (  i ) ) ] } # After the gene selection, some of the mutation might not exist # we will remove them to make the oncoprint work   mutation.type -   c ( )  for  ( i in  columns )  {  if (    length (   grep (  i ,   mat $ value ) ) undefined  0 )   mutation.type -   c (  mutation.type ,  i ) } # now we have a matrix with pairs samples/genes mutations # we want a matrix with samples vs genes mutations with the content being the value   mat -   setDF (   dcast (  mat ,   Tumor_Sample_Barcode ~  Hugo_Symbol , value.var =  \"value\" , fill =  \"\" ) )    rownames (  mat ) -   mat [ ,  1 ]   mat -   mat [ ,  -  1 ] #rownames(mat)   alter_fun =   list ( background =  function ( x , y , w , h )  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h -   unit (  dist.row ,  \"mm\" ) , gp =   gpar ( fill =   color [  \"background\" ] , col =  NA ) ) } , INS =  function ( x , y , w , h )  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h -   unit (  dist.row ,  \"mm\" ) , gp =   gpar ( fill =   color [  \"INS\" ] , col =  NA ) ) } , DEL =  function ( x , y , w , h )  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h -   unit (  dist.row ,  \"mm\" ) , gp =   gpar ( fill =   color [  \"DEL\" ] , col =  NA ) ) } , SNP =  function ( x , y , w , h )  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h *  0.33 , gp =   gpar ( fill =   color [  \"SNP\" ] , col =  NA ) ) } , DNP =  function ( x , y , w , h )  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h *  0.45 , gp =   gpar ( fill =   color [  \"DNP\" ] , col =  NA ) ) } ) # get only the colors to the mutations # otherwise it gives errors  if (   missing (  color ) )  {   color -   c (   rainbow (   length (  mutation.type ) ) ,  \"#CCCCCC\" )    names (  color ) -   c (  mutation.type ,  \"background\" ) } else  {  if (   \"background\" %in%   names (  color ) )  {   color -   color [   c (  mutation.type ,  \"background\" ) ] } else  {   color -   c (   color [  mutation.type ] , \"background\" =  \"#CCCCCC\" ) } }   alt =   intersect (   names (  alter_fun ) ,   c (  \"background\" ,   as.character (  mutation.type ) ) )   alter_fun -   alter_fun [  alt ] # header are samples, rows genes   mat -   t (  mat )  if (  !   missing (  height ) )   height -    length (  genes ) /  2  if (  !   missing (  filename ) )   pdf (  filename , width =  width , height =  height )  if (   missing (  annotation ) )   annotation -  NULL  if (  !   is.null (  annotation ) )  {   idx -   match (   substr (   colnames (  mat ) ,  1 ,  12 ) ,   annotation $ bcr_patient_barcode )   annotation -   annotation [  idx , ]    annotation $ bcr_patient_barcode -  NULL   n.col -   sum (   sapply (   colnames (  annotation ) ,  function ( x )  {   length (   unique (   annotation [ ,  x ] ) ) } ) ) # add automatic colors: not working   get.color -  function ( df , col )  {   idx -   which (    colnames (  df ) ==  col )   start -  1  if (   idx !=  1 )   start -    length (   unique (   unlist (   c (   df [ ,   1 :  (   idx -  1 ) ] ) ) ) ) +  1   end -    start +   length (   unique (   df [ ,  col ] ) ) -  1   diff.colors -   c (  \"dimgray\" ,  \"thistle\" ,  \"deeppink3\" ,  \"magenta4\" ,  \"lightsteelblue1\" ,  \"black\" ,  \"chartreuse\" ,  \"lightgreen\" ,  \"maroon4\" ,  \"darkslategray\" ,  \"lightyellow3\" ,  \"darkslateblue\" ,  \"firebrick1\" ,  \"aquamarine\" ,  \"dodgerblue4\" ,  \"bisque4\" ,  \"moccasin\" ,  \"indianred1\" ,  \"yellow\" ,  \"gray93\" ,  \"cyan\" ,  \"darkseagreen4\" ,  \"lightgoldenrodyellow\" ,  \"lightpink\" ,  \"sienna1\" ,  \"darkred\" ,  \"palevioletred\" ,  \"tomato4\" ,  \"blue\" ,  \"mediumorchid4\" ,  \"royalblue1\" ,  \"magenta2\" ,  \"darkgoldenrod1\" )   return (   diff.colors [   start :  end ] ) }   col.annot -   lapply (   colnames (  annotation ) ,  function ( x )  { #idx #print(idx/n.col)   ret -   get.color (  annotation ,  x ) #ret    names (  ret ) -   as.character (   unique (   annotation [ ,  x ] ) )   return (  ret ) } )    names (  col.annot ) -   colnames (  annotation )   annotHeatmap -   HeatmapAnnotation ( df =  annotation , col =  col.annot , annotation_legend_param =   list ( title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , #sizelabels grid_height =   unit (  8 ,  \"mm\" ) ) ) }  if (   heatmap.legend.side ==  \"bottom\" )  {   nrow -  1   title_position -  \"leftcenter\" } else  {   nrow -  10   title_position -  \"topcenter\" }  if (    is.null (  annotation ) undefined  !  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (    !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  !  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (    !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  !  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (    is.null (  annotation ) undefined  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (    !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (    !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  row.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) }   draw (  p , heatmap_legend_side =  heatmap.legend.side , annotation_legend_side =  annotation.legend.side )  if (  !   missing (  filename ) )   dev.off ( ) } ",
    "filename": "TCGAvisualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_oncoprint",
    "representation": "TCGAvisualize_oncoprint",
    "parameters": "function ( mut , genes , filename , color , annotation.position = \"bottom\" , annotation , height , width = 10 , rm.empty.columns = FALSE , show.column.names = FALSE , show.row.barplot = TRUE , label.title = \"Mutation\" , column.names.size = 8 , label.font.size = 16 , rows.font.size = 16 , dist.col = 0.5 , dist.row = 0.5 , information = \"Variant_Type\" , row.order = TRUE , col.order = TRUE , heatmap.legend.side = \"bottom\" , annotation.legend.side = \"bottom\" )",
    "body": "{  if (   missing (  mut ) )   stop (  \"Missing mut argument\" )   mut -   setDT (  mut )    mut $ value -  1  if (   rm.empty.columns ==  FALSE )   all.samples -   unique (   mut $ Tumor_Sample_Barcode )    mut $ Hugo_Symbol -   as.character (   mut $ Hugo_Symbol )  if (   !   missing (  genes ) undefined  !   is.null (  genes ) )   mut -   subset (  mut ,    mut $ Hugo_Symbol %in%  genes )  if (  !  rm.empty.columns )  {   formula -   paste0 (  \"Tumor_Sample_Barcode + Hugo_Symbol ~ \" ,  information )   suppressMessages (  {   mat -   dcast (  mut ,   as.formula (  formula ) , value.var =  \"value\" , fill =  0 , drop =  FALSE ) } ) } else  {   formula -   paste0 (  \"Tumor_Sample_Barcode + Hugo_Symbol ~ \" ,  information )   suppressMessages (  {   mat -   dcast (  mut ,   as.formula (  formula ) , value.var =  \"value\" , fill =  0 , drop =  TRUE ) } ) } # mutation in the file   columns -    colnames (  mat ) [  -   c (   1 :  2 ) ] # value will be a collum with all the mutations    mat $ value -  \"\"  for  ( i in  columns )  {    mat [ ,  i ] -   replace (   mat [ ,  i , with =  FALSE ] ,    mat [ ,  i , with =  FALSE ] undefined  0 ,   paste0 (  i ,  \";\" ) )    mat [ ,  i ] -   replace (   mat [ ,  i , with =  FALSE ] ,    mat [ ,  i , with =  FALSE ] ==  0 ,  \"\" )   mat [ ,   value :=   paste0 (  value ,   get (  i ) ) ] } # After the gene selection, some of the mutation might not exist # we will remove them to make the oncoprint work   mutation.type -   c ( )  for  ( i in  columns )  {  if (    length (   grep (  i ,   mat $ value ) ) undefined  0 )   mutation.type -   c (  mutation.type ,  i ) } # now we have a matrix with pairs samples/genes mutations # we want a matrix with samples vs genes mutations with the content being the value   mat -   setDF (   dcast (  mat ,   Tumor_Sample_Barcode ~  Hugo_Symbol , value.var =  \"value\" , fill =  \"\" ) )    rownames (  mat ) -   mat [ ,  1 ]   mat -   mat [ ,  -  1 ]  if (   rm.empty.columns ==  FALSE )  {   aux -   data.frame ( row.names =   all.samples [  !   all.samples %in%   rownames (  mat ) ] )  if (    nrow (  aux ) undefined  0 )  {    aux [ ,   colnames (  mat ) ] -  \"\"   mat -   rbind (  mat ,  aux ) } }   alter_fun =  function ( x , y , w , h , v )  {   n =   sum (  v )   h =   h *  0.9 # use `names(which(v))` to correctly map between `v` and `col`  if (  n )  {   grid.rect (  x ,    y -   h *  0.5 +     1 :  n /  n *  h ,   w -   unit (  dist.col ,  \"mm\" ) ,    1 /  n *  h , gp =   gpar ( fill =   color [   names (   which (  v ) ) ] , col =  NA ) , just =  \"top\" ) } else  {   grid.rect (  x ,  y ,   w -   unit (  dist.col ,  \"mm\" ) ,   h -   unit (  dist.row ,  \"mm\" ) , gp =   gpar ( fill =   color [  \"background\" ] , col =  NA ) ) } } # get only the colors to the mutations # otherwise it gives errors  if (   missing (  color ) )  {   color -   c (   rainbow (   length (  mutation.type ) ) ,  \"#CCCCCC\" )    names (  color ) -   c (  mutation.type ,  \"background\" ) } else  {  if (   \"background\" %in%   names (  color ) )  {   color -   color [   c (  mutation.type ,  \"background\" ) ] } else  {   color -   c (   color [  mutation.type ] , \"background\" =  \"#CCCCCC\" ) } } # header are samples, rows genes   mat -   t (  mat )  if (  !   missing (  height ) )   height -    length (  genes ) /  2  if (  !   missing (  filename ) )   pdf (  filename , width =  width , height =  height )  if (   missing (  annotation ) )   annotation -  NULL  if (  !   is.null (  annotation ) )  {  if (  !   \"bcr_patient_barcode\" %in%   colnames (  annotation ) )   stop (  \"bcr_patient_barcode column should be in the annotation\" )   idx -   match (   substr (   colnames (  mat ) ,  1 ,  12 ) ,   annotation $ bcr_patient_barcode )  if (   all (   is.na (  idx ) ) )   stop (  \" We couldn't match the columns names with the bcr_patient_barcode column in the annotation object\" )   annotation -   annotation [  idx , ]    annotation $ bcr_patient_barcode -  NULL   n.col -   sum (   sapply (   colnames (  annotation ) ,  function ( x )  {   length (   unique (   annotation [ ,  x ] ) ) } ) ) # add automatic colors: not working   get.color -  function ( df , col )  {   idx -   which (    colnames (  df ) ==  col )   start -  1  if (   idx !=  1 )   start -    length (   na.omit (   unique (   unlist (   c (   df [ ,   1 :  (   idx -  1 ) ] ) ) ) ) ) +  1   end -    start +   length (   na.omit (   unique (   df [ ,  col ] ) ) ) -  1   diff.colors -   c (  \"purple\" ,  \"thistle\" ,  \"deeppink3\" ,  \"magenta4\" ,  \"lightsteelblue1\" ,  \"black\" ,  \"chartreuse\" ,  \"lightgreen\" ,  \"maroon4\" ,  \"darkslategray\" ,  \"lightyellow3\" ,  \"darkslateblue\" ,  \"firebrick1\" ,  \"aquamarine\" ,  \"dodgerblue4\" ,  \"bisque4\" ,  \"moccasin\" ,  \"indianred1\" ,  \"yellow\" ,  \"gray93\" ,  \"cyan\" ,  \"darkseagreen4\" ,  \"lightgoldenrodyellow\" ,  \"lightpink\" ,  \"sienna1\" ,  \"darkred\" ,  \"palevioletred\" ,  \"tomato4\" ,  \"blue\" ,  \"mediumorchid4\" ,  \"royalblue1\" ,  \"magenta2\" ,  \"darkgoldenrod1\" )   return (   diff.colors [   start :  end ] ) }   col.annot -   lapply (   colnames (  annotation ) ,  function ( x )  { #idx #print(idx/n.col)   ret -   get.color (  annotation ,  x ) #ret    names (  ret ) -   as.character (   na.omit (   unique (   annotation [ ,  x ] ) ) )   return (  ret ) } )    names (  col.annot ) -   colnames (  annotation )   annotHeatmap -   HeatmapAnnotation ( df =  annotation , col =  col.annot , annotation_legend_param =   list ( title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , #sizelabels grid_height =   unit (  8 ,  \"mm\" ) ) ) }  if (   heatmap.legend.side ==  \"bottom\" )  {   nrow -  1   title_position -  \"leftcenter\" } else  {   nrow -  10   title_position -  \"topcenter\" }  if (     is.null (  annotation ) undefined  !  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  !  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  !  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     is.null (  annotation ) undefined  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  row.order undefined  !  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , column_order =  NULL , # Do not sort the columns alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     is.null (  annotation ) undefined  !  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  !  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  !  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , row_order =  NULL , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     is.null (  annotation ) undefined  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"bottom\" undefined  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , column_names_gp =   gpar ( fontsize =  column.names.size ) , show_row_barplot =  show.row.barplot , show_column_names =  show.column.names , alter_fun =  alter_fun , col =  color , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot bottom_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) } else  if (     !   is.null (  annotation ) undefined   annotation.position ==  \"top\" undefined  row.order undefined  col.order )  {   p -   oncoPrint (  mat , get_type =  function ( x )    strsplit (  x ,  \";\" ) [[  1 ] ] , remove_empty_columns =  FALSE , show_column_names =  show.column.names , show_row_barplot =  show.row.barplot , alter_fun =  alter_fun , col =  color , column_names_gp =   gpar ( fontsize =  column.names.size ) , row_names_gp =   gpar ( fontsize =  rows.font.size ) , # set size for row names pct_gp =   gpar ( fontsize =  rows.font.size ) , # set size for percentage labels axis_gp =   gpar ( fontsize =  rows.font.size ) , # size of axis #column_title = \"OncoPrint for TCGA LGG, genes in Glioma signaling\", #column_title_gp = gpar(fontsize = 11), row_barplot_width =   unit (  2 ,  \"cm\" ) , #size barplot top_annotation =  annotHeatmap , heatmap_legend_param =   list ( title =  label.title , at =   names (  color ) , labels =   names (  color ) , title_gp =   gpar ( fontsize =  label.font.size , fontface =  \"bold\" ) , labels_gp =   gpar ( fontsize =  label.font.size ) , # size labels grid_height =   unit (  8 ,  \"mm\" ) , # vertical distance labels nrow =  nrow , title_position =  title_position ) ) }   draw (  p , heatmap_legend_side =  heatmap.legend.side , annotation_legend_side =  annotation.legend.side )  if (  !   missing (  filename ) )  {   dev.off ( )   message (   paste0 (  \"File saved as: \" ,  filename ) ) } } ",
    "filename": "visualize.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_4 tcgabiolinks_release_3_5

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_4 tcgabiolinks_release_3_5",
    "desc_release_old": "2.2.10",
    "desc_release_new": "2.5.9",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 1,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 3
}

##########
Functions Removed
##########

TCGAvisualize_Tables


##########
Functions Added
##########

gaiaCNVplot
getAdjacencyBiogrid
getDataCategorySummary
getGDCInfo
getGistic
matchedMetExp


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"Gene_symbol\" ,   colnames (  met ) , ignore.case =  TRUE )     colnames (  met ) [  idx ] -  \"Gene_symbol\" # Check if gene symbol columns exists  if (  !   any (   grepl (  \"Gene_symbol\" ,   colnames (  exp ) , ignore.case =  FALSE ) ) )  {  if (   \"mRNA\" %in%   colnames (  exp ) )  {  if (   all (   grepl (  \"\\\\|\" ,   exp $ mRNA ) ) )  {    exp $ Gene_symbol -   unlist (   lapply (   strsplit (   exp $ mRNA ,  \"\\\\|\" ) ,  function ( x )   x [  2 ] ) ) } else  {    exp $ Gene_symbol -   exp $ mRNA } } else  {   aux -   rownames (  exp )  if (   all (   grepl (  \"\\\\|\" ,  aux ) ) )  {    exp $ Gene_symbol -   unlist (   lapply (   strsplit (  aux ,  \"\\\\|\" ) ,  function ( x )   x [  2 ] ) ) } else  {    exp $ Gene_symbol -  aux } } } else  { # Check if it has the same pattern   idx -   grep (  \"Gene_symbol\" ,   colnames (  exp ) , ignore.case =  TRUE )     colnames (  exp ) [  idx ] -  \"Gene_symbol\" }   volcano -   merge (  met ,  exp , by =  \"Gene_symbol\" )    volcano $ ID -   paste (   volcano $ Gene_symbol ,   volcano $ probeID , sep =  \".\" ) # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ]   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hipermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr ) # Group 2:up regulated and hypomethylated   a -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   a.sig -   subset (  a ,     abs (   a [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   a $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   b.sig -   subset (  b ,     abs (   b [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   b $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 5: hypermethylated   d -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr ) # Group 6: upregulated   e -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 7: downregulated   f -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 8: upregulated and hypermethylated   g -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr )   g.sig -   subset (  g ,     abs (   g [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   g $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr )   h.sig -   subset (  h ,     abs (   h [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   h $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [  idx ,  \"starburst.status\" ] -   state [  i ] } }   size -   rep (  2 ,  4 )   shape -   as.character (   rep (  2 ,  4 ) )   volcano_normal -  volcano   significant -  NULL   s -   list (  a.sig ,  b.sig ,  g.sig ,  h.sig )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.size\" ] -   size [  i ]    volcano [  idx ,  \"shape\" ] -   shape [  i ]   significant -   rbind (  significant ,   volcano [  idx , ] ) } } ## starburst plot   p -    ggplot ( data =  volcano_normal , environment =  .e ,   aes ( x =   volcano_normal $ meFDR2 , y =   volcano_normal $ geFDR2 , colour =   volcano_normal $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_symbol , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_symbol , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   subset (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , met.platform , genome , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{  if (   missing (  genome ) )   stop (  \"Please set genome (hg19 or hg38)\" )  if (   missing (  met.platform ) )   stop (  \"Please set met.platform (EPIC, 450K or 27K)\" )   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Transform factor coluns to characters   fctr.cols -   sapply (  exp ,  is.factor )    exp [ ,  fctr.cols ] -   sapply (   exp [ ,  fctr.cols ] ,  as.character ) # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"ENSG\" ,   exp [  1 , ] )  if (    length (  idx ) undefined  0 )  {     colnames (  exp ) [  idx ] -  \"ensembl_gene_id\" } else  { # it is in the row names ?  if (   grepl (  \"ENSG\" ,    rownames (  exp ) [  1 ] ) )  {    exp $ ensembl_gene_id -   rownames (  exp ) } else  { # We will consider our rownames has the gene symbol   gene.info -   get.GRCh.bioMart (  genome )  if (   any (   sapply (    rownames (  exp ) [   1 :  10 ] ,  function ( y )   any (   grepl (  y ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] ) ) ) ) )  {   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )   exp -   exp [  !   is.na (  idx ) , ]   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )    exp $ ensembl_gene_id -   gene.info [  idx ,  \"ensembl_gene_id\" ] } } }  if (  !   \"probeID\" %in%   colnames (  met ) )    met $ probeID -   met $ Composite.Element.REF # Check if gene symbol columns exists  if (  !   \"ensembl_gene_id\" %in%   colnames (  exp ) )  {   stop (  \"Column ensembl_gene_id was not found\" ) } # Correlate gene expression with DNA methylation levels # Step 1: identify nearest TSS for each probe # Step 2: create a table with probe, gene, transcript, distance.TSS and merge with #         the met (by probe name) and gene expression (by gene name) results   message (  \"o Fetching auxiliary information\" )   message (  \"oo Fetching probes genomic information\" )   met.info -   getMetPlatInfo ( genome =  genome , platform =  met.platform )    values (  met.info ) -  NULL   message (  \"oo Fetching TSS information\" )   tss -   getTSS ( genome =  genome )   message (  \"o Mapping probes to nearest TSS\" )   dist -   distanceToNearest (  tss ,  met.info )   g -   suppressWarnings (   as.data.frame (   tss [   queryHits (  dist ) ] ) )    g $ start_position -  NULL    g $ end_position -  NULL     colnames (  g ) [   1 :  5 ] -   paste0 (  \"gene_\" ,    colnames (  g ) [   1 :  5 ] )   m -   suppressWarnings (   as.data.frame (   met.info [   subjectHits (  dist ) ] , row.names =  NULL ) )    colnames (  m ) -   paste0 (  \"probe_\" ,   colnames (  m ) )    m $ probeID -   names (   met.info [   subjectHits (  dist ) ] )   nearest -   cbind (  m ,  g ) # END mapping nearest probe to nearest gene   message (  \"o Mapping results information\" )   volcano -   plyr :: join (  nearest ,  exp , by =  \"ensembl_gene_id\" )   volcano -   merge (  volcano ,  met , by =  \"probeID\" )    volcano $ ID -   paste (   volcano $ Gene_symbol ,   volcano $ ensembl_transcript_id ,   volcano $ probeID , sep =  \".\" )   volcano -   volcano [  !   is.na (   volcano $ FDR ) , ] # Some genes have no values # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ] # Preparing DNA methylation   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hypermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr )   volcano -   suppressWarnings (   tibble :: as.tibble (  volcano ) ) # Group 2:up regulated and hypomethylated   a -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 5: hypermethylated   d -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 6: upregulated   e -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 7: downregulated   f -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 8: upregulated and hypermethylated   g -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {    volcano [    volcano $ ID %in%  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [    volcano $ ID %in%  idx ,  \"starburst.status\" ] -   state [  i ] } }   s -   list (  a ,  b ,  g ,  h )   significant -  NULL  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {   significant -   rbind (  significant ,   volcano [    volcano $ ID %in%  idx , ] ) } }   message (  \"o Plotting figure\" )   volcano.aux -  volcano # we need an auxiliry data if dats is returned ## starburst plot   p -    ggplot ( data =  volcano.aux , environment =  .e ,   aes ( x =   volcano.aux $ meFDR2 , y =   volcano.aux $ geFDR2 , colour =   volcano.aux $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"oo Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   dplyr :: filter (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }   message (  \"o Saving results\" )   message (  \"oo Saving significant results as: starburst_results.csv\" )   message (  \"oo It contains pair with changes both in the expression level of the nearest gene and  in the DNA methylation level\" )   suppressWarnings (   write_csv ( x =  volcano , path =  \"starburst_results.csv\" ) )  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "GDCdownload",
    "representation": "GDCdownload",
    "parameters": "function ( query , token.file , method = \"api\" , directory = \"GDCdata\" , chunks.per.download = NULL )",
    "body": "{   isServeOK ( )  if (   missing (  query ) )   stop (  \"Please set query argument\" )  if (  !  (   method %in%   c (  \"api\" ,  \"client\" ) ) )   stop (  \"method arguments possible values are: 'api' or 'client'\" )   manifest -     query $ results [[  1 ] ] [ ,   c (  \"file_id\" ,  \"file_name\" ,  \"md5sum\" ,  \"file_size\" ,  \"state\" ) ]    colnames (  manifest ) -   c (  \"id\" ,  \"filename\" ,  \"md5\" ,  \"size\" ,  \"state\" )   source -   ifelse (   query $ legacy ,  \"legacy\" ,  \"harmonized\" )   dir.create (  directory , showWarnings =  FALSE , recursive =  TRUE )  for  ( proj in   unique (   unlist (   query $ project ) ) )  {   message (  \"Downloading data for project \" ,  proj )   query.aux -  query     query.aux $ results [[  1 ] ] -     query.aux $ results [[  1 ] ] [      query.aux $ results [[  1 ] ] $ project ==  proj , ]   path -   unique (   file.path (  proj ,  source ,   gsub (  \" \" ,  \"_\" ,     query.aux $ results [[  1 ] ] $ data_category ) ,   gsub (  \" \" ,  \"_\" ,     query.aux $ results [[  1 ] ] $ data_type ) ) )   path -   file.path (  directory ,  path ) # Check if the files were already downloaded by this package   files2Download -  !   file.exists (   file.path (  path ,   manifest $ id ,   manifest $ filename ) )  if (   any (   files2Download ==  FALSE ) )  {   message (  \"Of the \" ,   nrow (  manifest ) ,  \" files for download \" ,    table (  files2Download ) [  \"FALSE\" ] ,  \" already exist.\" )  if (   any (   files2Download ==  TRUE ) )   message (  \"We will download only those that are missing ones.\" ) }   manifest -   manifest [  files2Download , ] # There is a bug in the API, if the files has the same name it will not download correctly # so method should be set to client if there are files with duplicated names # However for clinical XML recurrent and primary are the same file. So we will ignore that case  if (    nrow (  manifest ) undefined   length (   unique (   manifest $ filename ) ) )   method -  \"client\"  if (     nrow (  manifest ) !=  0 undefined   method ==  \"client\" )  { # There exists two options to download the data, using the query or using a manifest file # The second option was created to let users use legacy data or the API to search # This will find gdc clinet, if not installed it will install it   gdc.client.bin -   GDCclientInstall ( ) # Using the query argument we will organize the files to the user # Creates a file with the gdc manifest format   write_delim (  manifest ,  \"gdc_manifest.txt\" , delim =  \"\\t\" )   cmd -   paste0 (  gdc.client.bin ,  \" download -m gdc_manifest.txt\" )  if (  !   missing (  token.file ) )   cmd -   paste0 (  cmd ,  \" -t \" ,  token.file ) # Download all the files in the manifest using gdc client   message (   paste0 (  \"GDCdownload will download: \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) )   message (   paste0 (  \"Executing GDC client with the following command:\\n\" ,  cmd ) )   result =   tryCatch (  {   system (  cmd ) } , warning =  function ( w )  { } , error =  function ( e )  { } , finally =  { # moving the file to make it more organized  for  ( i in   manifest $ id )   move (  i ,   file.path (  path ,  i ) ) } ) } else  if (     nrow (  manifest ) !=  0 undefined   method ==  \"api\" )  {  if (    nrow (  manifest ) undefined  1 )  {   name -   paste0 (   gsub (  \" |:\" ,  \"_\" ,   date ( ) ) ,  \".tar.gz\" )   unlink (  name )   message (   paste0 (  \"GDCdownload will download \" ,   nrow (  manifest ) ,  \" files. A total of \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) ) } else  { # case with one file only. This is not at tar.gz   name -   manifest $ filename   message (   paste0 (  \"GDCdownload will download: \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) ) }   server -   ifelse (   query $ legacy ,  \"https://gdc-api.nci.nih.gov/legacy/data/\" ,  \"https://gdc-api.nci.nih.gov/data/\" )  if (   is.null (  chunks.per.download ) )  {   message (   paste0 (  \"Downloading as: \" ,  name ) )   tryCatch (  {   GDCdownload.aux (  server ,  manifest ,  name ,  path ) } , error =  function ( e )  {   message (  \"Download failed. We will retry with smaller chuncks\" ) # split in groups of 100 MB   step -   ceiling (   100000000 /    manifest $ size [  1 ] )  if (   step ==  0 )   step -  1   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } ) } else  {   step -  chunks.per.download # If error we will try another time.   tryCatch (  {   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } , error =  function ( e )  {   message (  \"At least one of the chuncks download was not correct. We will retry\" )   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } ) } } else  {   message (  \"All samples have been already downloaded\" ) } } } ",
    "filename": "download.txt"
  },
  "new_function": {
    "name": "GDCdownload",
    "representation": "GDCdownload",
    "parameters": "function ( query , token.file , method = \"api\" , directory = \"GDCdata\" , files.per.chunk = NULL )",
    "body": "{   isServeOK ( )  if (   missing (  query ) )   stop (  \"Please set query argument\" )  if (  !  (   method %in%   c (  \"api\" ,  \"client\" ) ) )   stop (  \"method arguments possible values are: 'api' or 'client'\" )   source -   ifelse (   query $ legacy ,  \"legacy\" ,  \"harmonized\" )   dir.create (  directory , showWarnings =  FALSE , recursive =  TRUE )  for  ( proj in   unique (   unlist (   query $ project ) ) )  {   message (  \"Downloading data for project \" ,  proj )   query.aux -  query   results -    getResults (  query.aux ) [     getResults (  query.aux ) $ project ==  proj , ]     query.aux $ results [[  1 ] ] -  results   manifest -     query.aux $ results [[  1 ] ] [ ,   c (  \"file_id\" ,  \"file_name\" ,  \"md5sum\" ,  \"file_size\" ,  \"state\" ) ]    colnames (  manifest ) -   c (  \"id\" ,  \"filename\" ,  \"md5\" ,  \"size\" ,  \"state\" )   path -   unique (   file.path (  proj ,  source ,   gsub (  \" \" ,  \"_\" ,   results $ data_category ) ,   gsub (  \" \" ,  \"_\" ,   results $ data_type ) ) )   path -   file.path (  directory ,  path ) # Check if the files were already downloaded by this package   manifest -   checkAlreadyDownloaded (  path ,  manifest ) # There is a bug in the API, if the files has the same name it will not download correctly # so method should be set to client if there are files with duplicated names # However for clinical XML recurrent and primary are the same file. So we will ignore that case  if (    nrow (  manifest ) undefined   length (   unique (   manifest $ filename ) ) )   method -  \"client\"  if (     nrow (  manifest ) !=  0 undefined   method ==  \"client\" )  { # There exists two options to download the data, using the query or using a manifest file # The second option was created to let users use legacy data or the API to search # This will find gdc clinet, if not installed it will install it   gdc.client.bin -   GDCclientInstall ( ) # Using the query argument we will organize the files to the user # Creates a file with the gdc manifest format   write_delim (  manifest ,  \"gdc_manifest.txt\" , delim =  \"\\t\" )   cmd -   paste0 (  gdc.client.bin ,  \" download -m gdc_manifest.txt\" )  if (  !   missing (  token.file ) )   cmd -   paste0 (  cmd ,  \" -t \" ,  token.file ) # Download all the files in the manifest using gdc client   message (   paste0 (  \"GDCdownload will download: \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) )   message (   paste0 (  \"Executing GDC client with the following command:\\n\" ,  cmd ) )   result =   tryCatch (  {   system (  cmd ) } , warning =  function ( w )  { } , error =  function ( e )  { } , finally =  { # moving the file to make it more organized  for  ( i in   manifest $ id )   move (  i ,   file.path (  path ,  i ) ) } ) } else  if (     nrow (  manifest ) !=  0 undefined   method ==  \"api\" )  {  if (    nrow (  manifest ) undefined  1 )  {   name -   paste0 (   gsub (  \" |:\" ,  \"_\" ,   date ( ) ) ,  \".tar.gz\" )   unlink (  name )   message (   paste0 (  \"GDCdownload will download \" ,   nrow (  manifest ) ,  \" files. A total of \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) ) } else  { # case with one file only. This is not at tar.gz   name -   manifest $ filename   message (   paste0 (  \"GDCdownload will download: \" ,   humanReadableByteCount (   sum (   as.numeric (   manifest $ size ) ) ) ) ) }   server -   ifelse (   query $ legacy ,  \"https://gdc-api.nci.nih.gov/legacy/data/\" ,  \"https://gdc-api.nci.nih.gov/data/\" )  if (    is.null (  files.per.chunk ) undefined    sum (   as.numeric (   manifest $ size ) ) undefined   10 ^  9 )  {   message (  \"The total size of files is big. We will download files in chunks\" )   files.per.chunk -   floor (    10 ^  9 /   mean (   as.numeric (   manifest $ size ) ) ) }  if (   is.null (  files.per.chunk ) )  {   message (   paste0 (  \"Downloading as: \" ,  name ) )   tryCatch (  {   GDCdownload.aux (  server ,  manifest ,  name ,  path ) } , error =  function ( e )  {   message (  \"Download failed. We will retry with smaller chunks\" ) # split in groups of 100 MB   manifest -   checkAlreadyDownloaded (  path ,  manifest )   step -   ceiling (   100000000 /    manifest $ size [  1 ] )  if (   step ==  0 )   step -  1   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } ) } else  {   step -  files.per.chunk # If error we will try another time.   tryCatch (  {   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } , error =  function ( e )  {   message (  \"At least one of the chunks download was not correct. We will retry\" )   manifest -   checkAlreadyDownloaded (  path ,  manifest )   GDCdownload.by.chunk (  server ,  manifest ,  name ,  path ,  step ) } ) } } else  {   message (  \"All samples have been already downloaded\" ) } } } ",
    "filename": "download.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"Gene_symbol\" ,   colnames (  met ) , ignore.case =  TRUE )     colnames (  met ) [  idx ] -  \"Gene_symbol\" # Check if gene symbol columns exists  if (  !   any (   grepl (  \"Gene_symbol\" ,   colnames (  exp ) , ignore.case =  FALSE ) ) )  {  if (   \"mRNA\" %in%   colnames (  exp ) )  {  if (   all (   grepl (  \"\\\\|\" ,   exp $ mRNA ) ) )  {    exp $ Gene_symbol -   unlist (   lapply (   strsplit (   exp $ mRNA ,  \"\\\\|\" ) ,  function ( x )   x [  2 ] ) ) } else  {    exp $ Gene_symbol -   exp $ mRNA } } else  {   aux -   rownames (  exp )  if (   all (   grepl (  \"\\\\|\" ,  aux ) ) )  {    exp $ Gene_symbol -   unlist (   lapply (   strsplit (  aux ,  \"\\\\|\" ) ,  function ( x )   x [  2 ] ) ) } else  {    exp $ Gene_symbol -  aux } } } else  { # Check if it has the same pattern   idx -   grep (  \"Gene_symbol\" ,   colnames (  exp ) , ignore.case =  TRUE )     colnames (  exp ) [  idx ] -  \"Gene_symbol\" }   volcano -   merge (  met ,  exp , by =  \"Gene_symbol\" )    volcano $ ID -   paste (   volcano $ Gene_symbol ,   volcano $ probeID , sep =  \".\" ) # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ]   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hipermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr ) # Group 2:up regulated and hypomethylated   a -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   a.sig -   subset (  a ,     abs (   a [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   a $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr )   b.sig -   subset (  b ,     abs (   b [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   b $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 5: hypermethylated   d -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr ) # Group 6: upregulated   e -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 7: downregulated   f -   subset (  volcano ,      volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr ) # Group 8: upregulated and hypermethylated   g -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr )   g.sig -   subset (  g ,     abs (   g [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   g $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   subset (  volcano ,     volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr )   h.sig -   subset (  h ,     abs (   h [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   h $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [  idx ,  \"starburst.status\" ] -   state [  i ] } }   size -   rep (  2 ,  4 )   shape -   as.character (   rep (  2 ,  4 ) )   volcano_normal -  volcano   significant -  NULL   s -   list (  a.sig ,  b.sig ,  g.sig ,  h.sig )  for  ( i in   seq_along (  s ) )  {   idx -   rownames (   s [[  i ] ] )  if (    length (  idx ) undefined  0 )  {    volcano [  idx ,  \"threshold.size\" ] -   size [  i ]    volcano [  idx ,  \"shape\" ] -   shape [  i ]   significant -   rbind (  significant ,   volcano [  idx , ] ) } } ## starburst plot   p -    ggplot ( data =  volcano_normal , environment =  .e ,   aes ( x =   volcano_normal $ meFDR2 , y =   volcano_normal $ geFDR2 , colour =   volcano_normal $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_symbol , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =   significant $ Gene_symbol , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   subset (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   subset (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , met.platform , genome , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{  if (   missing (  genome ) )   stop (  \"Please set genome (hg19 or hg38)\" )  if (   missing (  met.platform ) )   stop (  \"Please set met.platform (EPIC, 450K or 27K)\" )   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Transform factor coluns to characters   fctr.cols -   sapply (  exp ,  is.factor )    exp [ ,  fctr.cols ] -   sapply (   exp [ ,  fctr.cols ] ,  as.character ) # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"ENSG\" ,   exp [  1 , ] )  if (    length (  idx ) undefined  0 )  {     colnames (  exp ) [  idx ] -  \"ensembl_gene_id\" } else  { # it is in the row names ?  if (   grepl (  \"ENSG\" ,    rownames (  exp ) [  1 ] ) )  {    exp $ ensembl_gene_id -   rownames (  exp ) } else  { # We will consider our rownames has the gene symbol   gene.info -   get.GRCh.bioMart (  genome )  if (   any (   sapply (    rownames (  exp ) [   1 :  10 ] ,  function ( y )   any (   grepl (  y ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] ) ) ) ) )  {   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )   exp -   exp [  !   is.na (  idx ) , ]   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )    exp $ ensembl_gene_id -   gene.info [  idx ,  \"ensembl_gene_id\" ] } } }  if (  !   \"probeID\" %in%   colnames (  met ) )    met $ probeID -   met $ Composite.Element.REF # Check if gene symbol columns exists  if (  !   \"ensembl_gene_id\" %in%   colnames (  exp ) )  {   stop (  \"Column ensembl_gene_id was not found\" ) } # Correlate gene expression with DNA methylation levels # Step 1: identify nearest TSS for each probe # Step 2: create a table with probe, gene, transcript, distance.TSS and merge with #         the met (by probe name) and gene expression (by gene name) results   message (  \"o Fetching auxiliary information\" )   message (  \"oo Fetching probes genomic information\" )   met.info -   getMetPlatInfo ( genome =  genome , platform =  met.platform )    values (  met.info ) -  NULL   message (  \"oo Fetching TSS information\" )   tss -   getTSS ( genome =  genome )   message (  \"o Mapping probes to nearest TSS\" )   dist -   distanceToNearest (  tss ,  met.info )   g -   suppressWarnings (   as.data.frame (   tss [   queryHits (  dist ) ] ) )    g $ start_position -  NULL    g $ end_position -  NULL     colnames (  g ) [   1 :  5 ] -   paste0 (  \"gene_\" ,    colnames (  g ) [   1 :  5 ] )   m -   suppressWarnings (   as.data.frame (   met.info [   subjectHits (  dist ) ] , row.names =  NULL ) )    colnames (  m ) -   paste0 (  \"probe_\" ,   colnames (  m ) )    m $ probeID -   names (   met.info [   subjectHits (  dist ) ] )   nearest -   cbind (  m ,  g ) # END mapping nearest probe to nearest gene   message (  \"o Mapping results information\" )   volcano -   plyr :: join (  nearest ,  exp , by =  \"ensembl_gene_id\" )   volcano -   merge (  volcano ,  met , by =  \"probeID\" )    volcano $ ID -   paste (   volcano $ Gene_symbol ,   volcano $ ensembl_transcript_id ,   volcano $ probeID , sep =  \".\" )   volcano -   volcano [  !   is.na (   volcano $ FDR ) , ] # Some genes have no values # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ] # Preparing DNA methylation   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hypermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr )   volcano -   suppressWarnings (   tibble :: as.tibble (  volcano ) ) # Group 2:up regulated and hypomethylated   a -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 5: hypermethylated   d -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 6: upregulated   e -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 7: downregulated   f -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 8: upregulated and hypermethylated   g -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {    volcano [    volcano $ ID %in%  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [    volcano $ ID %in%  idx ,  \"starburst.status\" ] -   state [  i ] } }   s -   list (  a ,  b ,  g ,  h )   significant -  NULL  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {   significant -   rbind (  significant ,   volcano [    volcano $ ID %in%  idx , ] ) } }   message (  \"o Plotting figure\" )   volcano.aux -  volcano # we need an auxiliry data if dats is returned ## starburst plot   p -    ggplot ( data =  volcano.aux , environment =  .e ,   aes ( x =   volcano.aux $ meFDR2 , y =   volcano.aux $ geFDR2 , colour =   volcano.aux $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"oo Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   dplyr :: filter (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }   message (  \"o Saving results\" )   message (  \"oo Saving significant results as: starburst_results.csv\" )   message (  \"oo It contains pair with changes both in the expression level of the nearest gene and  in the DNA methylation level\" )   suppressWarnings (   write_csv ( x =  volcano , path =  \"starburst_results.csv\" ) )  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_5 tcgabiolinks_release_3_6

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_5 tcgabiolinks_release_3_6",
    "desc_release_old": "2.5.9",
    "desc_release_new": "2.6.12",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 1,
    "function_additions": 7,
    "parameter_removals": 1,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 2,
    "total_count": 3
}

##########
Functions Removed
##########

TCGAprepare_elmer


##########
Functions Added
##########

PanCancerAtlas_subtypes
TCGA_MolecularSubtype
TCGAbatch_Correction
TCGAquery_recount2
TCGAtumor_purity
UseRaw_afterFilter
getManifest


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 , group1 , group2 )",
    "body": "{   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist )   dataCancer -   dataGE [  Genelist ,  group2 ]   dataNormal -   dataGE [  Genelist ,  group1 ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]  if (   \"days_to_last_followup\" %in%   colnames (  cfu ) )     colnames (  cfu ) [   grep (  \"days_to_last_followup\" ,   colnames (  cfu ) ) ] -  \"days_to_last_follow_up\"   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) ) # Set alive death to inf  if (    length (   grep (  \"alive\" ,   cfu $ vital_status , ignore.case =  TRUE ) ) undefined  0 )    cfu [   grep (  \"alive\" ,   cfu $ vital_status , ignore.case =  TRUE ) ,  \"days_to_death\" ] -  \"-Inf\" # Set dead follow up to inf  if (    length (   grep (  \"dead\" ,   cfu $ vital_status , ignore.case =  TRUE ) ) undefined  0 )    cfu [   grep (  \"dead\" ,   cfu $ vital_status , ignore.case =  TRUE ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE   Survresult -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) )  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  { #print(i)   cat (   paste (  (   ngenes -  i ) ,  \".\" , sep =  \"\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (   as.numeric (  mRNAselected_values_ordered ) ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (   as.numeric (  mRNAselected_values_ordered ) ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (    is.na (  mRNAselected_values_ordered_top ) !=  1 )  {   numberOfSamples -   ncol (   as.matrix (  mRNAselected_values_ordered ) )   lastelementTOP -   round (   numberOfSamples /  3 )   firstelementDOWN -   numberOfSamples -  lastelementTOP   samples_top_mRNA_selected -   colnames (   as.matrix (   mRNAselected_values_ordered [   1 :  (   lastelementTOP -  1 ) ] ) )   samples_down_mRNA_selected -   colnames (   as.matrix (   mRNAselected_values_ordered [   (   firstelementDOWN +  1 ) :  numberOfSamples ] ) )   samples_UNCHANGED_mRNA_selected -   rownames (   as.matrix (   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ) )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ] #if( followUpLevel == TRUE) #{ # samplesTop_over_followUplevel #  cfu_onlyTOP # samplesDown_over_followUplevel #cfu_onlyDOWN #print(paste(\"Processing ... with followUP level #  } # else { #  print(paste(\"Processing ... without followUP level and\", nrow(as.matrix(cfu)),\"clinical samples\")) #}   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered # print(dim(cfu)) # } #end else with all samples   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] ) #ttime   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 } #print(paste(\"deaths =\",deads_complete))    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (   as.numeric (  mRNAselected_values_normal ) )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (   as.numeric (  dataCancer_onlyTop_sample_mRNASelected ) )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (   as.numeric (  dataCancer_onlyDown_sample_mRNASelected ) )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] ) #ttime[!status]    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   length (  ttime ) #plot(survfit(ttime ~ 1)) #plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)), rep(\"unchanged\", nrow(cfu_onlyUNCHANGED)))), col = c(\"red\", \"green\",\"grey\")) #   plot(survfit(ttime ~ c(rep(\"top\", nrow(cfu_onlyTOP)), rep(\"down\", nrow(cfu_onlyDOWN)))), col = c(\"red\", \"green\"),main= mRNAselected)   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) #miRselected_surv_results_pvalue    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue #print(paste(i,\"....\",mRNAselected,\"pvalue=\",tabSurv_pvalue))  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ]    colnames (  tabSurvKM ) -   gsub (  \"Cancer\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Tumor\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Normal\" ,  \"Group1\" ,   colnames (  tabSurvKM ) )   return (  tabSurvKM ) } ",
    "filename": "analyze.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_SurvivalKM",
    "representation": "TCGAanalyze_SurvivalKM",
    "parameters": "function ( clinical_patient , dataGE , Genelist , Survresult = FALSE , ThreshTop = 0.67 , ThreshDown = 0.33 , p.cut = 0.05 , group1 , group2 )",
    "body": "{ # Check which genes we really have in the matrix   Genelist -   intersect (   rownames (  dataGE ) ,  Genelist ) # Split gene expression matrix btw the groups   dataCancer -   dataGE [  Genelist ,  group2 , drop =  FALSE ]   dataNormal -   dataGE [  Genelist ,  group1 , drop =  FALSE ]    colnames (  dataCancer ) -   substr (   colnames (  dataCancer ) ,  1 ,  12 )   cfu -   clinical_patient [    clinical_patient [ ,  \"bcr_patient_barcode\" ] %in%   substr (   colnames (  dataCancer ) ,  1 ,  12 ) , ]  if (   \"days_to_last_followup\" %in%   colnames (  cfu ) )     colnames (  cfu ) [   grep (  \"days_to_last_followup\" ,   colnames (  cfu ) ) ] -  \"days_to_last_follow_up\"   cfu -   as.data.frame (   subset (  cfu , select =   c (  \"bcr_patient_barcode\" ,  \"days_to_death\" ,  \"days_to_last_follow_up\" ,  \"vital_status\" ) ) ) # Set alive death to inf  if (    length (   grep (  \"alive\" ,   cfu $ vital_status , ignore.case =  TRUE ) ) undefined  0 )    cfu [   grep (  \"alive\" ,   cfu $ vital_status , ignore.case =  TRUE ) ,  \"days_to_death\" ] -  \"-Inf\" # Set dead follow up to inf  if (    length (   grep (  \"dead\" ,   cfu $ vital_status , ignore.case =  TRUE ) ) undefined  0 )    cfu [   grep (  \"dead\" ,   cfu $ vital_status , ignore.case =  TRUE ) ,  \"days_to_last_follow_up\" ] -  \"-Inf\"   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   followUpLevel -  FALSE #FC_FDR_table_mRNA   tabSurv_Matrix -   matrix (  0 ,   nrow (   as.matrix (   rownames (  dataNormal ) ) ) ,  8 )    colnames (  tabSurv_Matrix ) -   c (  \"mRNA\" ,  \"pvalue\" ,  \"Cancer Deaths\" ,  \"Cancer Deaths with Top\" ,  \"Cancer Deaths with Down\" ,  \"Mean Tumor Top\" ,  \"Mean Tumor Down\" ,  \"Mean Normal\" )   tabSurv_Matrix -   as.data.frame (  tabSurv_Matrix )    cfu $ days_to_death -   as.numeric (   as.character (   cfu $ days_to_death ) )    cfu $ days_to_last_follow_up -   as.numeric (   as.character (   cfu $ days_to_last_follow_up ) )    rownames (  cfu ) -   cfu [ ,  \"bcr_patient_barcode\" ] #mod1   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_last_follow_up\" ] ) ) , ]   cfu -   cfu [  !  (   is.na (   cfu [ ,  \"days_to_death\" ] ) ) , ]   cfu_complete -  cfu   ngenes -   nrow (   as.matrix (   rownames (  dataNormal ) ) ) # Evaluate each gene  for  ( i in   1 :   nrow (   as.matrix (   rownames (  dataNormal ) ) ) )  {   cat (   paste0 (  (   ngenes -  i ) ,  \".\" ) )   mRNAselected -    as.matrix (   rownames (  dataNormal ) ) [  i ]   mRNAselected_values -   dataCancer [    rownames (  dataCancer ) ==  mRNAselected , ]   mRNAselected_values_normal -   dataNormal [    rownames (  dataNormal ) ==  mRNAselected , ]  if (   all (   mRNAselected_values ==  0 ) )  next # All genes are 0    tabSurv_Matrix [  i ,  \"mRNA\" ] -  mRNAselected # Get Thresh values for cancer expression   mRNAselected_values_ordered -   sort (  mRNAselected_values , decreasing =  TRUE )   mRNAselected_values_ordered_top -   as.numeric (    quantile (   as.numeric (  mRNAselected_values_ordered ) ,  ThreshTop ) [  1 ] )   mRNAselected_values_ordered_down -   as.numeric (    quantile (   as.numeric (  mRNAselected_values_ordered ) ,  ThreshDown ) [  1 ] )   mRNAselected_values_newvector -  mRNAselected_values  if (  !   is.na (  mRNAselected_values_ordered_top ) )  { # How many samples do we have   numberOfSamples -   length (  mRNAselected_values_ordered ) # High group (above ThreshTop)   lastelementTOP -   max (   which (   mRNAselected_values_ordered undefined  mRNAselected_values_ordered_top ) ) # Low group (below ThreshDown)   firstelementDOWN -   min (   which (   mRNAselected_values_ordered =  mRNAselected_values_ordered_down ) )   samples_top_mRNA_selected -   names (   mRNAselected_values_ordered [   1 :  lastelementTOP ] )   samples_down_mRNA_selected -   names (   mRNAselected_values_ordered [   firstelementDOWN :  numberOfSamples ] ) # Which samples are in the intermediate group (above ThreshLow and below ThreshTop)   samples_UNCHANGED_mRNA_selected -   names (   mRNAselected_values_newvector [   which (    (  mRNAselected_values_newvector ) undefined  mRNAselected_values_ordered_down undefined   mRNAselected_values_newvector undefined  mRNAselected_values_ordered_top ) ] )   cfu_onlyTOP -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_top_mRNA_selected , ]   cfu_onlyDOWN -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_down_mRNA_selected , ]   cfu_onlyUNCHANGED -   cfu_complete [    cfu_complete [ ,  \"bcr_patient_barcode\" ] %in%  samples_UNCHANGED_mRNA_selected , ]   cfu_ordered -  NULL   cfu_ordered -   rbind (  cfu_onlyTOP ,  cfu_onlyDOWN )   cfu -  cfu_ordered   ttime -   as.numeric (   cfu [ ,  \"days_to_death\" ] )   sum (   status -   ttime undefined  0 ) # morti   deads_complete -   sum (   status -   ttime undefined  0 )   ttime_only_top -   cfu_onlyTOP [ ,  \"days_to_death\" ]   deads_top -   sum (   ttime_only_top undefined  0 )  if (     dim (  cfu_onlyDOWN ) [  1 ] =  1 )  {   ttime_only_down -   cfu_onlyDOWN [ ,  \"days_to_death\" ]   deads_down -   sum (   ttime_only_down undefined  0 ) } else  {   deads_down -  0 }    tabSurv_Matrix [  i ,  \"Cancer Deaths\" ] -  deads_complete    tabSurv_Matrix [  i ,  \"Cancer Deaths with Top\" ] -  deads_top    tabSurv_Matrix [  i ,  \"Cancer Deaths with Down\" ] -  deads_down    tabSurv_Matrix [  i ,  \"Mean Normal\" ] -   mean (   as.numeric (  mRNAselected_values_normal ) )   dataCancer_onlyTop_sample -   dataCancer [ ,  samples_top_mRNA_selected , drop =  FALSE ]   dataCancer_onlyTop_sample_mRNASelected -   dataCancer_onlyTop_sample [    rownames (  dataCancer_onlyTop_sample ) ==  mRNAselected , ]   dataCancer_onlyDown_sample -   dataCancer [ ,  samples_down_mRNA_selected , drop =  FALSE ]   dataCancer_onlyDown_sample_mRNASelected -   dataCancer_onlyDown_sample [    rownames (  dataCancer_onlyDown_sample ) ==  mRNAselected , ]    tabSurv_Matrix [  i ,  \"Mean Tumor Top\" ] -   mean (   as.numeric (  dataCancer_onlyTop_sample_mRNASelected ) )    tabSurv_Matrix [  i ,  \"Mean Tumor Down\" ] -   mean (   as.numeric (  dataCancer_onlyDown_sample_mRNASelected ) )    ttime [  !  status ] -   as.numeric (   cfu [  !  status ,  \"days_to_last_follow_up\" ] )    ttime [   which (   ttime ==  -  Inf ) ] -  0   ttime -   Surv (  ttime ,  status )    rownames (  ttime ) -   rownames (  cfu )   legendHigh -   paste (  mRNAselected ,  \"High\" )   legendLow -   paste (  mRNAselected ,  \"Low\" )   tabSurv_pvalue -   tryCatch (  {   tabSurv -   survdiff (   ttime ~   c (   rep (  \"top\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"down\" ,   nrow (  cfu_onlyDOWN ) ) ) )   tabSurv_chis -    unlist (  tabSurv ) $ chisq   tabSurv_pvalue -   as.numeric (   1 -   pchisq (   abs (   tabSurv $ chisq ) , df =  1 ) ) } , error =  function ( e )  {   return (  Inf ) } )    tabSurv_Matrix [  i ,  \"pvalue\" ] -  tabSurv_pvalue  if (   Survresult ==  TRUE )  {   titlePlot -   paste (  \"Kaplan-Meier Survival analysis, pvalue=\" ,  tabSurv_pvalue )   plot (   survfit (   ttime ~   c (   rep (  \"low\" ,   nrow (  cfu_onlyTOP ) ) ,   rep (  \"high\" ,   nrow (  cfu_onlyDOWN ) ) ) ) , col =   c (  \"green\" ,  \"red\" ) , main =  titlePlot , xlab =  \"Days\" , ylab =  \"Survival\" )   legend (  100 ,  1 , legend =   c (  legendLow ,  legendHigh ) , col =   c (  \"green\" ,  \"red\" ) , text.col =   c (  \"green\" ,  \"red\" ) , pch =  15 )   print (  tabSurv ) } } #end if } #end for    tabSurv_Matrix [   tabSurv_Matrix ==  \"-Inf\" ] -  0   tabSurvKM -  tabSurv_Matrix # Filtering by selected pvalue   tabSurvKM -   tabSurvKM [    tabSurvKM $ mRNA !=  0 , ]   tabSurvKM -   tabSurvKM [    tabSurvKM $ pvalue undefined  p.cut , ]   tabSurvKM -   tabSurvKM [  !   duplicated (   tabSurvKM $ mRNA ) , ]    rownames (  tabSurvKM ) -   tabSurvKM $ mRNA   tabSurvKM -   tabSurvKM [ ,  -  1 ]   tabSurvKM -   tabSurvKM [   order (   tabSurvKM $ pvalue , decreasing =  FALSE ) , ]    colnames (  tabSurvKM ) -   gsub (  \"Cancer\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Tumor\" ,  \"Group2\" ,   colnames (  tabSurvKM ) )    colnames (  tabSurvKM ) -   gsub (  \"Normal\" ,  \"Group1\" ,   colnames (  tabSurvKM ) )   return (  tabSurvKM ) } ",
    "filename": "analyze.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_DEA",
    "representation": "TCGAanalyze_DEA",
    "parameters": "function ( mat1 , mat2 , Cond1type , Cond2type , method = \"exactTest\" , fdr.cut = 1 , logFC.cut = 0 , elementsRatio = 30000 )",
    "body": "{   TOC -   cbind (  mat1 ,  mat2 )   Cond1num -   ncol (  mat1 )   Cond2num -   ncol (  mat2 )   message (  \"----------------------- DEA -------------------------------\" )   message (   message1 -   paste (  \"there are Cond1 type\" ,  Cond1type ,  \"in \" ,  Cond1num ,  \"samples\" ) )   message (   message2 -   paste (  \"there are Cond2 type\" ,  Cond2type ,  \"in \" ,  Cond2num ,  \"samples\" ) )   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) )   timeEstimated -   format (     ncol (  TOC ) *   nrow (  TOC ) /  elementsRatio , digits =  2 )   message (   messageEstimation -   paste (  \"I Need about \" ,  timeEstimated ,  \"seconds for this DEA. [Processing 30k elements /s]  \" ) ) # Reading in the data and creating a DGEList object    colnames (  TOC ) -   paste0 (  's' ,   1 :   ncol (  TOC ) ) #DGE #TumorSample)))  if (   method ==  \"exactTest\" )  {   DGE -   edgeR :: DGEList (  TOC , group =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) ) # Analysis using common dispersion   disp -   edgeR :: estimateCommonDisp (  DGE ) # Estimating the common dispersion #tested   tested -   edgeR :: exactTest (  disp , pair =   c (  Cond1type ,  Cond2type ) ) # Testing # Results visualization   logFC_table -   tested $ table   tableDEA -    edgeR :: topTags (  tested , n =   nrow (   tested $ table ) ) $ table   tableDEA -   tableDEA [    tableDEA $ FDR =  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) =  logFC.cut , ] }  if (   method ==  \"glmLRT\" )  {   tumorType -   factor ( x =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) , levels =   c (  Cond1type ,  Cond2type ) )   design -   model.matrix (  ~  tumorType )   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , coef =  2 )   tableDEA -   cbind (   aGlmLRT $ table , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tableDEA -   tableDEA [    tableDEA $ FDR undefined  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) undefined  logFC.cut , ] }  if (   all (   grepl (  \"ENSG\" ,   rownames (  tableDEA ) ) ) )   tableDEA -   cbind (  tableDEA ,    map.ensg ( genes =   rownames (  tableDEA ) ) [ ,   2 :  3 ] )   message (  \"----------------------- END DEA -------------------------------\" )   return (  tableDEA ) } ",
    "filename": "analyze.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_DEA",
    "representation": "TCGAanalyze_DEA",
    "parameters": "function ( mat1 , mat2 , Cond1type , Cond2type , pipeline = \"edgeR\" , method = \"exactTest\" , fdr.cut = 1 , logFC.cut = 0 , elementsRatio = 30000 , batch.factors = NULL , ClinicalDF = data.frame ( ) , paired = FALSE , log.trans = FALSE , voom = FALSE , trend = FALSE , MAT = data.frame ( ) , contrast.formula = \"\" , Condtypes = c ( ) )",
    "body": "{   table.code -   c (  \"TP\" ,  \"TR\" ,  \"TB\" ,  \"TRBM\" ,  \"TAP\" ,  \"TM\" ,  \"TAM\" ,  \"THOC\" ,  \"TBM\" ,  \"NB\" ,  \"NT\" ,  \"NBC\" ,  \"NEBV\" ,  \"NBM\" ,  \"CELLC\" ,  \"TRB\" ,  \"CELL\" ,  \"XP\" ,  \"XCL\" )    names (  table.code ) -   c (  '01' ,  '02' ,  '03' ,  '04' ,  '05' ,  '06' ,  '07' ,  '08' ,  '09' ,  '10' ,  '11' ,  '12' ,  '13' ,  '14' ,  '20' ,  '40' ,  '50' ,  '60' ,  '61' )  if (    nrow (  MAT ) ==  0 )  {   TOC -   cbind (  mat1 ,  mat2 )   Cond1num -   ncol (  mat1 )   Cond2num -   ncol (  mat2 ) #print(map.ensg(genes = rownames(TOC))[,2:3]) } else  {   TOC -  MAT }   my_IDs -   get_IDs (  TOC )  if (   paired ==  TRUE )  {   matched.query -   TCGAquery_MatchedCoupledSampleTypes (   my_IDs $ barcode ,   table.code [   unique (   my_IDs $ sample ) ] )   my_IDs -   subset (  my_IDs ,   barcode ==  matched.query )   TOC -   TOC [ ,  (    names (  TOC ) %in%  matched.query ) ] } ###Extract year data from clinical info:  if (    nrow (  ClinicalDF ) undefined  0 )  {     names (  ClinicalDF ) [    names (  ClinicalDF ) ==  \"bcr_patient_barcode\" ] -  \"patient\"    ClinicalDF $ age_at_diag_year -   floor (    clinical $ age_at_diagnosis /  365 )    ClinicalDF $ diag_year -    ClinicalDF $ age_at_diag_year +   clinical $ year_of_birth   diag_yearDF -   ClinicalDF [ ,   c (  \"patient\" ,  \"diag_year\" ) ]   my_IDs -   merge (  my_IDs ,  ClinicalDF , by =  \"patient\" )   Year -   as.factor (   my_IDs $ diag_year ) } #####   Plate -   factor (   my_IDs $ plate )   Condition -   factor (   my_IDs $ condition )   TSS -   factor (   my_IDs $ tss )   Portion -   factor (   my_IDs $ portion )   Center -   factor (   my_IDs $ center )   Patients -   factor (   my_IDs $ patient ) ####ADD PATIENT AS OPTION   options -   c (  \"Plate\" ,  \"TSS\" ,  \"Year\" ,  \"Portion\" ,  \"Center\" ,  \"Patients\" )  if (    length (  batch.factors ) ==  0 )  {   message (  \"Batch correction skipped since no factors provided\" ) } else  for  ( o in  batch.factors )  {  if (    o %in%  options ==  FALSE )   stop (   paste0 (  o ,  \" is not a valid batch correction factor\" ) )  if (    o ==  \"Year\" undefined    nrow (  ClinicalDF ) ==  0 )   stop (  \"batch correction using diagnosis year needs clinical info. Provide Clinical Data in arguments\" ) } ###Additive Formula#######   additiveformula -   paste (  batch.factors , collapse =  \"+\" ) ###########################   message (  \"----------------------- DEA -------------------------------\" )  if (    nrow (  MAT ) ==  0 )  {   message (   message1 -   paste (  \"there are Cond1 type\" ,  Cond1type ,  \"in \" ,  Cond1num ,  \"samples\" ) )   message (   message2 -   paste (  \"there are Cond2 type\" ,  Cond2type ,  \"in \" ,  Cond2num ,  \"samples\" ) )   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) } else  {   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) }   timeEstimated -   format (     ncol (  TOC ) *   nrow (  TOC ) /  elementsRatio , digits =  2 )   message (   messageEstimation -   paste (  \"I Need about \" ,  timeEstimated ,  \"seconds for this DEA. [Processing 30k elements /s]  \" ) ) # Reading in the data and creating a DGEList object    colnames (  TOC ) -   paste0 (  's' ,   1 :   ncol (  TOC ) ) #DGE #TumorSample)))  if (    length (  Condtypes ) undefined  0 )  {   tumorType -   factor ( x =  Condtypes , levels =   unique (  Condtypes ) ) } else  {   tumorType -   factor ( x =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) , levels =   c (  Cond1type ,  Cond2type ) ) } # DGE.mat  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) }  if (   pipeline ==  \"edgeR\" )  {  if (   method ==  \"exactTest\" )  {   DGE -   edgeR :: DGEList (  TOC , group =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) ) # Analysis using common dispersion   disp -   edgeR :: estimateCommonDisp (  DGE ) # Estimating the common dispersion #tested   tested -   edgeR :: exactTest (  disp , pair =   c (  Cond1type ,  Cond2type ) ) # Testing # Results visualization   logFC_table -   tested $ table   tableDEA -    edgeR :: topTags (  tested , n =   nrow (   tested $ table ) ) $ table   tableDEA -   tableDEA [    tableDEA $ FDR =  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) =  logFC.cut , ] } else  if (   method ==  \"glmLRT\" )  {  if (    length (   unique (  tumorType ) ) ==  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , coef =  2 )   tableDEA -   cbind (   aGlmLRT $ table , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tableDEA -   tableDEA [    tableDEA $ FDR undefined  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) undefined  logFC.cut , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (  tableDEA ) ) ) )   tableDEA -   cbind (  tableDEA ,    map.ensg ( genes =   rownames (  tableDEA ) ) [ ,   2 :  3 ] ) } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   print (  cont.matrix )   tableDEA -   list ( ) #[2:length(colnames(cont.matrix))]  for  ( mycoef in   colnames (  cont.matrix ) )  {   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , contrast =   cont.matrix [ ,  mycoef ] )   print (  \"---toptags---\" )   print (   topTags (  aGlmLRT , adjust.method =  \"fdr\" , sort.by =  \"PValue\" ) )   tt -   aGlmLRT $ table   tt -   cbind (  tt , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tt -   tt [  (     tt $ FDR undefined  fdr.cut undefined    abs (   as.numeric (   tt $ logFC ) ) undefined  logFC.cut ) , ] #tt    tableDEA [[   as.character (  mycoef ) ] ] -  tt #print(rownames(tableDEA[[as.character(mycoef)]]))  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } #design } else   stop (   paste0 (  method ,  \" is not a valid DEA method option. Choose 'exactTest' or 'glmLRT' \" ) ) } else  if (   pipeline ==  \"limma\" )  {  if (   voom ==  TRUE )  {   message (  \"Voom Transformation...\" )   logCPM -   limma :: voom (  TOC ,  design ) }  if (    length (   unique (  tumorType ) ) ==  2 )  { #DGE #c(Cond1num,Cond2num))) ###logcpm transformation for limma-trend method using edgeR cpm method  if (   log.trans ==  TRUE )   logCPM -   edgeR :: cpm (  TOC , log =  TRUE , prior.count =  3 ) else   logCPM -  TOC     colnames (  design ) [   1 :  2 ] -   c (  Cond1type ,  Cond2type )   contr -   paste0 (  Cond2type ,  \"-\" ,  Cond1type )   cont.matrix -   limma :: makeContrasts ( contrasts =  contr , levels =  design )   fit -   limma :: lmFit (  logCPM ,  design )   fit -   contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE )  {   fit -   limma :: eBayes (  fit , trend =  TRUE ) } else  {   fit -   limma :: eBayes (  fit , trend =  FALSE ) }   tableDEA -   limma :: toptable (  fit , coef =  1 , adjust.method =  'fdr' , number =   nrow (  TOC ) )   limma :: volcanoplot (  fit , highlight =  10 )   index -   which (    tableDEA [ ,  4 ] undefined  fdr.cut )   tableDEA -   tableDEA [  index , ]   neg_logFC.cut -   -  1 *  logFC.cut   index -   which (    abs (   as.numeric (   tableDEA $ logFC ) ) undefined  logFC.cut )   tableDEA -   tableDEA [  index , ] #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   DGE -   edgeR :: DGEList (  TOC , group =  tumorType ) ###logcpm transformation for limma-trend method using edgeR  if (   log.trans ==  TRUE )   logCPM -   edgeR :: cpm (  DGE , log =  TRUE , prior.count =  3 ) else   logCPM -  DGE #colnames(design)[1:2]     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   fit -   limma :: lmFit (   logCPM $ counts ,  design )   fit -   limma :: contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE ) ##limma-trend option   fit -   limma :: eBayes (  fit , trend =  TRUE ) else   fit -   limma :: eBayes (  fit , trend =  FALSE )   tableDEA -   list ( )  for  ( mycoef in   colnames (  cont.matrix ) )  {    tableDEA [[   as.character (  mycoef ) ] ] -   limma :: toptable (  fit , coef =  mycoef , adjust.method =  \"fdr\" , number =   nrow (  MAT ) )   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   tempDEA -   tableDEA [[   as.character (  mycoef ) ] ]   index.up -   which (     tempDEA $ adj.P.Val undefined  fdr.cut undefined    abs (   as.numeric (   tempDEA $ logFC ) ) undefined  logFC.cut )    tableDEA [[   as.character (  mycoef ) ] ] -   tempDEA [  index.up , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) #i } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } } else   stop (   paste0 (  pipeline ,  \" is not a valid pipeline option. Choose 'edgeR' or 'limma'\" ) ) #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA   message (  \"----------------------- END DEA -------------------------------\" )   return (  tableDEA ) } ",
    "filename": "analyze.txt"
  }
}

1.
{
  "old_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , met.platform , genome , names = FALSE , names.fill = TRUE , circle = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{  if (   missing (  genome ) )   stop (  \"Please set genome (hg19 or hg38)\" )  if (   missing (  met.platform ) )   stop (  \"Please set met.platform (EPIC, 450K or 27K)\" )   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Transform factor coluns to characters   fctr.cols -   sapply (  exp ,  is.factor )    exp [ ,  fctr.cols ] -   sapply (   exp [ ,  fctr.cols ] ,  as.character ) # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"ENSG\" ,   exp [  1 , ] )  if (    length (  idx ) undefined  0 )  {     colnames (  exp ) [  idx ] -  \"ensembl_gene_id\" } else  { # it is in the row names ?  if (   grepl (  \"ENSG\" ,    rownames (  exp ) [  1 ] ) )  {    exp $ ensembl_gene_id -   rownames (  exp ) } else  { # We will consider our rownames has the gene symbol   gene.info -   get.GRCh.bioMart (  genome )  if (   any (   sapply (    rownames (  exp ) [   1 :  10 ] ,  function ( y )   any (   grepl (  y ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] ) ) ) ) )  {   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )   exp -   exp [  !   is.na (  idx ) , ]   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )    exp $ ensembl_gene_id -   gene.info [  idx ,  \"ensembl_gene_id\" ] } } }  if (  !   \"probeID\" %in%   colnames (  met ) )    met $ probeID -   met $ Composite.Element.REF # Check if gene symbol columns exists  if (  !   \"ensembl_gene_id\" %in%   colnames (  exp ) )  {   stop (  \"Column ensembl_gene_id was not found\" ) } # Correlate gene expression with DNA methylation levels # Step 1: identify nearest TSS for each probe # Step 2: create a table with probe, gene, transcript, distance.TSS and merge with #         the met (by probe name) and gene expression (by gene name) results   message (  \"o Fetching auxiliary information\" )   message (  \"oo Fetching probes genomic information\" )   met.info -   getMetPlatInfo ( genome =  genome , platform =  met.platform )    values (  met.info ) -  NULL   message (  \"oo Fetching TSS information\" )   tss -   getTSS ( genome =  genome )   message (  \"o Mapping probes to nearest TSS\" )   dist -   distanceToNearest (  tss ,  met.info )   g -   suppressWarnings (   as.data.frame (   tss [   queryHits (  dist ) ] ) )    g $ start_position -  NULL    g $ end_position -  NULL     colnames (  g ) [   1 :  5 ] -   paste0 (  \"gene_\" ,    colnames (  g ) [   1 :  5 ] )   m -   suppressWarnings (   as.data.frame (   met.info [   subjectHits (  dist ) ] , row.names =  NULL ) )    colnames (  m ) -   paste0 (  \"probe_\" ,   colnames (  m ) )    m $ probeID -   names (   met.info [   subjectHits (  dist ) ] )   nearest -   cbind (  m ,  g ) # END mapping nearest probe to nearest gene   message (  \"o Mapping results information\" )   volcano -   plyr :: join (  nearest ,  exp , by =  \"ensembl_gene_id\" )   volcano -   merge (  volcano ,  met , by =  \"probeID\" )    volcano $ ID -   paste (   volcano $ Gene_symbol ,   volcano $ ensembl_transcript_id ,   volcano $ probeID , sep =  \".\" )   volcano -   volcano [  !   is.na (   volcano $ FDR ) , ] # Some genes have no values # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ] # Preparing DNA methylation   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hypermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr )   volcano -   suppressWarnings (   tibble :: as.tibble (  volcano ) ) # Group 2:up regulated and hypomethylated   a -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 4: hypomethylated   c -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 5: hypermethylated   d -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 6: upregulated   e -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 7: downregulated   f -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 8: upregulated and hypermethylated   g -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated ,  \"Down regulated ,  \"hypo methylated\" ,  \"hyper methylated\" ,  \"Up regulated\" ,  \"Down regulated\" ,  \"Up regulated ,  \"Down regulated )   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {    volcano [    volcano $ ID %in%  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [    volcano $ ID %in%  idx ,  \"starburst.status\" ] -   state [  i ] } }   s -   list (  a ,  b ,  g ,  h )   significant -  NULL  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {   significant -   rbind (  significant ,   volcano [    volcano $ ID %in%  idx , ] ) } }   message (  \"o Plotting figure\" )   volcano.aux -  volcano # we need an auxiliry data if dats is returned ## starburst plot   p -    ggplot ( data =  volcano.aux , environment =  .e ,   aes ( x =   volcano.aux $ meFDR2 , y =   volcano.aux $ geFDR2 , colour =   volcano.aux $ threshold.starburst ) ) +   geom_point ( ) #p #    labels = c(\"Candidate Biologically Significant\"), #    name = \"Biological importance\")  if (   !   is.null (  significant ) undefined  circle )  {   p -   p +   geom_point ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 ) , color =  \"black\" , shape =  1 , size =  8 , show.legend =  FALSE ) }  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"oo Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'white' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) ) #p #                     aes(x = meFDR2, #                         y = geFDR2), shape=1, size = 10,show_guide = FALSE) #    p #        labels = c(\"Candidate Biologically Significant\"), #        name = \"Biological importance\")  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi ) #statuscol #volcano #                                     \"probeID\",statuscol, #                                     \"starburst.status\") #)    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   dplyr :: filter (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }   message (  \"o Saving results\" )   message (  \"oo Saving significant results as: starburst_results.csv\" )   message (  \"oo It contains pair with changes both in the expression level of the nearest gene and  in the DNA methylation level\" )   suppressWarnings (   write_csv ( x =  volcano , path =  \"starburst_results.csv\" ) )  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_starburst",
    "representation": "TCGAvisualize_starburst",
    "parameters": "function ( met , exp , group1 = NULL , group2 = NULL , exp.p.cut = 0.01 , met.p.cut = 0.01 , diffmean.cut = 0 , logFC.cut = 0 , met.platform , genome , names = FALSE , names.fill = TRUE , filename = \"starburst.pdf\" , return.plot = FALSE , ylab = expression ( atop ( \"Gene Expression\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , xlab = expression ( atop ( \"DNA Methylation\" , paste ( Log [ 10 ] , \" (FDR corrected P values)\" ) ) ) , title = \"Starburst Plot\" , legend = \"DNA Methylation/Expression Relation\" , color = NULL , label = c ( \"Not Significant\" , \"Up regulated    Hypo methylated\" , \"Down regulated    Hypo methylated\" , \"hypo methylated\" , \"hyper methylated\" , \"Up regulated\" , \"Down regulated\" , \"Up regulated    Hyper methylated\" , \"Down regulated    Hyper methylated\" ) , xlim = NULL , ylim = NULL , height = 10 , width = 20 , dpi = 600 )",
    "body": "{  if (   missing (  genome ) )   stop (  \"Please set genome (hg19 or hg38)\" )  if (   missing (  met.platform ) )   stop (  \"Please set met.platform (EPIC, 450K or 27K)\" )   .e -   environment ( )   group1.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group1 )   group2.col -   gsub (  \"[[:punct:]]| \" ,  \".\" ,  group2 )  if (   title ==  \"Starburst Plot\" )  {  if (    diffmean.cut !=  0 undefined   logFC.cut ==  0 )  {   title -   bquote (   atop (  \"Starburst Plot\" ,   scriptstyle (  (   list (   Delta ~    bar (  beta ) =   . (  diffmean.cut ) ,    FDR [  expression ] =   . (  exp.p.cut ) ,    FDR [  DNAmethylation ] =   . (  met.p.cut ) ) ) ) ) ) } else  if (    logFC.cut !=  0 undefined   diffmean.cut ==  0 )  {   title -   bquote (   atop (  \"Starburst Plot\" ,   scriptstyle (  (   list (    group (  \"|\" ,  logFC ,  \"|\" ) =   . (  logFC.cut ) ,    FDR [  expression ] =   . (  exp.p.cut ) ,    FDR [  DNAmethylation ] =   . (  met.p.cut ) ) ) ) ) ) } else  if (    logFC.cut !=  0 undefined   diffmean.cut !=  0 )  {   title -   bquote (   atop (  \"Starburst Plot\" ,   scriptstyle (  (   list (  Delta ,    bar (  beta ) =   . (  diffmean.cut ) ,    group (  \"|\" ,  logFC ,  \"|\" ) =   . (  logFC.cut ) ,    FDR [  expression ] =   . (  exp.p.cut ) ,    FDR [  DNAmethylation ] =   . (  met.p.cut ) ) ) ) ) ) } }  if (   is.null (  color ) )   color -   c (  \"#000000\" ,  \"#E69F00\" ,  \"#56B4E9\" ,  \"#009E73\" ,  \"red\" ,  \"#0072B2\" ,  \"#D55E00\" ,  \"#CC79A7\" ,  \"purple\" )    names (  color ) -   as.character (   1 :  9 )    names (  label ) -   as.character (   1 :  9 )   names.color -  color    names (  names.color ) -  label  if (    is.null (  group1 ) ||   is.null (  group2 ) )  {   message (  \"Please, set the group1 and group2 parameters\" )   return (  NULL ) }  if (    class (  met ) ==   class (   as (   SummarizedExperiment ( ) ,  \"RangedSummarizedExperiment\" ) ) )  {   met -   values (  met ) } # Preparing methylation   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group1 ,  group2 , sep =  \".\" ) )  if (  !  (   pcol %in%   colnames (  met ) ) )  {   pcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"p.value.adj\" ,  group2 ,  group1 , sep =  \".\" ) ) }  if (  !  (   pcol %in%   colnames (  met ) ) )  {   stop (  \"Error! p-values adjusted not found. Please, run TCGAanalyze_DMR\" ) } # Transform factor coluns to characters   fctr.cols -   sapply (  exp ,  is.factor )    exp [ ,  fctr.cols ] -   sapply (   exp [ ,  fctr.cols ] ,  as.character ) # Methylation matrix and expression matrix should have the same name column for merge   idx -   grep (  \"ENSG\" ,   exp [  1 , ] )  if (    length (  idx ) undefined  0 )  {     colnames (  exp ) [  idx ] -  \"ensembl_gene_id\" } else  { # it is in the row names ?  if (   grepl (  \"ENSG\" ,    rownames (  exp ) [  1 ] ) )  {    exp $ ensembl_gene_id -   rownames (  exp ) } else  { # We will consider our rownames has the gene symbol   gene.info -   get.GRCh.bioMart (  genome )  if (   any (   sapply (    rownames (  exp ) [   1 :  10 ] ,  function ( y )   any (   grepl (  y ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] ) ) ) ) )  {   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )   exp -   exp [  !   is.na (  idx ) , ]   idx -   match (   rownames (  exp ) ,   gene.info [ ,   grep (  \"external_gene_\" ,   colnames (  gene.info ) ) ] )    exp $ ensembl_gene_id -   gene.info [  idx ,  \"ensembl_gene_id\" ] } } }  if (  !   \"probeID\" %in%   colnames (  met ) )    met $ probeID -   met $ Composite.Element.REF # Check if gene symbol columns exists  if (  !   \"ensembl_gene_id\" %in%   colnames (  exp ) )  {   stop (  \"Column ensembl_gene_id was not found\" ) } # Correlate gene expression with DNA methylation levels # Step 1: identify nearest TSS for each probe # Step 2: create a table with probe, gene, transcript, distance.TSS and merge with #         the met (by probe name) and gene expression (by gene name) results   message (  \"o Fetching auxiliary information\" )   message (  \"oo Fetching probes genomic information\" )   met.info -   getMetPlatInfo ( genome =  genome , platform =  met.platform )    values (  met.info ) -  NULL   message (  \"oo Fetching TSS information\" )   tss -   getTSS ( genome =  genome )   tss -   promoters (  tss , upstream =  0 , downstream =  0 )   message (  \"o Mapping probes to nearest TSS\" )   dist -   distanceToNearest (  tss ,  met.info )   g -   suppressWarnings (   as.data.frame (   tss [   queryHits (  dist ) ] ) )    g $ start_position -  NULL    g $ end_position -  NULL     colnames (  g ) [   1 :  5 ] -   paste0 (  \"gene_\" ,    colnames (  g ) [   1 :  5 ] )   m -   suppressWarnings (   as.data.frame (   met.info [   subjectHits (  dist ) ] , row.names =  NULL ) )    colnames (  m ) -   paste0 (  \"probe_\" ,   colnames (  m ) )    m $ probeID -   names (   met.info [   subjectHits (  dist ) ] )   nearest -   cbind (  m ,  g )    nearest $ distance_TSS -    values (  dist ) $ distance # Keep only one entry    nearest $ id -   paste0 (   nearest $ probeID ,   nearest $ ensembl_gene_id )   nearest -   nearest [   order (   nearest $ id ,  -   abs (   nearest $ distance_TSS ) ) , ]   nearest -   nearest [  !   duplicated (   nearest $ id ) , ]    nearest $ id -  NULL   nearest -   nearest [ ,   c (  \"distance_TSS\" ,  \"probeID\" ,  \"ensembl_gene_id\" ) ] # END mapping nearest probe to nearest gene   message (  \"o Mapping results information\" )   volcano -   plyr :: join (  nearest ,  exp , by =  \"ensembl_gene_id\" )   volcano -   merge (  volcano ,  met , by =  \"probeID\" )    volcano $ ID -   paste (   volcano $ ensembl_gene_id ,   volcano $ probeID , sep =  \".\" )   volcano -   volcano [  !   is.na (   volcano $ FDR ) , ] # Some genes have no values # Preparing gene expression    volcano $ geFDR -   log10 (   volcano $ FDR )    volcano $ geFDR2 -   volcano $ geFDR    volcano [    volcano $ logFC undefined  0 ,  \"geFDR2\" ] -   -  1 *   volcano [    volcano $ logFC undefined  0 ,  \"geFDR\" ] # Preparing DNA methylation   diffcol -   gsub (  \"[[:punct:]]| \" ,  \".\" ,   paste (  \"diffmean\" ,  group1 ,  group2 , sep =  \".\" ) )    volcano $ meFDR -   log10 (   volcano [ ,  pcol ] )    volcano $ meFDR2 -   volcano $ meFDR   idx -    volcano [ ,  diffcol ] undefined  0    idx [   is.na (  idx ) ] -  FALSE # handling NAs    volcano [  idx ,  \"meFDR2\" ] -   -  1 *   volcano [  idx ,  \"meFDR\" ]    label [   2 :  9 ] -   paste (   label [   2 :  9 ] ,  \"in\" ,  group2 ) # subseting by regulation (geFDR) and methylation level # (meFDR) down regulated up regulated lowerthr # |||||||||||||||| upperthr hypomethylated hypermethylated   met.lowerthr -   log10 (  met.p.cut )   met.upperthr -  (  -  met.lowerthr )   exp.lowerthr -   log10 (  exp.p.cut )   exp.upperthr -  (  -  exp.lowerthr )   volcano -   suppressWarnings (   tibble :: as.tibble (  volcano ) ) # Group 2:up regulated and hypomethylated   a -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 3: down regulated and hypomethylated   b -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    volcano $ logFC undefined  logFC.cut ) # Group 4: hypomethylated   c -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 5: hypermethylated   d -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) # Group 6: upregulated   e -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    volcano $ logFC undefined  logFC.cut ) # Group 7: downregulated   f -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    volcano $ meFDR2 undefined  met.lowerthr undefined    abs (   volcano $ logFC ) undefined  logFC.cut ) # Group 8: upregulated and hypermethylated   g -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.upperthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    volcano $ logFC undefined  logFC.cut ) # Group 9: downregulated and hypermethylated   h -   dplyr :: filter (  volcano ,       volcano $ geFDR2 undefined  exp.lowerthr undefined    volcano $ meFDR2 undefined  met.upperthr undefined    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut undefined    volcano $ logFC undefined  logFC.cut )   groups -   as.character (   seq (  2 ,  9 ) ) # return methylation    volcano $ starburst.status -  \"Not Significant\"    volcano $ shape -  \"1\"    volcano $ threshold.starburst -  \"1\"    volcano $ threshold.size -  \"1\"   state -   c (  \"Up regulated , # a  \"Down regulated , # b  \"hypo methylated\" , # c  \"hyper methylated\" , # d  \"Up regulated\" , # e  \"Down regulated\" , # f  \"Up regulated , # g  \"Down regulated ) # h   s -   list (  a ,  b ,  c ,  d ,  e ,  f ,  g ,  h )  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {    volcano [    volcano $ ID %in%  idx ,  \"threshold.starburst\" ] -   groups [  i ]    volcano [    volcano $ ID %in%  idx ,  \"starburst.status\" ] -   state [  i ] } }   s -   list (  a ,  b ,  g ,  h )   significant -  NULL  for  ( i in   seq_along (  s ) )  {   idx -    s [[  i ] ] $ ID  if (    length (  idx ) undefined  0 )  {   significant -   rbind (  significant ,   volcano [    volcano $ ID %in%  idx , ] ) } }   message (  \"o Plotting figure\" )   volcano.aux -  volcano # we need an auxiliry data if dats is returned ## starburst plot   p -    ggplot ( data =  volcano.aux , environment =  .e ,   aes ( x =   volcano.aux $ meFDR2 , y =   volcano.aux $ geFDR2 , colour =   volcano.aux $ threshold.starburst ) ) +   geom_point ( )  if (    names ==  TRUE undefined  !   is.null (  significant ) )  {   message (  \"oo Adding names to genes\" )  if (  names.fill )  {   p -    p +   geom_label_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   as.factor (   significant $ starburst.status ) ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , box.padding =   unit (  0.35 ,  \"lines\" ) , point.padding =   unit (  0.3 ,  \"lines\" ) ) +   scale_fill_manual ( values =  names.color ) } else  {   p -   p +   geom_text_repel ( data =  significant ,   aes ( x =   significant $ meFDR2 , y =   significant $ geFDR2 , label =    map.ensg (  genome ,   significant $ ensembl_gene_id ) $ external_gene_name , fill =   significant $ starburst.status ) , size =  4 , show.legend =  FALSE , fontface =  'bold' , color =  'black' , point.padding =   unit (  0.3 ,  \"lines\" ) , box.padding =   unit (  0.5 ,  'lines' ) ) } }  if (  !   is.null (  xlim ) )  {   p -   p +   xlim (  xlim ) }  if (  !   is.null (  ylim ) )  {   p -   p +   ylim (  ylim ) }   p -      p +   ggtitle (  title ) +   ylab (  ylab ) +   xlab (  xlab ) +   guides ( size =  FALSE )   p -    p +   scale_color_manual ( values =  color , labels =  label , name =  legend ) +   guides ( col =   guide_legend ( nrow =  3 ) )   p -        p +   geom_hline (   aes ( yintercept =  exp.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_hline (   aes ( yintercept =  exp.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.lowerthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   geom_vline (   aes ( xintercept =  met.upperthr ) , colour =  \"black\" , linetype =  \"dashed\" ) +   theme_bw ( ) +   theme ( panel.border =   element_blank ( ) , panel.grid.major =   element_blank ( ) , panel.grid.minor =   element_blank ( ) , axis.line.x =   element_line ( colour =  \"black\" ) , axis.line.y =   element_line ( colour =  \"black\" ) , legend.position =  \"top\" , legend.key =   element_rect ( colour =  'white' ) , plot.title =   element_text ( face =  \"bold\" , size =  16 , hjust =  0.5 ) , legend.text =   element_text ( size =  14 ) , legend.title =   element_text ( size =  14 ) , axis.text =   element_text ( size =  14 ) , axis.title.x =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.x =   element_text ( vjust =  0.5 , size =  14 ) , axis.title.y =   element_text ( face =  \"bold\" , size =  14 ) , axis.text.y =   element_text ( size =  14 ) )  if (  !  return.plot )   ggsave ( filename =  filename , width =  width , height =  height , dpi =  dpi )    volcano $ shape -  NULL    volcano $ threshold.starburst -  NULL    volcano $ threshold.size -  NULL   volcano -   dplyr :: filter (  volcano ,     volcano $ geFDR =  exp.lowerthr undefined    volcano $ meFDR =  met.lowerthr )  if (   diffmean.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano [ ,  diffcol ] ) undefined  diffmean.cut ) }  if (   logFC.cut !=  0 )  {   volcano -   dplyr :: filter (  volcano ,    abs (   volcano $ logFC ) =  logFC.cut ) }   message (  \"o Saving results\" )   message (  \"oo Saving significant results as: starburst_results.csv\" )   message (  \"oo It contains pair with changes both in the expression level of the nearest gene and  in the DNA methylation level\" )   suppressWarnings (   write_csv ( x =  volcano , path =  \"starburst_results.csv\" ) )  if (  return.plot )  {   return (   list ( plot =  p , starburst =  volcano ) ) }   return (  volcano ) } ",
    "filename": "methylation.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_6 tcgabiolinks_release_3_7

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_6 tcgabiolinks_release_3_7",
    "desc_release_old": "2.6.12",
    "desc_release_new": "2.8.4",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

get_IDs


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "TCGAanalyze_DEA",
    "representation": "TCGAanalyze_DEA",
    "parameters": "function ( mat1 , mat2 , Cond1type , Cond2type , pipeline = \"edgeR\" , method = \"exactTest\" , fdr.cut = 1 , logFC.cut = 0 , elementsRatio = 30000 , batch.factors = NULL , ClinicalDF = data.frame ( ) , paired = FALSE , log.trans = FALSE , voom = FALSE , trend = FALSE , MAT = data.frame ( ) , contrast.formula = \"\" , Condtypes = c ( ) )",
    "body": "{   table.code -   c (  \"TP\" ,  \"TR\" ,  \"TB\" ,  \"TRBM\" ,  \"TAP\" ,  \"TM\" ,  \"TAM\" ,  \"THOC\" ,  \"TBM\" ,  \"NB\" ,  \"NT\" ,  \"NBC\" ,  \"NEBV\" ,  \"NBM\" ,  \"CELLC\" ,  \"TRB\" ,  \"CELL\" ,  \"XP\" ,  \"XCL\" )    names (  table.code ) -   c (  '01' ,  '02' ,  '03' ,  '04' ,  '05' ,  '06' ,  '07' ,  '08' ,  '09' ,  '10' ,  '11' ,  '12' ,  '13' ,  '14' ,  '20' ,  '40' ,  '50' ,  '60' ,  '61' )  if (    nrow (  MAT ) ==  0 )  {   TOC -   cbind (  mat1 ,  mat2 )   Cond1num -   ncol (  mat1 )   Cond2num -   ncol (  mat2 ) #print(map.ensg(genes = rownames(TOC))[,2:3]) } else  {   TOC -  MAT }   my_IDs -   get_IDs (  TOC )  if (   paired ==  TRUE )  {   matched.query -   TCGAquery_MatchedCoupledSampleTypes (   my_IDs $ barcode ,   table.code [   unique (   my_IDs $ sample ) ] )   my_IDs -   subset (  my_IDs ,   barcode ==  matched.query )   TOC -   TOC [ ,  (    names (  TOC ) %in%  matched.query ) ] } ###Extract year data from clinical info:  if (    nrow (  ClinicalDF ) undefined  0 )  {     names (  ClinicalDF ) [    names (  ClinicalDF ) ==  \"bcr_patient_barcode\" ] -  \"patient\"    ClinicalDF $ age_at_diag_year -   floor (    clinical $ age_at_diagnosis /  365 )    ClinicalDF $ diag_year -    ClinicalDF $ age_at_diag_year +   clinical $ year_of_birth   diag_yearDF -   ClinicalDF [ ,   c (  \"patient\" ,  \"diag_year\" ) ]   my_IDs -   merge (  my_IDs ,  ClinicalDF , by =  \"patient\" )   Year -   as.factor (   my_IDs $ diag_year ) } #####   Plate -   factor (   my_IDs $ plate )   Condition -   factor (   my_IDs $ condition )   TSS -   factor (   my_IDs $ tss )   Portion -   factor (   my_IDs $ portion )   Center -   factor (   my_IDs $ center )   Patients -   factor (   my_IDs $ patient ) ####ADD PATIENT AS OPTION   options -   c (  \"Plate\" ,  \"TSS\" ,  \"Year\" ,  \"Portion\" ,  \"Center\" ,  \"Patients\" )  if (    length (  batch.factors ) ==  0 )  {   message (  \"Batch correction skipped since no factors provided\" ) } else  for  ( o in  batch.factors )  {  if (    o %in%  options ==  FALSE )   stop (   paste0 (  o ,  \" is not a valid batch correction factor\" ) )  if (    o ==  \"Year\" undefined    nrow (  ClinicalDF ) ==  0 )   stop (  \"batch correction using diagnosis year needs clinical info. Provide Clinical Data in arguments\" ) } ###Additive Formula#######   additiveformula -   paste (  batch.factors , collapse =  \"+\" ) ###########################   message (  \"----------------------- DEA -------------------------------\" )  if (    nrow (  MAT ) ==  0 )  {   message (   message1 -   paste (  \"there are Cond1 type\" ,  Cond1type ,  \"in \" ,  Cond1num ,  \"samples\" ) )   message (   message2 -   paste (  \"there are Cond2 type\" ,  Cond2type ,  \"in \" ,  Cond2num ,  \"samples\" ) )   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) } else  {   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) }   timeEstimated -   format (     ncol (  TOC ) *   nrow (  TOC ) /  elementsRatio , digits =  2 )   message (   messageEstimation -   paste (  \"I Need about \" ,  timeEstimated ,  \"seconds for this DEA. [Processing 30k elements /s]  \" ) ) # Reading in the data and creating a DGEList object    colnames (  TOC ) -   paste0 (  's' ,   1 :   ncol (  TOC ) ) #DGE #TumorSample)))  if (    length (  Condtypes ) undefined  0 )  {   tumorType -   factor ( x =  Condtypes , levels =   unique (  Condtypes ) ) } else  {   tumorType -   factor ( x =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) , levels =   c (  Cond1type ,  Cond2type ) ) } # DGE.mat  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) }  if (   pipeline ==  \"edgeR\" )  {  if (   method ==  \"exactTest\" )  {   DGE -   edgeR :: DGEList (  TOC , group =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) ) # Analysis using common dispersion   disp -   edgeR :: estimateCommonDisp (  DGE ) # Estimating the common dispersion #tested   tested -   edgeR :: exactTest (  disp , pair =   c (  Cond1type ,  Cond2type ) ) # Testing # Results visualization   logFC_table -   tested $ table   tableDEA -    edgeR :: topTags (  tested , n =   nrow (   tested $ table ) ) $ table   tableDEA -   tableDEA [    tableDEA $ FDR =  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) =  logFC.cut , ] } else  if (   method ==  \"glmLRT\" )  {  if (    length (   unique (  tumorType ) ) ==  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , coef =  2 )   tableDEA -   cbind (   aGlmLRT $ table , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tableDEA -   tableDEA [    tableDEA $ FDR undefined  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) undefined  logFC.cut , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (  tableDEA ) ) ) )   tableDEA -   cbind (  tableDEA ,    map.ensg ( genes =   rownames (  tableDEA ) ) [ ,   2 :  3 ] ) } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   print (  cont.matrix )   tableDEA -   list ( ) #[2:length(colnames(cont.matrix))]  for  ( mycoef in   colnames (  cont.matrix ) )  {   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , contrast =   cont.matrix [ ,  mycoef ] )   print (  \"---toptags---\" )   print (   topTags (  aGlmLRT , adjust.method =  \"fdr\" , sort.by =  \"PValue\" ) )   tt -   aGlmLRT $ table   tt -   cbind (  tt , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tt -   tt [  (     tt $ FDR undefined  fdr.cut undefined    abs (   as.numeric (   tt $ logFC ) ) undefined  logFC.cut ) , ] #tt    tableDEA [[   as.character (  mycoef ) ] ] -  tt #print(rownames(tableDEA[[as.character(mycoef)]]))  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } #design } else   stop (   paste0 (  method ,  \" is not a valid DEA method option. Choose 'exactTest' or 'glmLRT' \" ) ) } else  if (   pipeline ==  \"limma\" )  {  if (   voom ==  TRUE )  {   message (  \"Voom Transformation...\" )   logCPM -   limma :: voom (  TOC ,  design ) }  if (    length (   unique (  tumorType ) ) ==  2 )  { #DGE #c(Cond1num,Cond2num))) ###logcpm transformation for limma-trend method using edgeR cpm method  if (   log.trans ==  TRUE )   logCPM -   edgeR :: cpm (  TOC , log =  TRUE , prior.count =  3 ) else   logCPM -  TOC     colnames (  design ) [   1 :  2 ] -   c (  Cond1type ,  Cond2type )   contr -   paste0 (  Cond2type ,  \"-\" ,  Cond1type )   cont.matrix -   limma :: makeContrasts ( contrasts =  contr , levels =  design )   fit -   limma :: lmFit (  logCPM ,  design )   fit -   contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE )  {   fit -   limma :: eBayes (  fit , trend =  TRUE ) } else  {   fit -   limma :: eBayes (  fit , trend =  FALSE ) }   tableDEA -   limma :: toptable (  fit , coef =  1 , adjust.method =  'fdr' , number =   nrow (  TOC ) )   limma :: volcanoplot (  fit , highlight =  10 )   index -   which (    tableDEA [ ,  4 ] undefined  fdr.cut )   tableDEA -   tableDEA [  index , ]   neg_logFC.cut -   -  1 *  logFC.cut   index -   which (    abs (   as.numeric (   tableDEA $ logFC ) ) undefined  logFC.cut )   tableDEA -   tableDEA [  index , ] #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   DGE -   edgeR :: DGEList (  TOC , group =  tumorType ) ###logcpm transformation for limma-trend method using edgeR  if (   log.trans ==  TRUE )   logCPM -   edgeR :: cpm (  DGE , log =  TRUE , prior.count =  3 ) else   logCPM -  DGE #colnames(design)[1:2]     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   fit -   limma :: lmFit (   logCPM $ counts ,  design )   fit -   limma :: contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE ) ##limma-trend option   fit -   limma :: eBayes (  fit , trend =  TRUE ) else   fit -   limma :: eBayes (  fit , trend =  FALSE )   tableDEA -   list ( )  for  ( mycoef in   colnames (  cont.matrix ) )  {    tableDEA [[   as.character (  mycoef ) ] ] -   limma :: toptable (  fit , coef =  mycoef , adjust.method =  \"fdr\" , number =   nrow (  MAT ) )   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   tempDEA -   tableDEA [[   as.character (  mycoef ) ] ]   index.up -   which (     tempDEA $ adj.P.Val undefined  fdr.cut undefined    abs (   as.numeric (   tempDEA $ logFC ) ) undefined  logFC.cut )    tableDEA [[   as.character (  mycoef ) ] ] -   tempDEA [  index.up , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) #i } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } } else   stop (   paste0 (  pipeline ,  \" is not a valid pipeline option. Choose 'edgeR' or 'limma'\" ) ) #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA   message (  \"----------------------- END DEA -------------------------------\" )   return (  tableDEA ) } ",
    "filename": "analyze.txt"
  },
  "new_function": {
    "name": "TCGAanalyze_DEA",
    "representation": "TCGAanalyze_DEA",
    "parameters": "function ( mat1 , mat2 , metadata = TRUE , Cond1type , Cond2type , pipeline = \"edgeR\" , method = \"exactTest\" , fdr.cut = 1 , logFC.cut = 0 , elementsRatio = 30000 , batch.factors = NULL , ClinicalDF = data.frame ( ) , paired = FALSE , log.trans = FALSE , voom = FALSE , trend = FALSE , MAT = data.frame ( ) , contrast.formula = \"\" , Condtypes = c ( ) )",
    "body": "{   table.code -   c (  \"TP\" ,  \"TR\" ,  \"TB\" ,  \"TRBM\" ,  \"TAP\" ,  \"TM\" ,  \"TAM\" ,  \"THOC\" ,  \"TBM\" ,  \"NB\" ,  \"NT\" ,  \"NBC\" ,  \"NEBV\" ,  \"NBM\" ,  \"CELLC\" ,  \"TRB\" ,  \"CELL\" ,  \"XP\" ,  \"XCL\" )    names (  table.code ) -   c (  '01' ,  '02' ,  '03' ,  '04' ,  '05' ,  '06' ,  '07' ,  '08' ,  '09' ,  '10' ,  '11' ,  '12' ,  '13' ,  '14' ,  '20' ,  '40' ,  '50' ,  '60' ,  '61' )  if (    nrow (  MAT ) ==  0 )  {   TOC -   cbind (  mat1 ,  mat2 )   Cond1num -   ncol (  mat1 )   Cond2num -   ncol (  mat2 ) #print(map.ensg(genes = rownames(TOC))[,2:3]) } else  {   TOC -  MAT }  if (   metadata ==  TRUE )  { #####   my_IDs -   get_IDs (  TOC )   Plate -   factor (   my_IDs $ plate )   Condition -   factor (   my_IDs $ condition )   TSS -   factor (   my_IDs $ tss )   Portion -   factor (   my_IDs $ portion )   Center -   factor (   my_IDs $ center )   Patients -   factor (   my_IDs $ patient ) }  if (   paired ==  TRUE )  {   matched.query -   TCGAquery_MatchedCoupledSampleTypes (   my_IDs $ barcode ,   table.code [   unique (   my_IDs $ sample ) ] )   my_IDs -   subset (  my_IDs ,   barcode ==  matched.query )   TOC -   TOC [ ,  (    names (  TOC ) %in%  matched.query ) ] } ###Extract year data from clinical info:  if (    nrow (  ClinicalDF ) undefined  0 )  {     names (  ClinicalDF ) [    names (  ClinicalDF ) ==  \"bcr_patient_barcode\" ] -  \"patient\"    ClinicalDF $ age_at_diag_year -   floor (    clinical $ age_at_diagnosis /  365 )    ClinicalDF $ diag_year -    ClinicalDF $ age_at_diag_year +   clinical $ year_of_birth   diag_yearDF -   ClinicalDF [ ,   c (  \"patient\" ,  \"diag_year\" ) ]   my_IDs -   merge (  my_IDs ,  ClinicalDF , by =  \"patient\" )   Year -   as.factor (   my_IDs $ diag_year ) } ####ADD PATIENT AS OPTION   options -   c (  \"Plate\" ,  \"TSS\" ,  \"Year\" ,  \"Portion\" ,  \"Center\" ,  \"Patients\" )  if (    length (  batch.factors ) ==  0 )  {   message (  \"Batch correction skipped since no factors provided\" ) } else  for  ( o in  batch.factors )  {  if (    o %in%  options ==  FALSE )   stop (   paste0 (  o ,  \" is not a valid batch correction factor\" ) )  if (    o ==  \"Year\" undefined    nrow (  ClinicalDF ) ==  0 )   stop (  \"batch correction using diagnosis year needs clinical info. Provide Clinical Data in arguments\" ) } ###Additive Formula#######   additiveformula -   paste (  batch.factors , collapse =  \"+\" ) ###########################   message (  \"----------------------- DEA -------------------------------\" )  if (    nrow (  MAT ) ==  0 )  {   message (   message1 -   paste (  \"there are Cond1 type\" ,  Cond1type ,  \"in \" ,  Cond1num ,  \"samples\" ) )   message (   message2 -   paste (  \"there are Cond2 type\" ,  Cond2type ,  \"in \" ,  Cond2num ,  \"samples\" ) )   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) } else  {   message (   message3 -   paste (  \"there are \" ,   nrow (  TOC ) ,  \"features as miRNA or genes \" ) ) }   timeEstimated -   format (     ncol (  TOC ) *   nrow (  TOC ) /  elementsRatio , digits =  2 )   message (   messageEstimation -   paste (  \"I Need about \" ,  timeEstimated ,  \"seconds for this DEA. [Processing 30k elements /s]  \" ) ) # Reading in the data and creating a DGEList object    colnames (  TOC ) -   paste0 (  's' ,   1 :   ncol (  TOC ) ) #DGE #TumorSample)))  if (    length (  Condtypes ) undefined  0 )  {   tumorType -   factor ( x =  Condtypes , levels =   unique (  Condtypes ) ) } else  {   tumorType -   factor ( x =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) , levels =   c (  Cond1type ,  Cond2type ) ) } # DGE.mat  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) ==  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   design -   model.matrix (  ~  tumorType ) else   design -   model.matrix (  ~   0 +  tumorType ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) ==  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) } else  if (     length (  batch.factors ) undefined  0 undefined    length (  Condtypes ) undefined  0 )  {  if (   pipeline ==  \"edgeR\" )   formula -   paste0 (  \"~tumorType+\" ,  additiveformula ) else   formula -   paste0 (  \"~0+tumorType+\" ,  additiveformula )   design -   model.matrix (   eval (   parse ( text =  formula ) ) ) }  if (   pipeline ==  \"edgeR\" )  {  if (   method ==  \"exactTest\" )  {   DGE -   edgeR :: DGEList (  TOC , group =   rep (   c (  Cond1type ,  Cond2type ) ,   c (  Cond1num ,  Cond2num ) ) ) # Analysis using common dispersion   disp -   edgeR :: estimateCommonDisp (  DGE ) # Estimating the common dispersion #tested   tested -   edgeR :: exactTest (  disp , pair =   c (  Cond1type ,  Cond2type ) ) # Testing # Results visualization   logFC_table -   tested $ table   tableDEA -    edgeR :: topTags (  tested , n =   nrow (   tested $ table ) ) $ table   tableDEA -   tableDEA [    tableDEA $ FDR =  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) =  logFC.cut , ] } else  if (   method ==  \"glmLRT\" )  {  if (    length (   unique (  tumorType ) ) ==  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , coef =  2 )   tableDEA -   cbind (   aGlmLRT $ table , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tableDEA -   tableDEA [    tableDEA $ FDR undefined  fdr.cut , ]   tableDEA -   tableDEA [    abs (   tableDEA $ logFC ) undefined  logFC.cut , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (  tableDEA ) ) ) )   tableDEA -   cbind (  tableDEA ,    map.ensg ( genes =   rownames (  tableDEA ) ) [ ,   2 :  3 ] ) } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   aDGEList -   edgeR :: DGEList ( counts =  TOC , group =  tumorType )     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   aDGEList -   edgeR :: estimateGLMCommonDisp (  aDGEList ,  design )   aDGEList -   edgeR :: estimateGLMTagwiseDisp (  aDGEList ,  design )   aGlmFit -   edgeR :: glmFit (  aDGEList ,  design , dispersion =   aDGEList $ tagwise.dispersion , prior.count.total =  0 )   print (  cont.matrix )   tableDEA -   list ( ) #[2:length(colnames(cont.matrix))]  for  ( mycoef in   colnames (  cont.matrix ) )  {   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   aGlmLRT -   edgeR :: glmLRT (  aGlmFit , contrast =   cont.matrix [ ,  mycoef ] )   print (  \"---toptags---\" )   print (   topTags (  aGlmLRT , adjust.method =  \"fdr\" , sort.by =  \"PValue\" ) )   tt -   aGlmLRT $ table   tt -   cbind (  tt , FDR =   p.adjust (    aGlmLRT $ table $ PValue ,  \"fdr\" ) )   tt -   tt [  (     tt $ FDR undefined  fdr.cut undefined    abs (   as.numeric (   tt $ logFC ) ) undefined  logFC.cut ) , ] #tt    tableDEA [[   as.character (  mycoef ) ] ] -  tt #print(rownames(tableDEA[[as.character(mycoef)]]))  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } #design } else   stop (   paste0 (  method ,  \" is not a valid DEA method option. Choose 'exactTest' or 'glmLRT' \" ) ) } else  if (   pipeline ==  \"limma\" )  { ###logcpm transformation for limma-trend method using edgeR cpm method  if (   log.trans ==  TRUE )   logCPM -   edgeR :: cpm (  TOC , log =  TRUE , prior.count =  3 ) else   logCPM -  TOC  if (   voom ==  TRUE )  {   message (  \"Voom Transformation...\" )   logCPM -   limma :: voom (  logCPM ,  design ) }  if (    length (   unique (  tumorType ) ) ==  2 )  { #DGE #c(Cond1num,Cond2num)))     colnames (  design ) [   1 :  2 ] -   c (  Cond1type ,  Cond2type )   contr -   paste0 (  Cond2type ,  \"-\" ,  Cond1type )   cont.matrix -   limma :: makeContrasts ( contrasts =  contr , levels =  design )   fit -   limma :: lmFit (  logCPM ,  design )   fit -   contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE )  {   fit -   limma :: eBayes (  fit , trend =  TRUE ) } else  {   fit -   limma :: eBayes (  fit , trend =  FALSE ) }   tableDEA -   limma :: topTable (  fit , coef =  1 , adjust.method =  'fdr' , number =   nrow (  TOC ) )   limma :: volcanoplot (  fit , highlight =  10 )   index -   which (    tableDEA [ ,  4 ] undefined  fdr.cut )   tableDEA -   tableDEA [  index , ]   neg_logFC.cut -   -  1 *  logFC.cut   index -   which (    abs (   as.numeric (   tableDEA $ logFC ) ) undefined  logFC.cut )   tableDEA -   tableDEA [  index , ] #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA } else  if (    length (   unique (  tumorType ) ) undefined  2 )  {   DGE -   edgeR :: DGEList (  TOC , group =  tumorType ) #colnames(design)[1:2]     colnames (  design ) [   1 :   length (   levels (  tumorType ) ) ] -   levels (  tumorType )   prestr =  \"makeContrasts(\"   poststr =  \",levels=colnames(design))\"   commandstr =   paste (  prestr ,  contrast.formula ,  poststr , sep =  \"\" )   commandstr =   paste0 (  \"limma::\" ,  commandstr )   cont.matrix -   eval (   parse ( text =  commandstr ) )   fit -   limma :: lmFit (  logCPM ,  design )   fit -   limma :: contrasts.fit (  fit ,  cont.matrix )  if (   trend ==  TRUE ) ##limma-trend option   fit -   limma :: eBayes (  fit , trend =  TRUE ) else   fit -   limma :: eBayes (  fit , trend =  FALSE )   tableDEA -   list ( )  for  ( mycoef in   colnames (  cont.matrix ) )  {    tableDEA [[   as.character (  mycoef ) ] ] -   limma :: topTable (  fit , coef =  mycoef , adjust.method =  \"fdr\" , number =   nrow (  MAT ) )   message (   paste0 (  \"DEA for\" ,  \" :\" ,  mycoef ) )   tempDEA -   tableDEA [[   as.character (  mycoef ) ] ]   index.up -   which (     tempDEA $ adj.P.Val undefined  fdr.cut undefined    abs (   as.numeric (   tempDEA $ logFC ) ) undefined  logFC.cut )    tableDEA [[   as.character (  mycoef ) ] ] -   tempDEA [  index.up , ]  if (   all (   grepl (  \"ENSG\" ,   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) ) )    tableDEA [[   as.character (  mycoef ) ] ] -   cbind (   tableDEA [[   as.character (  mycoef ) ] ] ,    map.ensg ( genes =   rownames (   tableDEA [[   as.character (  mycoef ) ] ] ) ) [ ,   2 :  3 ] ) #i } #sapply(colnames(dataFilt), FUN= function(x) subtypedata[which(subtypedata$samples==substr(x,1,12)),]$subtype) } } else   stop (   paste0 (  pipeline ,  \" is not a valid pipeline option. Choose 'edgeR' or 'limma'\" ) ) #if(all(grepl(\"ENSG\",rownames(tableDEA)))) tableDEA   message (  \"----------------------- END DEA -------------------------------\" )   return (  tableDEA ) } ",
    "filename": "analyze.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_7 tcgabiolinks_release_3_8

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_7 tcgabiolinks_release_3_8",
    "desc_release_old": "2.8.4",
    "desc_release_new": "2.10.5",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

GDCquery_ATAC_seq
colDataPrepare
get.GRCh.bioMart
getSampleFilesSummary


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_8 tcgabiolinks_release_3_9

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_8 tcgabiolinks_release_3_9",
    "desc_release_old": "2.10.5",
    "desc_release_new": "2.12.6",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

TCGAanalyze_Stemness


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "GDCquery",
    "representation": "GDCquery",
    "parameters": "function ( project , data.category , data.type , workflow.type , legacy = FALSE , access , platform , file.type , barcode , experimental.strategy , sample.type )",
    "body": "{   isServeOK ( )   suppressWarnings (  { # prepare output  if (   missing (  sample.type ) )  {   sample.type -  NA } else  if (   all (   sample.type ==  FALSE ) )  {   sample.type -  NA }  if (   missing (  data.type ) )  {   data.type -  NA } else  if (   data.type ==  FALSE )  {   data.type -  NA }  if (   missing (  barcode ) )  {   barcode -  NA } else  if (    length (  barcode ) ==  1 )  {  if (   barcode ==  FALSE )   barcode -  NA }  if (   missing (  platform ) )  {   platform -  NA } else  if (   platform ==  FALSE )  {   platform -  NA }  if (   missing (  file.type ) )  {   file.type -  NA } else  if (   file.type ==  FALSE )  {   file.type -  NA }  if (   missing (  workflow.type ) )  {   workflow.type -  NA } else  if (   workflow.type ==  FALSE )  {   workflow.type -  NA }  if (   missing (  experimental.strategy ) )  {   experimental.strategy -  NA } else  if (   experimental.strategy ==  FALSE )  {   experimental.strategy -  NA }  if (   missing (  access ) )  {   access -  NA } else  if (   access ==  FALSE )  {   access -  NA } } )   print.header (  \"GDCquery: Searching in GDC database\" ,  \"section\" )   message (  \"Genome of reference: \" ,   ifelse (  legacy ,  \"hg19\" ,  \"hg38\" ) ) # Check arguments   checkProjectInput (  project )   checkDataCategoriesInput (  project ,  data.category ,  legacy )  if (  !   is.na (  data.type ) )   checkDataTypeInput ( legacy =  legacy , data.type =  data.type )  if (  !   any (   is.na (  sample.type ) ) )   checkBarcodeDefinition (  sample.type )   results -  NULL   print.header (  \"Accessing GDC. This might take a while...\" ,  \"subsection\" )  for  ( proj in  project )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  workflow.type , platform =  platform , file.type =  file.type , files.access =  access , experimental.strategy =  experimental.strategy , sample.type =  sample.type )   message (  \"ooo Project: \" ,  proj )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } )  if (      json $ data $ pagination $ count ==  0 )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  NA , platform =  NA , file.type =  file.type , experimental.strategy =  experimental.strategy , files.access =  access , sample.type =  sample.type )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } ) }      json $ data $ hits $ acl -  NULL      json $ data $ hits $ project -  proj  if (   \"archive\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ archive ) )  {   archive -     json $ data $ hits $ archive     colnames (  archive ) [   1 :   ncol (  archive ) ] -   paste0 (  \"archive_\" ,    colnames (  archive ) [   1 :   ncol (  archive ) ] )      json $ data $ hits $ archive -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  archive ) } }  if (   \"analysis\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ analysis ) )  {   analysis -     json $ data $ hits $ analysis     colnames (  analysis ) [   2 :   ncol (  analysis ) ] -   paste0 (  \"analysis_\" ,    colnames (  analysis ) [   2 :   ncol (  analysis ) ] )      json $ data $ hits $ analysis -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  analysis ) } }  if (   \"center\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ center ) )  {   center -     json $ data $ hits $ center     colnames (  center ) [   2 :   ncol (  center ) ] -   paste0 (  \"center_\" ,    colnames (  center ) [   2 :   ncol (  center ) ] )      json $ data $ hits $ center -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  center ) } }   results -   plyr :: rbind.fill (   as.data.frame (  results ) ,   as.data.frame (    json $ data $ hits ) ) }  if (    ncol (  results ) ==  1 )  {   message (  \"Sorry! There is no result for your query. Please check in GDC the data available or if there is no error in your query.\" )   return (  NULL ) }   print.header (  \"Filtering results\" ,  \"subsection\" )  if (  !   any (   is.na (  platform ) ) )  {  if (  !  (   all (   platform %in%   results $ platform ) ) )  {   stop (  \"Please set a valid platform argument from the list below:\\n  = ,   paste (   unique (   results $ platform ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By platform\" )   results -   results [    tolower (   results $ platform ) %in%   tolower (  platform ) , ] } # Filter by access  if (  !   is.na (  access ) )  {   message (  \"ooo By access\" )   results -   results [   grepl (  access ,   results $ access , ignore.case =  TRUE ) , ] } # Filter by experimental strategy  if (  !   is.na (  experimental.strategy ) )  {  if (   all (    tolower (  experimental.strategy ) %in%   tolower (   results $ experimental_strategy ) ) )  {   message (  \"ooo By experimental.strategy\" )   results -   results [    tolower (   results $ experimental_strategy ) %in%   tolower (  experimental.strategy ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ experimental_strategy ) , collapse =  \"\\n= ) ) ) } } # Filter by data.type  if (  !   is.na (  data.type ) )  {  if (  !  (    tolower (  data.type ) %in%   tolower (   results $ data_type ) ) )  {   stop (  \"Please set a valid data.type argument from the list below:\\n  = ,   paste (   unique (   results $ data_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By data.type\" )   results -   results [    tolower (   results $ data_type ) %in%   tolower (  data.type ) , ] } # Filter by workflow.type  if (  !   is.na (  workflow.type ) )  {  if (  !  (   workflow.type %in%   results $ analysis_workflow_type ) )  {   stop (  \"Please set a valid workflow.type argument from the list below:\\n  = ,   paste (   unique (   results $ analysis_workflow_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By workflow.type\" )   results -   results [    results $ analysis_workflow_type %in%  workflow.type , ] } # Filter by file.type  if (  !   is.na (  file.type ) )  {   message (  \"ooo By file.type\" )   pat -  file.type   invert -  FALSE  if (   file.type ==  \"normalized_results\" )   pat -  \"normalized_results\"  if (   file.type ==  \"results\" )   pat -  \"[^normalized_]results\"  if (    file.type ==  \"nocnv_hg18\" |   file.type ==  \"nocnv_hg18.seg\" )   pat -  \"nocnv_hg18\"  if (    file.type ==  \"cnv_hg18\" |   file.type ==  \"hg18.seg\" )   pat -  \"[^nocnv_]hg18.seg\"  if (    file.type ==  \"nocnv_hg19\" |   file.type ==  \"nocnv_hg19.seg\" )   pat -  \"nocnv_hg19\"  if (    file.type ==  \"cnv_hg19\" |   file.type ==  \"hg19.seg\" )   pat -  \"[^nocnv_]hg19.seg\"  if (   file.type ==  \"mirna\" )  {   pat -  \"hg19.*mirna\"   invert -  TRUE } # if(file.type == \"hg19.mirna\") pat # if(file.type == \"hg19.mirbase20.mirna\") pat  if (   file.type ==  \"hg19.isoform\" )   pat -  \"hg19.*isoform\"  if (   file.type ==  \"isoform\" )  {   pat -  \"hg19.*isoform\"   invert -  TRUE }   idx -   grep (  pat ,   results $ file_name , invert =  invert )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (    sort (   results $ file_name ) [   1 :  10 ] , col.names =  \"Files\" ) )   stop (  \"We were not able to filter using this file type. Examples of available files are above. Please check the vignette for possible entries\" ) }   results -   results [  idx , ] } # get barcode of the samples  if (   data.category %in%   c (  \"Clinical\" ,  \"Biospecimen\" ) )  {   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" ) } else  {   pat -   paste (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}-[:alnum:]{3}-[:alnum:]{2,3}-[:alnum:]{4}-[:alnum:]{2}\" ,  \"[:alnum:]{6}-[:alnum:]{2}-[:alnum:]{6}-[:alnum:]{3}-[:alnum:]{3}\" , sep =  \"|\" ) }  if (  !   all (    unique (   results $ data_type ) ==  \"Auxiliary test\" ) )  {   barcodes -   unlist (   lapply (   results $ cases ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) } else  { # auxiliary fies case   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" )   barcodes -   unlist (   lapply (   results $ file_name ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) }    results $ cases -  barcodes    results $ tissue.definition -    expandBarcodeInfo (  barcodes ) $ tissue.definition # Filter by barcode  if (  !   any (   is.na (  barcode ) ) )  {   message (  \"ooo By barcode\" )   idx -   unique (   unlist (   sapply (  barcode ,  function ( x )   grep (  x ,   results $ cases , ignore.case =  TRUE ) ) ) )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (   results $ cases , col.names =  \"Available barcodes\" ) )   stop (  \"None of the barcodes were matched. Available barcodes are above\" ) }   results -   results [  idx , ] } # Filter by sample.type  if (  !   any (   is.na (  sample.type ) ) )  {  if (  !   any (    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) ) )  {   aux -   as.data.frame (   table (   results $ tissue.definition ) )   aux -   aux [    aux $ Freq undefined  0 , ]   print (   kable (  aux , row.names =  FALSE , col.names =   c (  \"sample.type\" ,  \"Number of samples\" ) ) )   stop (  \"Please set a valid sample.type argument from the list above.\" ) }   message (  \"ooo By sample.type\" )   results -   results [    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) , ] } # some how there are duplicated files in GDC we should remove them # Example of problematic query # query.exp #                  legacy = TRUE, #                  data.category = \"Gene expression\", #                  data.type = \"Gene expression quantification\", #                  platform = \"Illumina HiSeq\", #                  file.type = \"results\", #                  experimental_strategy = \"RNA-Seq\", #                  sample.type = c(\"Primary solid Tumor\",\"Solid Tissue Normal\")) #   print.header (  \"Checking data\" ,  \"subsection\" )   message (  \"ooo Check if there are duplicated cases\" )  if (   any (   duplicated (   results $ cases ) ) )  {   message (  \"Warning: There are more than one file for the same case. Please verify query results. You can use the command View(getResults(query)) in rstudio\" ) }   message (  \"ooo Check if there results for the query\" )  if (    nrow (  results ) ==  0 )   stop (  \"Sorry, no results were found for this query\" )   print.header (  \"Preparing output\" ,  \"section\" )   ret -   data.frame ( results =   I (   list (  results ) ) , project =   I (   list (  project ) ) , data.category =  data.category , data.type =  data.type , legacy =  legacy , access =   I (   list (  access ) ) , experimental.strategy =   I (   list (  experimental.strategy ) ) , file.type =  file.type , platform =   I (   list (  platform ) ) , sample.type =   I (   list (  sample.type ) ) , barcode =   I (   list (  barcode ) ) , workflow.type =  workflow.type )   return (  ret ) } ",
    "filename": "query.txt"
  },
  "new_function": {
    "name": "GDCquery",
    "representation": "GDCquery",
    "parameters": "function ( project , data.category , data.type , workflow.type , legacy = FALSE , access , platform , file.type , barcode , data.format , experimental.strategy , sample.type )",
    "body": "{   isServeOK ( )   suppressWarnings (  { # prepare output  if (   missing (  sample.type ) )  {   sample.type -  NA } else  if (   all (   sample.type ==  FALSE ) )  {   sample.type -  NA }  if (   missing (  data.type ) )  {   data.type -  NA } else  if (   data.type ==  FALSE )  {   data.type -  NA }  if (   missing (  barcode ) )  {   barcode -  NA } else  if (    length (  barcode ) ==  1 )  {  if (   barcode ==  FALSE )   barcode -  NA }  if (   missing (  platform ) )  {   platform -  NA } else  if (   platform ==  FALSE )  {   platform -  NA }  if (   missing (  file.type ) )  {   file.type -  NA } else  if (   file.type ==  FALSE )  {   file.type -  NA }  if (   missing (  workflow.type ) )  {   workflow.type -  NA } else  if (   workflow.type ==  FALSE )  {   workflow.type -  NA }  if (   missing (  experimental.strategy ) )  {   experimental.strategy -  NA } else  if (   experimental.strategy ==  FALSE )  {   experimental.strategy -  NA }  if (   missing (  access ) )  {   access -  NA } else  if (   access ==  FALSE )  {   access -  NA }  if (   missing (  data.format ) )  {   data.format -  NA } else  if (   data.format ==  FALSE )  {   data.format -  NA } } )   print.header (  \"GDCquery: Searching in GDC database\" ,  \"section\" )   message (  \"Genome of reference: \" ,   ifelse (  legacy ,  \"hg19\" ,  \"hg38\" ) ) # Check arguments   checkProjectInput (  project )   checkDataCategoriesInput (  project ,  data.category ,  legacy )  if (  !   is.na (  data.type ) )   checkDataTypeInput ( legacy =  legacy , data.type =  data.type )  if (  !   any (   is.na (  sample.type ) ) )   checkBarcodeDefinition (  sample.type )   results -  NULL   print.header (  \"Accessing GDC. This might take a while...\" ,  \"subsection\" )  for  ( proj in  project )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  workflow.type , platform =  platform , file.type =  file.type , files.access =  access , experimental.strategy =  experimental.strategy , sample.type =  sample.type )   message (  \"ooo Project: \" ,  proj )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } )  if (      json $ data $ pagination $ count ==  0 )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  NA , platform =  NA , file.type =  file.type , experimental.strategy =  experimental.strategy , files.access =  access , sample.type =  sample.type )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } ) }      json $ data $ hits $ acl -  NULL      json $ data $ hits $ project -  proj  if (   \"archive\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ archive ) )  {   archive -     json $ data $ hits $ archive     colnames (  archive ) [   1 :   ncol (  archive ) ] -   paste0 (  \"archive_\" ,    colnames (  archive ) [   1 :   ncol (  archive ) ] )      json $ data $ hits $ archive -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  archive ) } }  if (   \"analysis\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ analysis ) )  {   analysis -     json $ data $ hits $ analysis     colnames (  analysis ) [   2 :   ncol (  analysis ) ] -   paste0 (  \"analysis_\" ,    colnames (  analysis ) [   2 :   ncol (  analysis ) ] )      json $ data $ hits $ analysis -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  analysis ) } }  if (   \"center\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ center ) )  {   center -     json $ data $ hits $ center     colnames (  center ) [   2 :   ncol (  center ) ] -   paste0 (  \"center_\" ,    colnames (  center ) [   2 :   ncol (  center ) ] )      json $ data $ hits $ center -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  center ) } }   results -   plyr :: rbind.fill (   as.data.frame (  results ) ,   as.data.frame (    json $ data $ hits ) ) }  if (    ncol (  results ) ==  1 )  {   message (  \"Sorry! There is no result for your query. Please check in GDC the data available or if there is no error in your query.\" )   return (  NULL ) }   print.header (  \"Filtering results\" ,  \"subsection\" )  if (  !   any (   is.na (  platform ) ) )  {  if (  !  (   all (   platform %in%   results $ platform ) ) )  {   stop (  \"Please set a valid platform argument from the list below:\\n  = ,   paste (   unique (   results $ platform ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By platform\" )   results -   results [    tolower (   results $ platform ) %in%   tolower (  platform ) , ] } # Filter by access  if (  !   is.na (  access ) )  {   message (  \"ooo By access\" )   results -   results [   grepl (  access ,   results $ access , ignore.case =  TRUE ) , ] } # Filter by experimental strategy  if (  !   is.na (  experimental.strategy ) )  {  if (   all (    tolower (  experimental.strategy ) %in%   tolower (   results $ experimental_strategy ) ) )  {   message (  \"ooo By experimental.strategy\" )   results -   results [    tolower (   results $ experimental_strategy ) %in%   tolower (  experimental.strategy ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ experimental_strategy ) , collapse =  \"\\n= ) ) ) } }  if (  !   is.na (  data.format ) )  {  if (   all (    tolower (  data.format ) %in%   tolower (   results $ data_format ) ) )  {   message (  \"ooo By data.format\" )   results -   results [    tolower (   results $ data_format ) %in%   tolower (  data.format ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ data_format ) , collapse =  \"\\n= ) ) ) } } # Filter by data.type  if (  !   is.na (  data.type ) )  {  if (  !  (    tolower (  data.type ) %in%   tolower (   results $ data_type ) ) )  {   stop (  \"Please set a valid data.type argument from the list below:\\n  = ,   paste (   unique (   results $ data_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By data.type\" )   results -   results [    tolower (   results $ data_type ) %in%   tolower (  data.type ) , ] } # Filter by workflow.type  if (  !   is.na (  workflow.type ) )  {  if (  !  (   workflow.type %in%   results $ analysis_workflow_type ) )  {   stop (  \"Please set a valid workflow.type argument from the list below:\\n  = ,   paste (   unique (   results $ analysis_workflow_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By workflow.type\" )   results -   results [    results $ analysis_workflow_type %in%  workflow.type , ] } # Filter by file.type  if (  !   is.na (  file.type ) )  {   message (  \"ooo By file.type\" )   pat -  file.type   invert -  FALSE  if (   file.type ==  \"normalized_results\" )   pat -  \"normalized_results\"  if (   file.type ==  \"results\" )   pat -  \"[^normalized_]results\"  if (    file.type ==  \"nocnv_hg18\" |   file.type ==  \"nocnv_hg18.seg\" )   pat -  \"nocnv_hg18\"  if (    file.type ==  \"cnv_hg18\" |   file.type ==  \"hg18.seg\" )   pat -  \"[^nocnv_]hg18.seg\"  if (    file.type ==  \"nocnv_hg19\" |   file.type ==  \"nocnv_hg19.seg\" )   pat -  \"nocnv_hg19\"  if (    file.type ==  \"cnv_hg19\" |   file.type ==  \"hg19.seg\" )   pat -  \"[^nocnv_]hg19.seg\"  if (   file.type ==  \"mirna\" )  {   pat -  \"hg19.*mirna\"   invert -  TRUE } # if(file.type == \"hg19.mirna\") pat # if(file.type == \"hg19.mirbase20.mirna\") pat  if (   file.type ==  \"hg19.isoform\" )   pat -  \"hg19.*isoform\"  if (   file.type ==  \"isoform\" )  {   pat -  \"hg19.*isoform\"   invert -  TRUE }   idx -   grep (  pat ,   results $ file_name , invert =  invert )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (    sort (   results $ file_name ) [   1 :  10 ] , col.names =  \"Files\" ) )   stop (  \"We were not able to filter using this file type. Examples of available files are above. Please check the vignette for possible entries\" ) }   results -   results [  idx , ] } # get barcode of the samples  if (   data.category %in%   c (  \"Clinical\" ,  \"Biospecimen\" ) )  {   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" ) } else  {   pat -   paste (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}-[:alnum:]{3}-[:alnum:]{2,3}-[:alnum:]{4}-[:alnum:]{2}\" ,  \"[:alnum:]{6}-[:alnum:]{2}-[:alnum:]{6}-[:alnum:]{3}-[:alnum:]{3}\" ,  \"[:alnum:]{3}-[:alnum:]{5}-[:alnum:]{2}\" , sep =  \"|\" ) }  if (  !   all (    unique (   results $ data_type ) ==  \"Auxiliary test\" ) )  {   barcodes -   unlist (   lapply (   results $ cases ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) } else  { # auxiliary fies case   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" )   barcodes -   unlist (   lapply (   results $ file_name ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) }    results $ cases -  barcodes    results $ tissue.definition -    expandBarcodeInfo (  barcodes ) $ tissue.definition # Filter by barcode  if (  !   any (   is.na (  barcode ) ) )  {   message (  \"ooo By barcode\" )   idx -   unique (   unlist (   sapply (  barcode ,  function ( x )   grep (  x ,   results $ cases , ignore.case =  TRUE ) ) ) )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (   results $ cases , col.names =  \"Available barcodes\" ) )   stop (  \"None of the barcodes were matched. Available barcodes are above\" ) }   results -   results [  idx , ] } # Filter by sample.type  if (  !   any (   is.na (  sample.type ) ) )  {  if (  !   any (    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) ) )  {   aux -   as.data.frame (   table (   results $ tissue.definition ) )   aux -   aux [    aux $ Freq undefined  0 , ]   print (   kable (  aux , row.names =  FALSE , col.names =   c (  \"sample.type\" ,  \"Number of samples\" ) ) )   stop (  \"Please set a valid sample.type argument from the list above.\" ) }   message (  \"ooo By sample.type\" )   results -   results [    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) , ] } # some how there are duplicated files in GDC we should remove them # Example of problematic query # query.exp #                  legacy = TRUE, #                  data.category = \"Gene expression\", #                  data.type = \"Gene expression quantification\", #                  platform = \"Illumina HiSeq\", #                  file.type = \"results\", #                  experimental_strategy = \"RNA-Seq\", #                  sample.type = c(\"Primary solid Tumor\",\"Solid Tissue Normal\")) #   print.header (  \"Checking data\" ,  \"subsection\" )   message (  \"ooo Check if there are duplicated cases\" )  if (   any (   duplicated (   results $ cases ) ) )  {   message (  \"Warning: There are more than one file for the same case. Please verify query results. You can use the command View(getResults(query)) in rstudio\" ) }   message (  \"ooo Check if there results for the query\" )  if (    nrow (  results ) ==  0 )   stop (  \"Sorry, no results were found for this query\" )   print.header (  \"Preparing output\" ,  \"section\" )   ret -   data.frame ( results =   I (   list (  results ) ) , project =   I (   list (  project ) ) , data.category =  data.category , data.type =  data.type , legacy =  legacy , access =   I (   list (  access ) ) , experimental.strategy =   I (   list (  experimental.strategy ) ) , file.type =  file.type , platform =   I (   list (  platform ) ) , sample.type =   I (   list (  sample.type ) ) , barcode =   I (   list (  barcode ) ) , workflow.type =  workflow.type )   return (  ret ) } ",
    "filename": "query.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "GDCquery",
    "representation": "GDCquery",
    "parameters": "function ( project , data.category , data.type , workflow.type , legacy = FALSE , access , platform , file.type , barcode , experimental.strategy , sample.type )",
    "body": "{   isServeOK ( )   suppressWarnings (  { # prepare output  if (   missing (  sample.type ) )  {   sample.type -  NA } else  if (   all (   sample.type ==  FALSE ) )  {   sample.type -  NA }  if (   missing (  data.type ) )  {   data.type -  NA } else  if (   data.type ==  FALSE )  {   data.type -  NA }  if (   missing (  barcode ) )  {   barcode -  NA } else  if (    length (  barcode ) ==  1 )  {  if (   barcode ==  FALSE )   barcode -  NA }  if (   missing (  platform ) )  {   platform -  NA } else  if (   platform ==  FALSE )  {   platform -  NA }  if (   missing (  file.type ) )  {   file.type -  NA } else  if (   file.type ==  FALSE )  {   file.type -  NA }  if (   missing (  workflow.type ) )  {   workflow.type -  NA } else  if (   workflow.type ==  FALSE )  {   workflow.type -  NA }  if (   missing (  experimental.strategy ) )  {   experimental.strategy -  NA } else  if (   experimental.strategy ==  FALSE )  {   experimental.strategy -  NA }  if (   missing (  access ) )  {   access -  NA } else  if (   access ==  FALSE )  {   access -  NA } } )   print.header (  \"GDCquery: Searching in GDC database\" ,  \"section\" )   message (  \"Genome of reference: \" ,   ifelse (  legacy ,  \"hg19\" ,  \"hg38\" ) ) # Check arguments   checkProjectInput (  project )   checkDataCategoriesInput (  project ,  data.category ,  legacy )  if (  !   is.na (  data.type ) )   checkDataTypeInput ( legacy =  legacy , data.type =  data.type )  if (  !   any (   is.na (  sample.type ) ) )   checkBarcodeDefinition (  sample.type )   results -  NULL   print.header (  \"Accessing GDC. This might take a while...\" ,  \"subsection\" )  for  ( proj in  project )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  workflow.type , platform =  platform , file.type =  file.type , files.access =  access , experimental.strategy =  experimental.strategy , sample.type =  sample.type )   message (  \"ooo Project: \" ,  proj )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } )  if (      json $ data $ pagination $ count ==  0 )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  NA , platform =  NA , file.type =  file.type , experimental.strategy =  experimental.strategy , files.access =  access , sample.type =  sample.type )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } ) }      json $ data $ hits $ acl -  NULL      json $ data $ hits $ project -  proj  if (   \"archive\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ archive ) )  {   archive -     json $ data $ hits $ archive     colnames (  archive ) [   1 :   ncol (  archive ) ] -   paste0 (  \"archive_\" ,    colnames (  archive ) [   1 :   ncol (  archive ) ] )      json $ data $ hits $ archive -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  archive ) } }  if (   \"analysis\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ analysis ) )  {   analysis -     json $ data $ hits $ analysis     colnames (  analysis ) [   2 :   ncol (  analysis ) ] -   paste0 (  \"analysis_\" ,    colnames (  analysis ) [   2 :   ncol (  analysis ) ] )      json $ data $ hits $ analysis -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  analysis ) } }  if (   \"center\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ center ) )  {   center -     json $ data $ hits $ center     colnames (  center ) [   2 :   ncol (  center ) ] -   paste0 (  \"center_\" ,    colnames (  center ) [   2 :   ncol (  center ) ] )      json $ data $ hits $ center -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  center ) } }   results -   plyr :: rbind.fill (   as.data.frame (  results ) ,   as.data.frame (    json $ data $ hits ) ) }  if (    ncol (  results ) ==  1 )  {   message (  \"Sorry! There is no result for your query. Please check in GDC the data available or if there is no error in your query.\" )   return (  NULL ) }   print.header (  \"Filtering results\" ,  \"subsection\" )  if (  !   any (   is.na (  platform ) ) )  {  if (  !  (   all (   platform %in%   results $ platform ) ) )  {   stop (  \"Please set a valid platform argument from the list below:\\n  = ,   paste (   unique (   results $ platform ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By platform\" )   results -   results [    tolower (   results $ platform ) %in%   tolower (  platform ) , ] } # Filter by access  if (  !   is.na (  access ) )  {   message (  \"ooo By access\" )   results -   results [   grepl (  access ,   results $ access , ignore.case =  TRUE ) , ] } # Filter by experimental strategy  if (  !   is.na (  experimental.strategy ) )  {  if (   all (    tolower (  experimental.strategy ) %in%   tolower (   results $ experimental_strategy ) ) )  {   message (  \"ooo By experimental.strategy\" )   results -   results [    tolower (   results $ experimental_strategy ) %in%   tolower (  experimental.strategy ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ experimental_strategy ) , collapse =  \"\\n= ) ) ) } } # Filter by data.type  if (  !   is.na (  data.type ) )  {  if (  !  (    tolower (  data.type ) %in%   tolower (   results $ data_type ) ) )  {   stop (  \"Please set a valid data.type argument from the list below:\\n  = ,   paste (   unique (   results $ data_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By data.type\" )   results -   results [    tolower (   results $ data_type ) %in%   tolower (  data.type ) , ] } # Filter by workflow.type  if (  !   is.na (  workflow.type ) )  {  if (  !  (   workflow.type %in%   results $ analysis_workflow_type ) )  {   stop (  \"Please set a valid workflow.type argument from the list below:\\n  = ,   paste (   unique (   results $ analysis_workflow_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By workflow.type\" )   results -   results [    results $ analysis_workflow_type %in%  workflow.type , ] } # Filter by file.type  if (  !   is.na (  file.type ) )  {   message (  \"ooo By file.type\" )   pat -  file.type   invert -  FALSE  if (   file.type ==  \"normalized_results\" )   pat -  \"normalized_results\"  if (   file.type ==  \"results\" )   pat -  \"[^normalized_]results\"  if (    file.type ==  \"nocnv_hg18\" |   file.type ==  \"nocnv_hg18.seg\" )   pat -  \"nocnv_hg18\"  if (    file.type ==  \"cnv_hg18\" |   file.type ==  \"hg18.seg\" )   pat -  \"[^nocnv_]hg18.seg\"  if (    file.type ==  \"nocnv_hg19\" |   file.type ==  \"nocnv_hg19.seg\" )   pat -  \"nocnv_hg19\"  if (    file.type ==  \"cnv_hg19\" |   file.type ==  \"hg19.seg\" )   pat -  \"[^nocnv_]hg19.seg\"  if (   file.type ==  \"mirna\" )  {   pat -  \"hg19.*mirna\"   invert -  TRUE } # if(file.type == \"hg19.mirna\") pat # if(file.type == \"hg19.mirbase20.mirna\") pat  if (   file.type ==  \"hg19.isoform\" )   pat -  \"hg19.*isoform\"  if (   file.type ==  \"isoform\" )  {   pat -  \"hg19.*isoform\"   invert -  TRUE }   idx -   grep (  pat ,   results $ file_name , invert =  invert )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (    sort (   results $ file_name ) [   1 :  10 ] , col.names =  \"Files\" ) )   stop (  \"We were not able to filter using this file type. Examples of available files are above. Please check the vignette for possible entries\" ) }   results -   results [  idx , ] } # get barcode of the samples  if (   data.category %in%   c (  \"Clinical\" ,  \"Biospecimen\" ) )  {   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" ) } else  {   pat -   paste (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}-[:alnum:]{3}-[:alnum:]{2,3}-[:alnum:]{4}-[:alnum:]{2}\" ,  \"[:alnum:]{6}-[:alnum:]{2}-[:alnum:]{6}-[:alnum:]{3}-[:alnum:]{3}\" , sep =  \"|\" ) }  if (  !   all (    unique (   results $ data_type ) ==  \"Auxiliary test\" ) )  {   barcodes -   unlist (   lapply (   results $ cases ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) } else  { # auxiliary fies case   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" )   barcodes -   unlist (   lapply (   results $ file_name ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) }    results $ cases -  barcodes    results $ tissue.definition -    expandBarcodeInfo (  barcodes ) $ tissue.definition # Filter by barcode  if (  !   any (   is.na (  barcode ) ) )  {   message (  \"ooo By barcode\" )   idx -   unique (   unlist (   sapply (  barcode ,  function ( x )   grep (  x ,   results $ cases , ignore.case =  TRUE ) ) ) )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (   results $ cases , col.names =  \"Available barcodes\" ) )   stop (  \"None of the barcodes were matched. Available barcodes are above\" ) }   results -   results [  idx , ] } # Filter by sample.type  if (  !   any (   is.na (  sample.type ) ) )  {  if (  !   any (    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) ) )  {   aux -   as.data.frame (   table (   results $ tissue.definition ) )   aux -   aux [    aux $ Freq undefined  0 , ]   print (   kable (  aux , row.names =  FALSE , col.names =   c (  \"sample.type\" ,  \"Number of samples\" ) ) )   stop (  \"Please set a valid sample.type argument from the list above.\" ) }   message (  \"ooo By sample.type\" )   results -   results [    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) , ] } # some how there are duplicated files in GDC we should remove them # Example of problematic query # query.exp #                  legacy = TRUE, #                  data.category = \"Gene expression\", #                  data.type = \"Gene expression quantification\", #                  platform = \"Illumina HiSeq\", #                  file.type = \"results\", #                  experimental_strategy = \"RNA-Seq\", #                  sample.type = c(\"Primary solid Tumor\",\"Solid Tissue Normal\")) #   print.header (  \"Checking data\" ,  \"subsection\" )   message (  \"ooo Check if there are duplicated cases\" )  if (   any (   duplicated (   results $ cases ) ) )  {   message (  \"Warning: There are more than one file for the same case. Please verify query results. You can use the command View(getResults(query)) in rstudio\" ) }   message (  \"ooo Check if there results for the query\" )  if (    nrow (  results ) ==  0 )   stop (  \"Sorry, no results were found for this query\" )   print.header (  \"Preparing output\" ,  \"section\" )   ret -   data.frame ( results =   I (   list (  results ) ) , project =   I (   list (  project ) ) , data.category =  data.category , data.type =  data.type , legacy =  legacy , access =   I (   list (  access ) ) , experimental.strategy =   I (   list (  experimental.strategy ) ) , file.type =  file.type , platform =   I (   list (  platform ) ) , sample.type =   I (   list (  sample.type ) ) , barcode =   I (   list (  barcode ) ) , workflow.type =  workflow.type )   return (  ret ) } ",
    "filename": "query.txt"
  },
  "new_function": {
    "name": "GDCquery",
    "representation": "GDCquery",
    "parameters": "function ( project , data.category , data.type , workflow.type , legacy = FALSE , access , platform , file.type , barcode , data.format , experimental.strategy , sample.type )",
    "body": "{   isServeOK ( )   suppressWarnings (  { # prepare output  if (   missing (  sample.type ) )  {   sample.type -  NA } else  if (   all (   sample.type ==  FALSE ) )  {   sample.type -  NA }  if (   missing (  data.type ) )  {   data.type -  NA } else  if (   data.type ==  FALSE )  {   data.type -  NA }  if (   missing (  barcode ) )  {   barcode -  NA } else  if (    length (  barcode ) ==  1 )  {  if (   barcode ==  FALSE )   barcode -  NA }  if (   missing (  platform ) )  {   platform -  NA } else  if (   platform ==  FALSE )  {   platform -  NA }  if (   missing (  file.type ) )  {   file.type -  NA } else  if (   file.type ==  FALSE )  {   file.type -  NA }  if (   missing (  workflow.type ) )  {   workflow.type -  NA } else  if (   workflow.type ==  FALSE )  {   workflow.type -  NA }  if (   missing (  experimental.strategy ) )  {   experimental.strategy -  NA } else  if (   experimental.strategy ==  FALSE )  {   experimental.strategy -  NA }  if (   missing (  access ) )  {   access -  NA } else  if (   access ==  FALSE )  {   access -  NA }  if (   missing (  data.format ) )  {   data.format -  NA } else  if (   data.format ==  FALSE )  {   data.format -  NA } } )   print.header (  \"GDCquery: Searching in GDC database\" ,  \"section\" )   message (  \"Genome of reference: \" ,   ifelse (  legacy ,  \"hg19\" ,  \"hg38\" ) ) # Check arguments   checkProjectInput (  project )   checkDataCategoriesInput (  project ,  data.category ,  legacy )  if (  !   is.na (  data.type ) )   checkDataTypeInput ( legacy =  legacy , data.type =  data.type )  if (  !   any (   is.na (  sample.type ) ) )   checkBarcodeDefinition (  sample.type )   results -  NULL   print.header (  \"Accessing GDC. This might take a while...\" ,  \"subsection\" )  for  ( proj in  project )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  workflow.type , platform =  platform , file.type =  file.type , files.access =  access , experimental.strategy =  experimental.strategy , sample.type =  sample.type )   message (  \"ooo Project: \" ,  proj )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } )  if (      json $ data $ pagination $ count ==  0 )  {   url -   getGDCquery ( project =  proj , data.category =  data.category , data.type =  data.type , legacy =  legacy , workflow.type =  NA , platform =  NA , file.type =  file.type , experimental.strategy =  experimental.strategy , files.access =  access , sample.type =  sample.type )   json -   tryCatch (   getURL (  url ,  fromJSON ,   timeout (  600 ) , simplifyDataFrame =  TRUE ) , error =  function ( e )  {   message (   paste (  \"Error: \" ,  e , sep =  \" \" ) )   message (  \"We will retry to access GDC!\" )   fromJSON (   content (   getURL (  url ,  GET ,   timeout (  600 ) ) , as =  \"text\" , encoding =  \"UTF-8\" ) , simplifyDataFrame =  TRUE ) } ) }      json $ data $ hits $ acl -  NULL      json $ data $ hits $ project -  proj  if (   \"archive\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ archive ) )  {   archive -     json $ data $ hits $ archive     colnames (  archive ) [   1 :   ncol (  archive ) ] -   paste0 (  \"archive_\" ,    colnames (  archive ) [   1 :   ncol (  archive ) ] )      json $ data $ hits $ archive -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  archive ) } }  if (   \"analysis\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ analysis ) )  {   analysis -     json $ data $ hits $ analysis     colnames (  analysis ) [   2 :   ncol (  analysis ) ] -   paste0 (  \"analysis_\" ,    colnames (  analysis ) [   2 :   ncol (  analysis ) ] )      json $ data $ hits $ analysis -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  analysis ) } }  if (   \"center\" %in%   colnames (    json $ data $ hits ) )  {  if (   is.data.frame (     json $ data $ hits $ center ) )  {   center -     json $ data $ hits $ center     colnames (  center ) [   2 :   ncol (  center ) ] -   paste0 (  \"center_\" ,    colnames (  center ) [   2 :   ncol (  center ) ] )      json $ data $ hits $ center -  NULL     json $ data $ hits -   cbind (    json $ data $ hits ,  center ) } }   results -   plyr :: rbind.fill (   as.data.frame (  results ) ,   as.data.frame (    json $ data $ hits ) ) }  if (    ncol (  results ) ==  1 )  {   message (  \"Sorry! There is no result for your query. Please check in GDC the data available or if there is no error in your query.\" )   return (  NULL ) }   print.header (  \"Filtering results\" ,  \"subsection\" )  if (  !   any (   is.na (  platform ) ) )  {  if (  !  (   all (   platform %in%   results $ platform ) ) )  {   stop (  \"Please set a valid platform argument from the list below:\\n  = ,   paste (   unique (   results $ platform ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By platform\" )   results -   results [    tolower (   results $ platform ) %in%   tolower (  platform ) , ] } # Filter by access  if (  !   is.na (  access ) )  {   message (  \"ooo By access\" )   results -   results [   grepl (  access ,   results $ access , ignore.case =  TRUE ) , ] } # Filter by experimental strategy  if (  !   is.na (  experimental.strategy ) )  {  if (   all (    tolower (  experimental.strategy ) %in%   tolower (   results $ experimental_strategy ) ) )  {   message (  \"ooo By experimental.strategy\" )   results -   results [    tolower (   results $ experimental_strategy ) %in%   tolower (  experimental.strategy ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ experimental_strategy ) , collapse =  \"\\n= ) ) ) } }  if (  !   is.na (  data.format ) )  {  if (   all (    tolower (  data.format ) %in%   tolower (   results $ data_format ) ) )  {   message (  \"ooo By data.format\" )   results -   results [    tolower (   results $ data_format ) %in%   tolower (  data.format ) , ] } else  {   message (   paste0 (  \"The argument experimental_strategy does not match any of the results.\\nPossible values:\" ,   paste (   unique (   results $ data_format ) , collapse =  \"\\n= ) ) ) } } # Filter by data.type  if (  !   is.na (  data.type ) )  {  if (  !  (    tolower (  data.type ) %in%   tolower (   results $ data_type ) ) )  {   stop (  \"Please set a valid data.type argument from the list below:\\n  = ,   paste (   unique (   results $ data_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By data.type\" )   results -   results [    tolower (   results $ data_type ) %in%   tolower (  data.type ) , ] } # Filter by workflow.type  if (  !   is.na (  workflow.type ) )  {  if (  !  (   workflow.type %in%   results $ analysis_workflow_type ) )  {   stop (  \"Please set a valid workflow.type argument from the list below:\\n  = ,   paste (   unique (   results $ analysis_workflow_type ) , collapse =  \"\\n  = ) ) }   message (  \"ooo By workflow.type\" )   results -   results [    results $ analysis_workflow_type %in%  workflow.type , ] } # Filter by file.type  if (  !   is.na (  file.type ) )  {   message (  \"ooo By file.type\" )   pat -  file.type   invert -  FALSE  if (   file.type ==  \"normalized_results\" )   pat -  \"normalized_results\"  if (   file.type ==  \"results\" )   pat -  \"[^normalized_]results\"  if (    file.type ==  \"nocnv_hg18\" |   file.type ==  \"nocnv_hg18.seg\" )   pat -  \"nocnv_hg18\"  if (    file.type ==  \"cnv_hg18\" |   file.type ==  \"hg18.seg\" )   pat -  \"[^nocnv_]hg18.seg\"  if (    file.type ==  \"nocnv_hg19\" |   file.type ==  \"nocnv_hg19.seg\" )   pat -  \"nocnv_hg19\"  if (    file.type ==  \"cnv_hg19\" |   file.type ==  \"hg19.seg\" )   pat -  \"[^nocnv_]hg19.seg\"  if (   file.type ==  \"mirna\" )  {   pat -  \"hg19.*mirna\"   invert -  TRUE } # if(file.type == \"hg19.mirna\") pat # if(file.type == \"hg19.mirbase20.mirna\") pat  if (   file.type ==  \"hg19.isoform\" )   pat -  \"hg19.*isoform\"  if (   file.type ==  \"isoform\" )  {   pat -  \"hg19.*isoform\"   invert -  TRUE }   idx -   grep (  pat ,   results $ file_name , invert =  invert )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (    sort (   results $ file_name ) [   1 :  10 ] , col.names =  \"Files\" ) )   stop (  \"We were not able to filter using this file type. Examples of available files are above. Please check the vignette for possible entries\" ) }   results -   results [  idx , ] } # get barcode of the samples  if (   data.category %in%   c (  \"Clinical\" ,  \"Biospecimen\" ) )  {   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" ) } else  {   pat -   paste (  \"[:alnum:]{4}-[:alnum:]{2}-[:alnum:]{4}-[:alnum:]{3}-[:alnum:]{2,3}-[:alnum:]{4}-[:alnum:]{2}\" ,  \"[:alnum:]{6}-[:alnum:]{2}-[:alnum:]{6}-[:alnum:]{3}-[:alnum:]{3}\" ,  \"[:alnum:]{3}-[:alnum:]{5}-[:alnum:]{2}\" , sep =  \"|\" ) }  if (  !   all (    unique (   results $ data_type ) ==  \"Auxiliary test\" ) )  {   barcodes -   unlist (   lapply (   results $ cases ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) } else  { # auxiliary fies case   pat -   paste (  \"TCGA-[:alnum:]{2}-[:alnum:]{4}\" ,  \"TARGET-[:alnum:]{2}-[:alnum:]{6}\" , sep =  \"|\" )   barcodes -   unlist (   lapply (   results $ file_name ,  function ( x )  {   str -      str_extract_all (   unlist (  x ) ,  pat ) %  unlist %  na.omit %   paste ( collapse =  \",\" )   ifelse (   all (   is.na (  str ) ) ,  NA ,   str [  !   is.na (  str ) ] ) } ) ) }    results $ cases -  barcodes    results $ tissue.definition -    expandBarcodeInfo (  barcodes ) $ tissue.definition # Filter by barcode  if (  !   any (   is.na (  barcode ) ) )  {   message (  \"ooo By barcode\" )   idx -   unique (   unlist (   sapply (  barcode ,  function ( x )   grep (  x ,   results $ cases , ignore.case =  TRUE ) ) ) )  if (    length (  idx ) ==  0 )  {   print (   knitr :: kable (   results $ cases , col.names =  \"Available barcodes\" ) )   stop (  \"None of the barcodes were matched. Available barcodes are above\" ) }   results -   results [  idx , ] } # Filter by sample.type  if (  !   any (   is.na (  sample.type ) ) )  {  if (  !   any (    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) ) )  {   aux -   as.data.frame (   table (   results $ tissue.definition ) )   aux -   aux [    aux $ Freq undefined  0 , ]   print (   kable (  aux , row.names =  FALSE , col.names =   c (  \"sample.type\" ,  \"Number of samples\" ) ) )   stop (  \"Please set a valid sample.type argument from the list above.\" ) }   message (  \"ooo By sample.type\" )   results -   results [    tolower (   results $ tissue.definition ) %in%   tolower (  sample.type ) , ] } # some how there are duplicated files in GDC we should remove them # Example of problematic query # query.exp #                  legacy = TRUE, #                  data.category = \"Gene expression\", #                  data.type = \"Gene expression quantification\", #                  platform = \"Illumina HiSeq\", #                  file.type = \"results\", #                  experimental_strategy = \"RNA-Seq\", #                  sample.type = c(\"Primary solid Tumor\",\"Solid Tissue Normal\")) #   print.header (  \"Checking data\" ,  \"subsection\" )   message (  \"ooo Check if there are duplicated cases\" )  if (   any (   duplicated (   results $ cases ) ) )  {   message (  \"Warning: There are more than one file for the same case. Please verify query results. You can use the command View(getResults(query)) in rstudio\" ) }   message (  \"ooo Check if there results for the query\" )  if (    nrow (  results ) ==  0 )   stop (  \"Sorry, no results were found for this query\" )   print.header (  \"Preparing output\" ,  \"section\" )   ret -   data.frame ( results =   I (   list (  results ) ) , project =   I (   list (  project ) ) , data.category =  data.category , data.type =  data.type , legacy =  legacy , access =   I (   list (  access ) ) , experimental.strategy =   I (   list (  experimental.strategy ) ) , file.type =  file.type , platform =   I (   list (  platform ) ) , sample.type =   I (   list (  sample.type ) ) , barcode =   I (   list (  barcode ) ) , workflow.type =  workflow.type )   return (  ret ) } ",
    "filename": "query.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_9 tcgabiolinks_release_3_11

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_9 tcgabiolinks_release_3_11",
    "desc_release_old": "2.12.6",
    "desc_release_new": "2.16.4",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 1,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 2
}

##########
Functions Removed
##########

TCGAanalyze_DMR


##########
Functions Added
##########

TCGAanalyze_DMC
getLinkedOmicsData
getMC3MAF
gliomaClassifier


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( data , col.metadata , row.metadata , col.colors = NULL , row.colors = NULL , show_column_names = FALSE , show_row_names = FALSE , cluster_rows = FALSE , cluster_columns = FALSE , sortCol , extrems = NULL , rownames.size = 12 , title = NULL , color.levels = NULL , values.label = NULL , filename = \"heatmap.pdf\" , width = 10 , height = 10 , type = \"expression\" , scale = \"none\" , heatmap.legend.color.bar = \"continuous\" )",
    "body": "{ # STEP 1 add columns labels (top of heatmap)   ha -  NULL  if (  !   missing (  col.metadata ) )  {  if (  !   is.null (  col.metadata ) )  {   id -  NULL  if (   \"patient\" %in%   colnames (  col.metadata ) )  {   id -  \"patient\"   size -  12 }  if (   \"barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  28 )   size -  28 }  if (   \"bcr_patient_barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"bcr_patient_barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  12 )   size -  12 }  if (   \"sample\" %in%   colnames (  col.metadata ) )  {   id -  \"sample\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  16 )   size -  16 }  if (   is.null (  id ) )  {   message (  \"=============== INNPUT ERROR =================\" )   message (  \"I'm expecting one of these columns:\" )   message (  \" = )   message (  \"    Has the complete barcode (TCGA-AA-3833-01A-01D-0904-05)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the sample barcode (TCGA-AA-3833-01A)\" )   message (  \"-----------------------------------------------\" )   message (  \"Obs: The complete barcode is the recommended one, as the others might lead to errors\" )   return (  NULL ) }   stopifnot (    nchar (    as.character (   col.metadata [ ,  id ] ) [  1 ] ) ==  size )   message (   paste0 (  \"Reorganizing: col.metadata order should be the same of the data object\" ) )   df -   col.metadata [   match (   substr (   colnames (  data ) ,  1 ,  size ) ,   col.metadata [ ,  id ] ) , ]    df [ ,  id ] -  NULL   duplicated.samples -   any (   sapply (   col.metadata [ ,  id ] ,  function ( x )  {    length (   grep (  x ,   col.metadata [ ,  id ] ) ) undefined  1 } ) )  if (  duplicated.samples )  {   warning (  \"Some samples are from the same patient, this might lead to the wrong upper annotation\" ) }  if (  !   missing (  sortCol ) )  {   message (   paste0 (  \"Sorting columns based on column: \" ,  sortCol ) )   column_order -   order (   df [ ,  sortCol ] ) }  if (   is.null (  col.colors ) )  {   ha -   HeatmapAnnotation ( df =  df ) } else  {   ha -   HeatmapAnnotation ( df =  df , col =  col.colors ) } } } # STEP 2 Create heatmap  if (   is.null (  color.levels ) )  {  if (   type ==  \"expression\" )   color.levels -   c (  \"green\" ,  \"white\" ,  \"red\" )  if (   type ==  \"methylation\" )   color.levels -   c (  \"blue\" ,  \"white\" ,  \"red\" ) } # If we want to show differences between genes, it is good to make Z-score by samples # (force each sample to have zero mean and standard deviation=1). # If we want to show differences between samples, it is good to make Z-score by genes # (force each gene to have zero mean and standard deviation=1).  if (   scale ==  \"row\" )  {   message (  \"Calculating z-scores for the rows....\" )   data -   t (   scale (   t (  data ) ) )   all.na -   apply (  data ,  1 ,  function ( x )   all (   is.na (  x ) ) )   data -   data [  !  all.na , ] } else  if (   scale ==  \"col\" )  {   message (  \"Calculiating z-scores for the columns....\" )   data -   scale (  data ) }  if (   is.null (  extrems ) )  {  if (    min (  data , na.rm =  TRUE ) undefined  0 )  {   extrems -   c (   min (  data , na.rm =  TRUE ) ,   (    max (  data , na.rm =  TRUE ) +   min (  data , na.rm =  TRUE ) ) /  2 ,   max (  data , na.rm =  TRUE ) ) } else  {   extrems -   c (  0 ,    max (  data , na.rm =  TRUE ) /  2 ,   max (  data , na.rm =  TRUE ) ) } }  if (   type ==  \"expression\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels )  if (   type ==  \"methylation\" )   color -   circlize :: colorRamp2 (  extrems ,  color.levels ) # Creating plot title  if (   is.null (  title ) )  {  if (   type ==  \"methylation\" )   title -  \"DNA methylation heatmap\"  if (   type ==  \"expression\" )   title -  \"Expression heatmap\" } # Change label type   heatmap_legend_param -   list ( )  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"methylation\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param )  if (  !   scale %in%   c (  \"row\" ,  \"col\" ) )   heatmap_legend_param -   list ( color_bar =  \"continuous\" , at =   c (  0 ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  1 ) , legend_height =   unit (  3 ,  \"cm\" ) , labels =   c (  \"0.0 (hypomethylated)\" ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  \"1.0 (hypermethylated)\" ) ) }  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"expression\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param ) } # Change label reference  if (   is.null (  values.label ) )  {  if (   type ==  \"methylation\" )   values.label -  \"DNA methylation level\"  if (   type ==  \"expression\" )  {   values.label -  \"Expression\"  if (   scale !=  \"none\" )   values.label -   paste0 (  values.label ,  \"(z-score)\" ) } }  if (   !   missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (    missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , show_row_names =  show_row_names , row_names_gp =   gpar ( fontsize =  rownames.size ) , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (  !   missing (  sortCol ) )  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title ) } else  {   heatmap -   Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } # STEP 3 row labels (right side)  if (  !   missing (  row.metadata ) )  {  if (  !   is.null (  row.metadata ) )  {  for  ( i in   1 :   ncol (  row.metadata ) )  {  if (   !   missing (  row.colors ) undefined  !   is.null (   row.colors [[    colnames (  row.metadata ) [  i ] ] ] ) )  {   color -   row.colors [[    colnames (  row.metadata ) [  i ] ] ]   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE , col =  color ) } else  {   x =   Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE ) }   heatmap -   add_heatmap (  heatmap ,  x ) } } }  if (  !   is.null (  filename ) )  {  if (    file_ext (  filename ) ==  \"png\" )   png (  filename , width =  width , height =  height )  if (    file_ext (  filename ) ==  \"pdf\" )   pdf (  filename , width =  width , height =  height )   draw (  heatmap )   dev.off ( ) } else  {   draw (  heatmap ) } } ",
    "filename": "visualize.txt"
  },
  "new_function": {
    "name": "TCGAvisualize_Heatmap",
    "representation": "TCGAvisualize_Heatmap",
    "parameters": "function ( data , col.metadata , row.metadata , col.colors = NULL , row.colors = NULL , show_column_names = FALSE , show_row_names = FALSE , cluster_rows = FALSE , cluster_columns = FALSE , sortCol , extremes = NULL , rownames.size = 12 , title = NULL , color.levels = NULL , values.label = NULL , filename = \"heatmap.pdf\" , width = 10 , height = 10 , type = \"expression\" , scale = \"none\" , heatmap.legend.color.bar = \"continuous\" )",
    "body": "{   check_package (  \"ComplexHeatmap\" )   check_package (  \"circlize\" ) # STEP 1 add columns labels (top of heatmap)   ha -  NULL  if (  !   missing (  col.metadata ) )  {  if (  !   is.null (  col.metadata ) )  {   id -  NULL  if (   \"patient\" %in%   colnames (  col.metadata ) )  {   id -  \"patient\"   size -  12 }  if (   \"barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  28 )   size -  28 }  if (   \"bcr_patient_barcode\" %in%   colnames (  col.metadata ) )  {   id -  \"bcr_patient_barcode\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  12 )   size -  12 }  if (   \"sample\" %in%   colnames (  col.metadata ) )  {   id -  \"sample\"   stopifnot (     nchar (   col.metadata [ ,  id ] ) [  1 ] ==  16 )   size -  16 }  if (   is.null (  id ) )  {   message (  \"=============== INNPUT ERROR =================\" )   message (  \"I'm expecting one of these columns:\" )   message (  \" = )   message (  \"    Has the complete barcode (TCGA-AA-3833-01A-01D-0904-05)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the patient barcode (TCGA-AA-3833)\" )   message (  \" = )   message (  \"    Has the sample barcode (TCGA-AA-3833-01A)\" )   message (  \"-----------------------------------------------\" )   message (  \"Obs: The complete barcode is the recommended one, as the others might lead to errors\" )   return (  NULL ) }   stopifnot (    nchar (    as.character (   col.metadata [ ,  id ] ) [  1 ] ) ==  size )   message (   paste0 (  \"Reorganizing: col.metadata order should be the same of the data object\" ) )   df -   col.metadata [   match (   substr (   colnames (  data ) ,  1 ,  size ) ,   col.metadata [ ,  id ] ) , ]    df [ ,  id ] -  NULL   duplicated.samples -   any (   sapply (   col.metadata [ ,  id ] ,  function ( x )  {    length (   grep (  x ,   col.metadata [ ,  id ] ) ) undefined  1 } ) )  if (  duplicated.samples )  {   warning (  \"Some samples are from the same patient, this might lead to the wrong upper annotation\" ) }  if (  !   missing (  sortCol ) )  {   message (   paste0 (  \"Sorting columns based on column: \" ,  sortCol ) )   column_order -   order (   df [ ,  sortCol ] ) }  if (   is.null (  col.colors ) )  {   ha -   ComplexHeatmap :: HeatmapAnnotation ( df =  df ) } else  {   ha -   ComplexHeatmap :: HeatmapAnnotation ( df =  df , col =  col.colors ) } } } # STEP 2 Create heatmap  if (   is.null (  color.levels ) )  {  if (   type ==  \"expression\" )   color.levels -   c (  \"green\" ,  \"white\" ,  \"red\" )  if (   type ==  \"methylation\" )   color.levels -   c (  \"blue\" ,  \"white\" ,  \"red\" ) } # If we want to show differences between genes, it is good to make Z-score by samples # (force each sample to have zero mean and standard deviation=1). # If we want to show differences between samples, it is good to make Z-score by genes # (force each gene to have zero mean and standard deviation=1).  if (   scale ==  \"row\" )  {   message (  \"Calculating z-scores for the rows....\" )   data -   t (   scale (   t (  data ) ) )   all.na -   apply (  data ,  1 ,  function ( x )   all (   is.na (  x ) ) )   data -   data [  !  all.na , ] } else  if (   scale ==  \"col\" )  {   message (  \"Calculiating z-scores for the columns....\" )   data -   scale (  data ) }  if (   is.null (  extremes ) )  {  if (    min (  data , na.rm =  TRUE ) undefined  0 )  {   extremes -   c (   min (  data , na.rm =  TRUE ) ,   (    max (  data , na.rm =  TRUE ) +   min (  data , na.rm =  TRUE ) ) /  2 ,   max (  data , na.rm =  TRUE ) ) } else  {   extremes -   c (  0 ,    max (  data , na.rm =  TRUE ) /  2 ,   max (  data , na.rm =  TRUE ) ) } }  if (   type ==  \"expression\" )   color -   circlize :: colorRamp2 (  extremes ,  color.levels )  if (   type ==  \"methylation\" )   color -   circlize :: colorRamp2 (  extremes ,  color.levels ) # Creating plot title  if (   is.null (  title ) )  {  if (   type ==  \"methylation\" )   title -  \"DNA methylation heatmap\"  if (   type ==  \"expression\" )   title -  \"Expression heatmap\" } # Change label type   heatmap_legend_param -   list ( )  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"methylation\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param )  if (  !   scale %in%   c (  \"row\" ,  \"col\" ) )   heatmap_legend_param -   list ( color_bar =  \"continuous\" , at =   c (  0 ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  1 ) , legend_height =   unit (  3 ,  \"cm\" ) , labels =   c (  \"0.0 (hypomethylated)\" ,  0.2 ,  0.4 ,  0.6 ,  0.8 ,  \"1.0 (hypermethylated)\" ) ) }  if (    heatmap.legend.color.bar ==  \"continuous\" undefined   type ==  \"expression\" )  {   heatmap_legend_param -   c (   list ( color_bar =  \"continuous\" ) ,  heatmap_legend_param ) } # Change label reference  if (   is.null (  values.label ) )  {  if (   type ==  \"methylation\" )   values.label -  \"DNA methylation level\"  if (   type ==  \"expression\" )  {   values.label -  \"Expression\"  if (   scale !=  \"none\" )   values.label -   paste0 (  values.label ,  \"(z-score)\" ) } }  if (   !   missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   ComplexHeatmap :: Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   grid :: gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (    missing (  sortCol ) undefined   heatmap.legend.color.bar ==  \"continuous\" )  {   heatmap -   ComplexHeatmap :: Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , show_row_names =  show_row_names , row_names_gp =   grid :: gpar ( fontsize =  rownames.size ) , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } else  if (  !   missing (  sortCol ) )  {   heatmap -   ComplexHeatmap :: Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   grid :: gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_order =  column_order , column_title =  title ) } else  {   heatmap -   ComplexHeatmap :: Heatmap (  data , name =  values.label , top_annotation =  ha , col =  color , row_names_gp =   grid :: gpar ( fontsize =  rownames.size ) , show_row_names =  show_row_names , cluster_rows =  cluster_rows , cluster_columns =  cluster_columns , show_column_names =  show_column_names , column_title =  title , heatmap_legend_param =  heatmap_legend_param ) } # STEP 3 row labels (right side)  if (  !   missing (  row.metadata ) )  {  if (  !   is.null (  row.metadata ) )  {  for  ( i in   1 :   ncol (  row.metadata ) )  {  if (   !   missing (  row.colors ) undefined  !   is.null (   row.colors [[    colnames (  row.metadata ) [  i ] ] ] ) )  {   color -   row.colors [[    colnames (  row.metadata ) [  i ] ] ]   x =   ComplexHeatmap :: Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE , col =  color ) } else  {   x =   ComplexHeatmap :: Heatmap (   row.metadata [ ,  i ] , name =    colnames (  row.metadata ) [  i ] , width =   unit (  0.5 ,  \"cm\" ) , show_row_names =  FALSE ) }   heatmap -   ComplexHeatmap :: add_heatmap (  heatmap ,  x ) } } }  if (  !   is.null (  filename ) )  {  if (    tools :: file_ext (  filename ) ==  \"png\" )   png (  filename , width =  width , height =  height )  if (    tools :: file_ext (  filename ) ==  \"pdf\" )   pdf (  filename , width =  width , height =  height )   ComplexHeatmap :: draw (  heatmap )   dev.off ( ) } else  {   ComplexHeatmap :: draw (  heatmap ) } } ",
    "filename": "visualize.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_11 tcgabiolinks_release_3_12

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_11 tcgabiolinks_release_3_12",
    "desc_release_old": "2.16.4",
    "desc_release_new": "2.18.0",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_12 tcgabiolinks_release_3_13

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_12 tcgabiolinks_release_3_13",
    "desc_release_old": "2.18.0",
    "desc_release_new": "2.20.1",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_13 tcgabiolinks_release_3_14

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_13 tcgabiolinks_release_3_14",
    "desc_release_old": "2.20.1",
    "desc_release_new": "2.22.4",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  tcgabiolinks_release_3_14 tcgabiolinks_master

{
    "package": "TCGAbiolinks",
    "release_versions": "tcgabiolinks_release_3_14 tcgabiolinks_master",
    "desc_release_old": "2.22.4",
    "desc_release_new": "2.23.5",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

