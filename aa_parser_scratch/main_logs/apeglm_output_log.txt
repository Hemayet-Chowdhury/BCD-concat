
###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_6 apeglm_release_3_7

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_6 apeglm_release_3_7",
    "desc_release_old": "1.0.3",
    "desc_release_new": "1.2.1",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "apeglm",
    "representation": "apeglm",
    "parameters": "function ( Y , x , log.lik , param = NULL , coef = NULL , mle = NULL , no.shrink = FALSE , interval.type = c ( 'laplace' , 'HPD' , 'credible' ) , interval.level = 0.95 , threshold = NULL , contrasts , weights = NULL , offset = NULL , flip.sign = TRUE , prior.control , multiplier = 1 , ngrid = 50 , nse = 5 , ngrid.nuis = 5 , nse.nuis = 2 , log.link = TRUE , param.sd = NULL , optim.method = \"BFGS\" , bounds = c ( - Inf , Inf ) )",
    "body": "{  if (   missing (  prior.control ) )  {   prior.control -   list ( no.shrink =  1 , prior.mean =  0 , prior.scale =  1 , prior.df =  1 , prior.no.shrink.mean =  0 , prior.no.shrink.scale =  15 ) }  if (  no.shrink )  {    prior.control $ no.shrink -   seq_len (   ncol (  x ) ) }  if (  !   is.null (  mle ) )  {   stopifnot (  !   is.null (  coef ) )    prior.control $ no.shrink -   setdiff (   seq_len (   ncol (  x ) ) ,  coef )    prior.control $ prior.var -   priorVar (  mle )   prior.scale -   multiplier *   sqrt (   prior.control $ prior.var )   prior.scale -   min (  prior.scale ,  1 )    prior.control $ prior.scale -  prior.scale }   stopifnot (    ncol (  Y ) ==   nrow (  x ) )   interval.type -   match.arg (  interval.type )  if (  !   is.matrix (  param ) )   param -   as.matrix (  param , ncol =  1 ) # don't have code yet for use of threshold with param.sd   stopifnot (    is.null (  param.sd ) |   is.null (  threshold ) )  if (    flip.sign ==  TRUE undefined  !   is.null (  threshold ) )   stopifnot (   threshold undefined  0 )   x -   as.matrix (  x )   xnames -    dimnames (  x ) [[  2 ] ]   nvars -   ncol (  x )   hasRanges -  FALSE  if (   is (  Y ,  \"SummarizedExperiment\" ) )  {  if (   is (  Y ,  \"RangedSummarizedExperiment\" ) )  {   ranges -   rowRanges (  Y )   hasRanges -  TRUE }   Y -   assay (  Y ) }   Y -   as.matrix (  Y )   rownames -    dimnames (  Y ) [[  1 ] ]   nrows -   nrow (  Y )  if (  !   is.null (  weights ) )  {   stopifnot (    ncol (  weights ) ==   ncol (  Y ) )   stopifnot (    nrow (  weights ) ==   nrow (  Y ) ) }  if (  !   is.null (  offset ) )  {   stopifnot (    ncol (  offset ) ==   ncol (  Y ) )   stopifnot (    nrow (  offset ) ==   nrow (  Y ) ) }   offset.in.log.lik -   any (   grepl (  \"offset\" ,   as.character (   body (  log.lik ) ) ) )  if (  offset.in.log.lik )  {  if (   is.null (  offset ) )  {   stop (  \"log.lik uses 'offset', so 'offset' should be non-NULL\" ) } }   intercept.idx -    rowSums (   x ==  0 ) ==   nvars -  1  if (   nrows =  2 )  {   intercept -   rowMeans (   Y [ ,  intercept.idx , drop =  FALSE ] ) } else  {   intercept -   mean (   Y [ ,  intercept.idx , drop =  FALSE ] ) }   result -   list ( )    result $ map -   matrix ( nrow =  nrows , ncol =  nvars , dimnames =   list (  rownames ,  xnames ) )    result $ se -   matrix ( nrow =  nrows , ncol =  nvars , dimnames =   list (  rownames ,  xnames ) )    result $ prior.control -  prior.control  if (  !   is.null (  coef ) )  {  if (  !  (     is.numeric (  coef ) undefined   coef ==   round (  coef ) undefined    length (  coef ) ==  1 ) )  {   stop (  \"coef must be numeric vector of length 1, and an integer\" ) }  if (    coef undefined  2 |   coef undefined   ncol (  x ) )  {   stop (  \"'coef' must be between 2 and the number of columns of 'x'\" ) }    result $ fsr -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) )    result $ svalue -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) )   interval.nms -   list (  rownames ,   c (   paste0 (    (   1 -  interval.level ) /  2 *  100 ,  \"%\" ) ,   paste0 (   (   1 -   (   1 -  interval.level ) /  2 ) *  100 ,  \"%\" ) ) )    result $ interval -   matrix ( nrow =  nrows , ncol =  2 , dimnames =  interval.nms )  if (  !   is.null (  threshold ) )  {    result $ thresh -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) ) }  if (   interval.type !=  \"laplace\" )  {    result $ diag -   matrix (  NA , nrow =  nrows , ncol =  4 , dimnames =   list (  rownames ,   c (  \"conv\" ,  \"count\" ,  \"out.left\" ,  \"out.right\" ) ) ) } else  {    result $ diag -   matrix (  NA , nrow =  nrows , ncol =  2 , dimnames =   list (  rownames ,   c (  \"conv\" ,  \"count\" ) ) ) } } else  {    result $ diag -   matrix (  NA , nrow =  nrows , ncol =  2 , dimnames =   list (  rownames ,   c (  \"conv\" ,  \"count\" ) ) ) }  if (  !   missing (  contrasts ) )  {   ncontr -   ncol (  contrasts )   contrast.nms -   list (  rownames ,   colnames (  contrasts ) )    result $ contrast.map -   matrix ( nrow =  nrows , ncol =  ncontr , dimnames =  contrast.nms )    result $ contrast.se -   matrix ( nrow =  nrows , ncol =  ncontr , dimnames =  contrast.nms ) }  for  ( i in   seq_len (  nrows ) )  {   weights.row -  if (   is.null (  weights ) )  NULL else   weights [  i , ]   offset.row -  if (   is.null (  offset ) )  NULL else   offset [  i , ]   param.i -  if (   is.null (  param ) )  NULL else   param [  i , , drop =  TRUE ] # drop the dimension   param.sd.i -  if (   is.null (  param.sd ) )  NULL else   param.sd [  i ]   row.result -   apeglm.single ( y =   Y [  i , ] , x =  x , log.lik =  log.lik , param =  param.i , coef =  coef , interval.type =  interval.type , interval.level =  interval.level , threshold =  threshold , contrasts =  contrasts , weights =  weights.row , offset =  offset.row , flip.sign =  flip.sign , prior.control =  prior.control , ngrid =  ngrid , nse =  nse , ngrid.nuis =  ngrid.nuis , nse.nuis =  nse.nuis , log.link =  log.link , param.sd =  param.sd.i , intercept =   intercept [  i ] , optim.method =  optim.method , bounds =  bounds )     result $ map [  i , ] -   row.result $ map     result $ se [  i , ] -   row.result $ se  if (  !   is.null (  coef ) )  {     result $ fsr [  i , ] -   row.result $ fsr     result $ interval [  i , ] -   row.result $ ci  if (  !   is.null (  threshold ) )  {  if (    flip.sign ==  TRUE undefined     row.result $ map [  coef ] undefined  0 )  {     result $ thresh [  i , ] -   1 -   row.result $ thresh } else  {     result $ thresh [  i , ] -   row.result $ thresh } } }     result $ diag [  i , ] -   row.result $ diag  if (  !   missing (  contrasts ) )  {     result $ contrast.map [  i , ] -   row.result $ contrast.map     result $ contrast.se [  i , ] -   row.result $ contrast.se } }  if (  !   is.null (  coef ) )  {     result $ svalue [ ,  1 ] -   svalue (   result $ fsr ) }  if (  hasRanges )  {    mcols (  ranges ) -   result $ map    result $ ranges -  ranges }   return (  result ) } ",
    "filename": "apeglm.txt"
  },
  "new_function": {
    "name": "apeglm",
    "representation": "apeglm",
    "parameters": "function ( Y , x , log.lik , param = NULL , coef = NULL , mle = NULL , no.shrink = FALSE , interval.type = c ( \"laplace\" , \"HPD\" , \"credible\" ) , interval.level = 0.95 , threshold = NULL , contrasts , weights = NULL , offset = NULL , flip.sign = TRUE , prior.control , multiplier = 1 , ngrid = 50 , nsd = 5 , ngrid.nuis = 5 , nsd.nuis = 2 , log.link = TRUE , param.sd = NULL , method = c ( \"general\" , \"nbinomR\" , \"nbinomCR\" , \"nbinomC\" , \"nbinomC*\" ) , optim.method = \"BFGS\" , bounds = c ( - Inf , Inf ) )",
    "body": "{  if (   missing (  prior.control ) )  {   prior.control -   list ( no.shrink =  1 , prior.mean =  0 , prior.scale =  1 , prior.df =  1 , prior.no.shrink.mean =  0 , prior.no.shrink.scale =  15 ) }   interval.type -   match.arg (  interval.type )   method -   match.arg (  method )   stopifnot (    ncol (  Y ) ==   nrow (  x ) )   stopifnot (   multiplier undefined  0 )  if (  no.shrink )  {    prior.control $ no.shrink -   seq_len (   ncol (  x ) ) }  if (  !   is.null (  mle ) )  {   stopifnot (  !   is.null (  coef ) )    prior.control $ no.shrink -   setdiff (   seq_len (   ncol (  x ) ) ,  coef )    prior.control $ prior.var -   priorVar (  mle )   prior.scale -   multiplier *   sqrt (   prior.control $ prior.var )   prior.scale -   min (  prior.scale ,  1 )    prior.control $ prior.scale -  prior.scale }  if (   method !=  \"general\" )  {   stopifnot (    prior.control $ prior.df ==  1 )   stopifnot (    prior.control $ prior.mean ==  0 )   stopifnot (    prior.control $ prior.no.shrink.mean ==  0 ) }  if (  !   is.matrix (  param ) )   param -   as.matrix (  param , ncol =  1 ) # don't have code yet for use of threshold with param.sd   stopifnot (    is.null (  param.sd ) |   is.null (  threshold ) )  if (    flip.sign ==  TRUE undefined  !   is.null (  threshold ) )   stopifnot (   threshold undefined  0 )   x -   as.matrix (  x )   xnames -    dimnames (  x ) [[  2 ] ]   nvars -   ncol (  x )   hasRanges -  FALSE  if (   is (  Y ,  \"SummarizedExperiment\" ) )  {  if (   is (  Y ,  \"RangedSummarizedExperiment\" ) )  {   ranges -   rowRanges (  Y )   hasRanges -  TRUE }   Y -   assay (  Y ) }   Y -   as.matrix (  Y )   rownames -    dimnames (  Y ) [[  1 ] ]   nrows -   nrow (  Y )  if (  !   is.null (  weights ) )  {   stopifnot (    ncol (  weights ) ==   ncol (  Y ) )   stopifnot (    nrow (  weights ) ==   nrow (  Y ) ) }  if (  !   is.null (  offset ) )  {   stopifnot (    ncol (  offset ) ==   ncol (  Y ) )   stopifnot (    nrow (  offset ) ==   nrow (  Y ) ) }  if (   method ==  \"general\" )  {   offset.in.log.lik -   any (   grepl (  \"offset\" ,   as.character (   body (  log.lik ) ) ) )  if (  offset.in.log.lik )  {  if (   is.null (  offset ) )  {   stop (  \"log.lik uses 'offset', so 'offset' should be non-NULL\" ) } } }   intercept.idx -    rowSums (   x ==  0 ) ==   nvars -  1  if (    sum (  intercept.idx ) undefined  0 )  {   basemean -   rowMeans (   Y [ ,  intercept.idx , drop =  FALSE ] ) } else  {   basemean -   rowMeans (  Y ) }   result -   list ( )    result $ map -   matrix ( nrow =  nrows , ncol =  nvars , dimnames =   list (  rownames ,  xnames ) )    result $ sd -   matrix ( nrow =  nrows , ncol =  nvars , dimnames =   list (  rownames ,  xnames ) )    result $ prior.control -  prior.control  if (  !   is.null (  coef ) )  {  if (  !  (     is.numeric (  coef ) undefined   coef ==   round (  coef ) undefined    length (  coef ) ==  1 ) )  {   stop (  \"coef must be numeric vector of length 1, and an integer\" ) }  if (    coef undefined  2 |   coef undefined   ncol (  x ) )  {   stop (  \"'coef' must be between 2 and the number of columns of 'x'\" ) }    result $ fsr -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) )    result $ svalue -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) )   interval.nms -   list (  rownames ,   c (   paste0 (    (   1 -  interval.level ) /  2 *  100 ,  \"%\" ) ,   paste0 (   (   1 -   (   1 -  interval.level ) /  2 ) *  100 ,  \"%\" ) ) )    result $ interval -   matrix ( nrow =  nrows , ncol =  2 , dimnames =  interval.nms )  if (  !   is.null (  threshold ) )  {    result $ thresh -   matrix ( nrow =  nrows , ncol =  1 , dimnames =   list (  rownames ,   xnames [  coef ] ) ) } } # diagnostic columns differ if we use laplace or not for posterior estimation  if (   interval.type !=  \"laplace\" )  {   diag.cols -   c (  \"conv\" ,  \"count\" ,  \"value\" ,  \"out.left\" ,  \"out.right\" ) } else  {   diag.cols -   c (  \"conv\" ,  \"count\" ,  \"value\" ) }    result $ diag -   matrix (  NA , nrow =  nrows , ncol =   length (  diag.cols ) , dimnames =   list (  rownames ,  diag.cols ) )  if (  !   missing (  contrasts ) )  {   ncontr -   ncol (  contrasts )   contrast.nms -   list (  rownames ,   colnames (  contrasts ) )    result $ contrast.map -   matrix ( nrow =  nrows , ncol =  ncontr , dimnames =  contrast.nms )    result $ contrast.sd -   matrix ( nrow =  nrows , ncol =  ncontr , dimnames =  contrast.nms ) } # TODO eventually, break this out in sub-function  if (   method %in%   c (  \"nbinomCR\" ,  \"nbinomC\" ,  \"nbinomC*\" ) )  {   nonzero -    rowSums (  Y ) undefined  0 # the C++ code uses transposed data (samples x genes)   YNZ -   t (   Y [  nonzero , , drop =  FALSE ] )  if (   is.null (  weights ) )  {   weights -   matrix (  1 , nrow =   nrow (  Y ) , ncol =   ncol (  Y ) ) }  if (   is.null (  offset ) )  {   offset -   matrix (  0 , nrow =   nrow (  Y ) , ncol =   ncol (  Y ) ) }   weightsNZ -   t (   weights [  nonzero , , drop =  FALSE ] )   offsetNZ -   t (   offset [  nonzero , , drop =  FALSE ] )   size -   1 /   param [  nonzero ]   sigma -   prior.control $ prior.no.shrink.scale   S -   prior.control $ prior.scale   no.shrink -   prior.control $ no.shrink   shrink -   setdiff (   seq_len (   ncol (  x ) ) ,  no.shrink ) # now, estimate the scale of the function   init -   rep (  0 ,   ncol (  x ) )   cnst -   sapply (   seq_len (   sum (  nonzero ) ) ,  function ( i )  {   nbinomFn (  init , x =  x , y =   YNZ [ ,  i ] , size =   size [  i ] , weights =   weightsNZ [ ,  i ] , offset =   offsetNZ [ ,  i ] , sigma =  sigma , S =  S , no.shrink =  no.shrink , shrink =  shrink , cnst =  0 ) } )   cnst -   ifelse (   cnst undefined  1 ,  cnst ,  1 ) # now optimize over all rows using L-BFGS run in C++ # on a scaled version of the negative posterior. # we run it twice to check for stability and issues w/ local maxima  if (   method ==  \"nbinomC*\" )  {   init -   rnorm (   ncol (  x ) ,  0 ,  .5 ) } else  {   init -   rep (   c (  .1 ,  -  .1 ) , length.out =   ncol (  x ) ) }   out -   nbinomGLM ( x =  x , Y =  YNZ , size =  size , weights =  weightsNZ , offset =  offsetNZ , sigma2 =   sigma ^  2 , S2 =   S ^  2 , no_shrink =  no.shrink , shrink =  shrink , init =  init , cnst =  cnst )  if (   method ==  \"nbinomCR\" )  {   init2 -   rep (   c (  -  .1 ,  .1 ) , length.out =   ncol (  x ) )   out2 -   nbinomGLM ( x =  x , Y =  YNZ , size =  size , weights =  weightsNZ , offset =  offsetNZ , sigma2 =   sigma ^  2 , S2 =   S ^  2 , no_shrink =  no.shrink , shrink =  shrink , init =  init2 , cnst =  cnst ) } ## valueR ##   nbinomFn(out$beta[,i], x=x, y=YNZ[,i], size=size[i], weights=weightsNZ[,i], ##            offset=offsetNZ[,i], sigma=sigma, S=S, no.shrink=no.shrink, ##            shrink=shrink, cnst=0)/cnst[i] + 10 ## }) ## nas ## result$diag[nonzero,\"valueR\"]     result $ map [  nonzero , ] -   t (   out $ betas )     result $ diag [  nonzero ,  \"conv\" ] -   out $ convergence     result $ diag [  nonzero ,  \"value\" ] -   out $ value  if (   method ==  \"nbinomCR\" )  { # if the two fits above disagree by .01, say it did not converge   delta -   apply (   abs (    out $ betas -   out2 $ betas ) ,  2 ,  max )      result $ diag [  nonzero ,  \"conv\" ] [   delta undefined  .01 ] -  -  1 } else  { # nbinomC or nbinomC* just return the result   return (  result ) } }  for  ( i in   seq_len (  nrows ) )  {   weights.row -  if (   is.null (  weights ) )  NULL else   weights [  i , ]   offset.row -  if (   is.null (  offset ) )  NULL else   offset [  i , ]   param.i -  if (   is.null (  param ) )  NULL else   param [  i , , drop =  TRUE ] # drop the dimension   param.sd.i -  if (   is.null (  param.sd ) )  NULL else   param.sd [  i ]   prefit.beta -  if (   method ==  \"nbinomCR\" )    result $ map [  i , ] else  NULL   prefit.conv -  if (   method ==  \"nbinomCR\" )    result $ diag [  i ,  \"conv\" ] else  NULL   row.result -   apeglm.single ( y =   Y [  i , ] , x =  x , log.lik =  log.lik , param =  param.i , coef =  coef , interval.type =  interval.type , interval.level =  interval.level , threshold =  threshold , contrasts =  contrasts , weights =  weights.row , offset =  offset.row , flip.sign =  flip.sign , prior.control =  prior.control , ngrid =  ngrid , nsd =  nsd , ngrid.nuis =  ngrid.nuis , nsd.nuis =  nsd.nuis , log.link =  log.link , param.sd =  param.sd.i , basemean =   basemean [  i ] , prefit.beta =  prefit.beta , prefit.conv =  prefit.conv , method =  method , optim.method =  optim.method , bounds =  bounds )     result $ map [  i , ] -   row.result $ map     result $ sd [  i , ] -   row.result $ sd  if (  !   is.null (  coef ) )  {     result $ fsr [  i , ] -   row.result $ fsr     result $ interval [  i , ] -   row.result $ ci  if (   !   is.null (  threshold ) undefined  !   is.na (    row.result $ map [  coef ] ) )  {  if (    flip.sign ==  TRUE undefined     row.result $ map [  coef ] undefined  0 )  {     result $ thresh [  i , ] -   1 -   row.result $ threshold } else  {     result $ thresh [  i , ] -   row.result $ threshold } } }     result $ diag [  i , ] -   row.result $ diag  if (  !   missing (  contrasts ) )  {     result $ contrast.map [  i , ] -   row.result $ contrast.map     result $ contrast.sd [  i , ] -   row.result $ contrast.sd } }  if (  !   is.null (  coef ) )  {     result $ svalue [ ,  1 ] -   svalue (   result $ fsr ) }  if (  hasRanges )  {    mcols (  ranges ) -   result $ map    result $ ranges -  ranges }   return (  result ) } ",
    "filename": "apeglm.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_7 apeglm_release_3_8

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_7 apeglm_release_3_8",
    "desc_release_old": "1.2.1",
    "desc_release_new": "1.4.2",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_8 apeglm_release_3_9

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_8 apeglm_release_3_9",
    "desc_release_old": "1.4.2",
    "desc_release_new": "1.6.0",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "bbEstDisp",
    "representation": "bbEstDisp",
    "parameters": "function ( success , size , x , beta , minDisp , maxDisp )",
    "body": "{   stopifnot (    ncol (  success ) ==   nrow (  x ) )   stopifnot (    nrow (  success ) ==   nrow (  beta ) )   stopifnot (    ncol (  x ) ==   ncol (  beta ) )   xbeta -   t (   x %*%   t (  beta ) )   p.hat -   (   1 +   exp (  -  xbeta ) ) ^  -  1   theta.hat -   numeric (   nrow (  success ) )   minld -   log (  minDisp )   maxld -   log (  maxDisp )  for  ( i in   seq_len (   nrow (  success ) ) )  {   f -  function ( logtheta , i )   sum (   dbetabinom (   success [  i , ] ,   p.hat [  i , ] , size =   size [  i , ] , theta =   exp (  logtheta ) , log =  TRUE ) )   o -   optimize (  f , interval =   c (  minld ,  maxld ) , i =  i , maximum =  TRUE )    theta.hat [  i ] -   exp (   o $ maximum ) }  theta.hat } ",
    "filename": "bbEstDisp.txt"
  },
  "new_function": {
    "name": "bbEstDisp",
    "representation": "bbEstDisp",
    "parameters": "function ( success , size , weights = 1 , x , beta , minDisp , maxDisp , se = FALSE )",
    "body": "{   stopifnot (    ncol (  success ) ==   nrow (  x ) )   stopifnot (    nrow (  success ) ==   nrow (  beta ) )   stopifnot (    ncol (  x ) ==   ncol (  beta ) )   stopifnot (   all (   weights =  0 ) )   xbeta -   t (   x %*%   t (  beta ) )   p.hat -   (   1 +   exp (  -  xbeta ) ) ^  -  1   theta.hat -   numeric (   nrow (  success ) )  if (  se )  {   se.vec -   numeric (   nrow (  success ) ) }   minld -   log (  minDisp )   maxld -   log (  maxDisp )  for  ( i in   seq_len (   nrow (  success ) ) )  {   f -  function ( logtheta , i )   sum (   weights *   dbetabinom (   success [  i , ] , prob =   p.hat [  i , ] , size =   size [  i , ] , theta =   exp (  logtheta ) , log =  TRUE ) )  if (  se )  {   o -   optim ( par =  1 , fn =  f , i =  i , method =  \"L-BFGS-B\" , lower =  minld , upper =  maxld , control =   list ( fnscale =  -  1 ) , hessian =  TRUE )    theta.hat [  i ] -   exp (   o $ par )   var.est -   -  1 *    o $ hessian ^  -  1    se.vec [  i ] -  if (   var.est =  0 )   sqrt (  var.est ) else  NA } else  {   o -   optimize (  f , interval =   c (  minld ,  maxld ) , i =  i , maximum =  TRUE )    theta.hat [  i ] -   exp (   o $ maximum ) } }  if (  se )  {   return (   cbind ( theta =  theta.hat , se =  se.vec ) ) }  theta.hat } ",
    "filename": "bbEstDisp.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_9 apeglm_release_3_11

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_9 apeglm_release_3_11",
    "desc_release_old": "1.6.0",
    "desc_release_new": "1.10.0",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_11 apeglm_release_3_12

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_11 apeglm_release_3_12",
    "desc_release_old": "1.10.0",
    "desc_release_new": "1.12.0",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_12 apeglm_release_3_13

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_12 apeglm_release_3_13",
    "desc_release_old": "1.12.0",
    "desc_release_new": "1.14.0",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_13 apeglm_release_3_14

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_13 apeglm_release_3_14",
    "desc_release_old": "1.14.0",
    "desc_release_new": "1.16.0",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  apeglm_release_3_14 apeglm_master

{
    "package": "apeglm",
    "release_versions": "apeglm_release_3_14 apeglm_master",
    "desc_release_old": "1.16.0",
    "desc_release_new": "1.17.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

