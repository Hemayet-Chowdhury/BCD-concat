
###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_3 iranges_release_2_4

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_3 iranges_release_2_4",
    "desc_release_old": "1.0.16",
    "desc_release_new": "1.2.3",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 7,
    "function_additions": 107,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 9,
    "total_count": 16
}

##########
Functions Removed
##########

GenomicData
SplitXDataFrame
strand
genome
annotation
chrom
elements


##########
Functions Added
##########

isConstant
normargShift
normargWeight
solveUserSEW0
updateRangedData
AnnotatedList
XRaw
updateTypedList
LogicalList
IntegerList
NumericList
ComplexList
CharacterList
RawList
RleList
XDataFrameList
SplitXDataFrameList
coverage.normargWidth
coverage.isCalledWithStartEndInterface
coverage.getShift0FromStartEnd
coverage.getWidthFromStartEnd
mid
threebands
nearest
precede
follow
reflect
flank
pgap
disjoin
disjointBins
score
Rle
runLength
runValue
nrun
runLength<-
runValue<-
shiftApply
findRange
findRun
isDisjoint
subseq<-
viewApply
viewWhichMins
viewWhichMaxs
viewRangeMins
viewRangeMaxs
table
universe
universe<-
space
elementLengths
metadata
elementMetadata
metadata<-
elementMetadata<-
Ops
Math
Math2
Summary
Complex
unique
<=
>=
<
>
order
sort
rank
rev
rep.int
head
tail
range
pmax
pmin
pmax.int
pmin.int
diff
mean
var
cov
cor
sd
median
quantile
mad
window
aggregate
nchar
substr
substring
chartr
tolower
toupper
sub
gsub
as.logical
as.numeric
as.complex
as.character
as.raw
as.factor
!
which
is.na


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "IRanges",
    "parameters": "function ( x , start = NA , end = NA , weight = 1L )",
    "body": "{  if (  !   isSingleNumber (  start ) )   stop (  \"'start' must be a single integer\" )  if (  !   is.integer (  start ) )   start -   as.integer (  start )  if (  !   isSingleNumber (  end ) )   stop (  \"'end' must be a single integer\" )  if (  !   is.integer (  end ) )   end -   as.integer (  end )   width -    end -  start +  1L  if (   width undefined  0 )   stop (  \"'end' must be )  if (   !   is.numeric (  weight ) ||  !  (    length (  weight ) %in%   c (  1 ,   length (  x ) ) ) )   stop (  \"'weight' must be an integer vector with length 1 or 'length(x)'\" )  if (  !   is.integer (  weight ) )   weight -   as.integer (  weight )   x1 -   shift (   restrict (  x , start =  start , end =  end ) ,   1L -  start )   .Call (  \"IRanges_coverage\" ,  x1 ,  weight ,   order (   start (  x1 ) ) ,  width , PACKAGE =  \"IRanges\" ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "IRanges",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start )   width -   coverage.getWidthFromStartEnd (  end ,  shift ) } else  {   width -   coverage.normargWidth (  width ,   length (  x ) ) } #shift   weight -   coverage.normargWeight (  weight ,   length (  x ) )   sx -   shift (  x ,  shift )  if (   is.null (  width ) )  {   width -   max (   end (  sx ) ) ## By keeping all ranges, 'rsx' and 'weight' remain of the same ## length and the pairing between their elements is preserved.   rsx -   restrict (  sx , start =  1L , keep.all.ranges =  TRUE ) } else  {   rsx -   restrict (  sx , start =  1L , end =  width , keep.all.ranges =  TRUE ) }  if (   width =  0L ) # could be   return (   Rle ( ) )   .IRanges.coverage (  rsx ,  width ,  weight ) } ",
    "filename": "coverage.txt"
  }
}

1.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskCollection",
    "parameters": "function ( x , start = NA , end = NA , weight = 1L )",
    "body": "{  if (  !   isSingleNumberOrNA (  start ) )   stop (  \"'start' must be a single integer or NA\" )  if (  !   is.integer (  start ) )   start -   as.integer (  start )  if (   is.na (  start ) )   start -  1L  if (  !   isSingleNumberOrNA (  end ) )   stop (  \"'end' must be a single integer or NA\" )  if (  !   is.integer (  end ) )   end -   as.integer (  end )  if (   is.na (  end ) )   end -   width (  x )   width -    end -  start +  1L  if (   width undefined  0 )   stop (  \"'end' must be )  if (  !   is.numeric (  weight ) )   stop (  \"'weight' must be an integer vector\" )  if (  !   is.integer (  weight ) )   weight -   as.integer (  weight )  if (    length (  weight ) !=   length (  x ) )  {  if (     length (  weight ) undefined  1 ||    length (  weight ) undefined   length (  x ) )   stop (  \"'length(weight)' must be )   weight -   rep (  weight , length.out =   length (  x ) ) }   ans -   new (  \"XRleInteger\" , values =   XInteger (  1 ,  0L ) , lengths =   XInteger (  1 ,  width ) )  for  ( i in   seq_len (   length (  x ) ) )  {   x1 -   shift (   restrict (   x [[  i ] ] , start =  start , end =  end ) ,   1L -  start )   ans -   ans +   .Call (  \"IRanges_coverage\" ,  x1 ,   weight [  i ] ,   order (   start (  x1 ) ) ,  width , PACKAGE =  \"IRanges\" ) }  ans } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskCollection",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start )   width -   coverage.getWidthFromStartEnd (  end ,  shift ) } else  {   width -   coverage.normargWidth (  width ,   length (  x ) ) }   shift -   normargShift (  shift ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )  if (   is.null (  width ) )   width -   width (  mymasks )  if (   width =  0L ) # should never be   return (   Rle ( ) )   ans -   new (  \"Rle\" , values =  0L , lengths =  width )  for  ( i in   seq_len (   length (  x ) ) )  {   nir -   x [[  i ] ]  if (   isEmpty (  nir ) )   next ( )   snir -   shift (  nir ,   shift [  i ] )   rsnir -   restrict (  snir , start =  1L , end =  width )   ans -   ans +   .IRanges.coverage (  rsnir ,  width ,   weight [  i ] ) }  ans } ",
    "filename": "coverage.txt"
  }
}

2.
{
  "old_function": {
    "name": "matchMatrix",
    "representation": "matchMatrix",
    "signature": "RangesMatching",
    "parameters": "function ( object )",
    "body": "object @ matchMatrix",
    "filename": "RangesMatching-class.txt"
  },
  "new_function": {
    "name": "matchMatrix",
    "representation": "matchMatrix",
    "signature": "RangesMatching",
    "parameters": "function ( x )",
    "body": "x @ matchMatrix",
    "filename": "RangesMatching-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "solveUserSEW",
    "representation": "solveUserSEW",
    "parameters": "function ( refwidths , start = NA , end = NA , width = NA , translate.nonpositive.coord = TRUE , allow.nonnarrowing = FALSE )",
    "body": "{  if (  !   is.numeric (  refwidths ) )   stop (  \"'refwidths' must be a vector of integers\" )  if (  !   is.integer (  refwidths ) )   refwidths -   as.integer (  refwidths )   start -   normargIntegerOrNA (  start ,  \"start\" )   end -   normargIntegerOrNA (  end ,  \"end\" )   width -   normargIntegerOrNA (  width ,  \"width\" ) ## From here, 'refwidths', 'start', 'end' and 'width' are guaranteed to be ## integer vectors. NAs in 'start', 'end' and 'width' are OK but not in ## 'refwidths' so this needs to be checked by C function solve_user_SEW().   l1 -   length (  start )   l2 -   length (  end )   l3 -   length (  width )   min123 -   min (  l1 ,  l2 ,  l3 )   max123 -   max (  l1 ,  l2 ,  l3 )  if (    length (  refwidths ) ==  0 )  {  if (    max123 !=  min123 ||   max123 undefined  1 )   stop (  \"'start', 'end' and 'width' must have the same length \" ,  \"and it must be 0 or 1 when 'refwidths' is empty\" ) } else  {  if (   max123 undefined   length (  refwidths ) )   stop (  \"'start', 'end' or 'width' has more elements than 'refwidths'\" )  if (   min123 ==  0 )   stop (  \"'start', 'end' or 'width' is empty but 'refwidths' is not\" ) }  if (  !   isTRUEorFALSE (  translate.nonpositive.coord ) )   stop (  \"'translate.nonpositive.coord' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  allow.nonnarrowing ) )   stop (  \"'allow.nonnarrowing' must be TRUE or FALSE\" )   .Call (  \"solve_user_SEW\" ,  refwidths ,  start ,  end ,  width ,  translate.nonpositive.coord ,  allow.nonnarrowing , PACKAGE =  \"IRanges\" ) } ",
    "filename": "solveUserSEW.txt"
  },
  "new_function": {
    "name": "solveUserSEW",
    "representation": "solveUserSEW",
    "parameters": "function ( refwidths , start = NA , end = NA , width = NA , translate.negative.coord = TRUE , allow.nonnarrowing = FALSE )",
    "body": "{  if (  !   is.numeric (  refwidths ) )   stop (  \"'refwidths' must be a vector of integers\" )  if (  !   is.integer (  refwidths ) )   refwidths -   as.integer (  refwidths )   start -   .normargSEW (  start ,  \"start\" )   end -   .normargSEW (  end ,  \"end\" )   width -   .normargSEW (  width ,  \"width\" ) ## From here, 'refwidths', 'start', 'end' and 'width' are guaranteed to be ## integer vectors. NAs in 'start', 'end' and 'width' are OK but not in ## 'refwidths' so this needs to be checked by C function solve_user_SEW().   l1 -   length (  start )   l2 -   length (  end )   l3 -   length (  width )   min123 -   min (  l1 ,  l2 ,  l3 )   max123 -   max (  l1 ,  l2 ,  l3 )  if (    length (  refwidths ) ==  0L )  {  if (    max123 !=  min123 ||   max123 undefined  1L )   stop (  \"'start', 'end' and 'width' must have the same length \" ,  \"and it must be 0 or 1 when 'refwidths' is empty\" ) } else  {  if (   max123 undefined   length (  refwidths ) )   stop (  \"'start', 'end' or 'width' has more elements than 'refwidths'\" )  if (   min123 ==  0L )   stop (  \"'start', 'end' or 'width' is empty but 'refwidths' is not\" ) }  if (  !   isTRUEorFALSE (  translate.negative.coord ) )   stop (  \"'translate.negative.coord' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  allow.nonnarrowing ) )   stop (  \"'allow.nonnarrowing' must be TRUE or FALSE\" )   .Call (  \"solve_user_SEW\" ,  refwidths ,  start ,  end ,  width ,  translate.negative.coord ,  allow.nonnarrowing , PACKAGE =  \"IRanges\" ) } ",
    "filename": "IRanges-constructor.txt"
  }
}

4.
{
  "old_function": {
    "name": "newViews",
    "representation": "newViews",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL , Class = NULL )",
    "body": "{  if (   !   isNumericOrNAs (  start ) ||  !   isNumericOrNAs (  end ) )   stop (  \"'start' and 'end' must be numeric vectors\" )  if (  !   is.integer (  start ) )   start -   as.integer (  start )    start [   is.na (  start ) ] -  1L  if (  !   is.integer (  end ) )   end -   as.integer (  end )    end [   is.na (  end ) ] -   length (  subject )  if (    length (  start ) undefined   length (  end ) )   start -   recycleVector (  start ,   length (  end ) ) else  if (    length (  end ) undefined   length (  start ) )   end -   recycleVector (  end ,   length (  start ) )  if (  !   all (   start =  end ) )   stop (  \"'start' and 'end' must verify 'start )   width -    end -  start +  1L ## 'start' and 'with' are guaranteed to be valid.  if (   is.null (  Class ) )   Class -   paste (   class (  subject ) ,  \"Views\" , sep =  \"\" )   ans -   new2 (  Class , subject =  subject , start =  start , width =  width , check =  FALSE )    names (  ans ) -  names  ans } ",
    "filename": "Views-class.txt"
  },
  "new_function": {
    "name": "newViews",
    "representation": "newViews",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL , Class = NULL )",
    "body": "{  if (   is (  start ,  \"IRanges\" ) )  {  if (   !   is.null (  end ) ||  !   is.null (  width ) )   stop (  \"'end' and 'width' must be NULLs when 'start' is an IRanges object\" )   ir -  start ## Keep names in 'ir' unless 'names' is specified.  if (  !   is.null (  names ) )    names (  ir ) -  names } else  {   ir -   IRanges ( start =  start , end =  end , width =  width , names =  names ) }  if (     length (   width (  ir ) ) !=  0L undefined    min (   width (  ir ) ) =  0L )   stop (  \"null widths are not allowed\" )  if (   is.null (  Class ) )   Class -   paste (   class (  subject ) ,  \"Views\" , sep =  \"\" ) #new2(Class, ir, subject=subject, check=FALSE)  # gives me an infinite recursion!   new2 (  Class , subject =  subject , start =   start (  ir ) , width =   width (  ir ) , NAMES =   names (  ir ) , check =  FALSE ) } ",
    "filename": "Views-class.txt"
  }
}

5.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XInteger",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , names = names , Class = \"XIntegerViews\" )",
    "filename": "XIntegerViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XInteger",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , width = width , names = names , Class = \"XIntegerViews\" )",
    "filename": "XIntegerViews-class.txt"
  }
}

6.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "integer",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "{   xsubject -   XInteger (   length (  subject ) ,  subject )   Views (  xsubject , start =  start , end =  end , names =  names ) } ",
    "filename": "XIntegerViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "integer",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "{   xsubject -   as (  subject ,  \"XInteger\" )   Views (  xsubject , start =  start , end =  end , width =  width , names =  names ) } ",
    "filename": "XIntegerViews-class.txt"
  }
}

7.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XRleInteger",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , names = names , Class = \"XRleIntegerViews\" )",
    "filename": "XRleIntegerViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "XRleInteger",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "newViews ( subject , start = start , end = end , width = width , names = names , Class = \"XRleIntegerViews\" )",
    "filename": "XRleIntegerViews-class.txt"
  }
}

8.
{
  "old_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "integer",
    "parameters": "function ( subject , start = NA , end = NA , names = NULL )",
    "body": "{   xsubject -   XRleInteger (  subject )   Views (  xsubject , start =  start , end =  end , names =  names ) } ",
    "filename": "XRleIntegerViews-class.txt"
  },
  "new_function": {
    "name": "Views",
    "representation": "Views",
    "signature": "integer",
    "parameters": "function ( subject , start = NULL , end = NULL , width = NULL , names = NULL )",
    "body": "{   xsubject -   as (  subject ,  \"XInteger\" )   Views (  xsubject , start =  start , end =  end , width =  width , names =  names ) } ",
    "filename": "XIntegerViews-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_4 iranges_release_2_5

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_4 iranges_release_2_5",
    "desc_release_old": "1.2.3",
    "desc_release_new": "1.4.16",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 20,
    "function_additions": 83,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 20
}

##########
Functions Removed
##########

sapplyLength
updateRangedData
AnnotatedList
RawPtr
RawPtr.readInts
RawPtr.writeInts
RawPtr.read
RawPtr.write
RawPtr.copy
RawPtr.reverseCopy
RawPtr.readComplexes
RawPtr.append
RawPtr.compare
XDataFrame
XRleInteger
updateTypedList
XDataFrameList
SplitXDataFrameList
elementClass
Arith


##########
Functions Added
##########

strsplitAsListOfIntegerVectors
H2LGrouping
Dups
PartitioningByEnd
PartitioningByWidth
Binning
RleViewsList
SharedVector.compare
SharedVector.copy
SharedRaw
SharedRaw.readInts
SharedRaw.writeInts
SharedRaw.read
SharedRaw.write
SharedRaw.readComplexes
XDouble
SimpleList
DataFrame
DataFrameList
SplitDataFrameList
endoapply
mendoapply
seqextract
seqselect
seqselect<-
mapply
Map
resize
findOverlaps
countOverlaps
countOverlap
nobj
grouplength
members
vmembers
togroup
togrouplength
high2low
low2high
grouprank
togrouprank
as.env
xvcopy
collapse
ranges<-
values<-
runmean
runsum
runwtsum
runq
viewMeans
xtabs
score<-
elementType
queryHits
subjectHits
length<-
nrow
NROW
ncol
NCOL
dim
rownames
colnames
dimnames
rownames<-
colnames<-
dimnames<-
IQR
smoothEnds
runmed
subset
window<-
levels
levels<-
with
by
match
Reduce
Filter
Find
Position
updateObject


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_5 iranges_release_2_6

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_5 iranges_release_2_6",
    "desc_release_old": "1.4.16",
    "desc_release_new": "1.6.17",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 10,
    "function_additions": 20,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 23,
    "total_count": 33
}

##########
Functions Removed
##########

coverage.isCalledWithStartEndInterface
coverage.getShift0FromStartEnd
coverage.getWidthFromStartEnd
seqextract
first
last
intToRanges
intToAdjacentRanges
toNormalIRanges
views


##########
Functions Added
##########

svn.time
RangedSelection
seqapply
mseqapply
tseqapply
seqsplit
subsetByOverlaps
paste
ngap
columnMetadata
columnMetadata<-
tapply
is.unsorted
nlevels
stack
splitRanges
within
na.omit
na.exclude
complete.cases


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "numeric",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start )   width -   coverage.getWidthFromStartEnd (  end ,  shift ) } else  {   width -   coverage.normargWidth (  width ,   length (  x ) ) }   shift -   normargShift (  shift ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )  if (  !   is.integer (  x ) )   x -   as.integer (  x )  if (   any (   is.na (  x ) ) )   stop (  \"'x' contains NAs\" )   sx -   x +  shift  if (   is.null (  width ) )  {   width -   max (  sx )   ii -   which (   1L =  sx ) } else  {   ii -   which (    1L =  sx undefined   sx =  width ) }  if (   width =  0L ) # could be   return (   Rle ( ) ) ## Restrict 'sx' (i.e. keep   rsx -   sx [  ii ]   rw -   weight [  ii ]   Rle (   sapply (   seq_len (  width ) ,  function ( i )   sum (   rw [   rsx ==  i ] ) ) ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "numeric",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{   shift -   normargShift (  shift ,   length (  x ) )   width -   coverage.normargWidth (  width ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )  if (  !   is.integer (  x ) )   x -   as.integer (  x )  if (   anyMissing (  x ) )   stop (  \"'x' contains NAs\" )   sx -   x +  shift  if (   is.null (  width ) )  {   width -   max (  sx )   ii -   which (   1L =  sx ) } else  {   ii -   which (    1L =  sx undefined   sx =  width ) }  if (   width =  0L ) # could be   return (   Rle ( ) ) ## Restrict 'sx' (i.e. keep   rsx -   sx [  ii ]   rw -   weight [  ii ]   Rle (   sapply (   seq_len (  width ) ,  function ( i )   sum (   rw [   rsx ==  i ] ) ) ) } ",
    "filename": "coverage.txt"
  }
}

1.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "IRanges",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start )   width -   coverage.getWidthFromStartEnd (  end ,  shift ) } else  {   width -   coverage.normargWidth (  width ,   length (  x ) ) } #shift   weight -   coverage.normargWeight (  weight ,   length (  x ) )   sx -   shift (  x ,  shift )  if (   is.null (  width ) )  {   width -   max (   end (  sx ) ) ## By keeping all ranges, 'rsx' and 'weight' remain of the same ## length and the pairing between their elements is preserved.   rsx -   restrict (  sx , start =  1L , keep.all.ranges =  TRUE ) } else  {   rsx -   restrict (  sx , start =  1L , end =  width , keep.all.ranges =  TRUE ) }  if (   width =  0L ) # could be   return (   Rle ( ) )   .IRanges.coverage (  rsx ,  width ,  weight ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "IRanges",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{ #shift   width -   coverage.normargWidth (  width ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )   sx -   shift (  x ,  shift )  if (   is.null (  width ) )  {   width -   max (   end (  sx ) ) ## By keeping all ranges, 'rsx' and 'weight' remain of the same ## length and the pairing between their elements is preserved.   rsx -   restrict (  sx , start =  1L , keep.all.ranges =  TRUE ) } else  {   rsx -   restrict (  sx , start =  1L , end =  width , keep.all.ranges =  TRUE ) }  if (   width =  0L ) # could be   return (   Rle ( ) )   .IRanges.coverage (  rsx ,  width ,  weight ) } ",
    "filename": "coverage.txt"
  }
}

2.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "Views",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start ) }  if (   is.null (  width ) )   width -    length (   subject (  x ) ) +   max (  shift )   coverage (   as (  x ,  \"IRanges\" ) , start =  start , end =  end , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "Views",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   is.null (  width ) )   width -    length (   subject (  x ) ) +   max (  shift )   coverage (   as (  x ,  \"IRanges\" ) , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "coverage.txt"
  }
}

3.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskCollection",
    "parameters": "function ( x , start = NA , end = NA , shift = 0L , width = NULL , weight = 1L )",
    "body": "{  if (   coverage.isCalledWithStartEndInterface (  start ,  end ,  shift ,  width ) )  { ## From here, 'start' and 'end' cannot be single NAs   shift -   coverage.getShift0FromStartEnd (  start )   width -   coverage.getWidthFromStartEnd (  end ,  shift ) } else  {   width -   coverage.normargWidth (  width ,   length (  x ) ) }   shift -   normargShift (  shift ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )  if (   is.null (  width ) )   width -   width (  mymasks )  if (   width =  0L ) # should never be   return (   Rle ( ) )   ans -   new2 (  \"Rle\" , values =  0L , lengths =  width , check =  FALSE )  for  ( i in   seq_len (   length (  x ) ) )  {   nir -   x [[  i ] ]  if (   isEmpty (  nir ) )   next ( )   snir -   shift (  nir ,   shift [  i ] )   rsnir -   restrict (  snir , start =  1L , end =  width )   ans -   ans +   .IRanges.coverage (  rsnir ,  width ,   weight [  i ] ) }  ans } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "MaskCollection",
    "parameters": "function ( x , shift = 0L , width = NULL , weight = 1L )",
    "body": "{   shift -   normargShift (  shift ,   length (  x ) )   width -   coverage.normargWidth (  width ,   length (  x ) )   weight -   coverage.normargWeight (  weight ,   length (  x ) )  if (   is.null (  width ) )   width -   width (  mymasks )  if (   width =  0L ) # should never be   return (   Rle ( ) )   ans -   new2 (  \"Rle\" , values =  0L , lengths =  width , check =  FALSE )  for  ( i in   seq_len (   length (  x ) ) )  {   nir -   x [[  i ] ]  if (   isEmpty (  nir ) )   next ( )   snir -   shift (  nir ,   shift [  i ] )   rsnir -   restrict (  snir , start =  1L , end =  width )   ans -   ans +   .IRanges.coverage (  rsnir ,  width ,   weight [  i ] ) }  ans } ",
    "filename": "coverage.txt"
  }
}

4.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "RangesList",
    "parameters": "function ( x , start = structure ( rep ( list ( NA ) , length ( x ) ) , names = names ( x ) ) , end = structure ( rep ( list ( NA ) , length ( x ) ) , names = names ( x ) ) , shift = structure ( rep ( list ( 0L ) , length ( x ) ) , names = names ( x ) ) , width = structure ( rep ( list ( NULL ) , length ( x ) ) , names = names ( x ) ) , weight = structure ( rep ( list ( 1L ) , length ( x ) ) , names = names ( x ) ) )",
    "body": "{   indices -   names (  x )  if (   is.null (  indices ) )   indices -   seq_len (   length (  x ) ) else    names (  indices ) -  indices   newSimpleList (  \"SimpleRleList\" ,   lapply (  indices ,  function ( i )  {   coverage (   as (   x [[  i ] ] ,  \"IRanges\" ) , start =   start [[  i ] ] , end =   end [[  i ] ] , shift =   shift [[  i ] ] , width =   width [[  i ] ] , weight =   weight [[  i ] ] ) } ) , metadata =   metadata (  x ) , elementMetadata =   elementMetadata (  x ) ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "RangesList",
    "parameters": "function ( x , shift = structure ( rep ( list ( 0L ) , length ( x ) ) , names = names ( x ) ) , width = structure ( rep ( list ( NULL ) , length ( x ) ) , names = names ( x ) ) , weight = structure ( rep ( list ( 1L ) , length ( x ) ) , names = names ( x ) ) )",
    "body": "{   lx -   length (  x )  if (    lx !=  0 undefined  (   (   !   is.list (  shift ) undefined  !   is (  shift ,  \"IntegerList\" ) ) ||    length (  shift ) ==  0 ) )   stop (  \"'shift' must be a non-empty list of integers\" )  if (    length (  shift ) undefined  lx )   shift -   rep (  shift , length.out =  lx )  if (    lx !=  0 undefined  (   (   !   is.list (  width ) undefined  !   is (  width ,  \"IntegerList\" ) ) ||    length (  width ) ==  0 ) )   stop (  \"'width' must be a non-empty list\" )  if (    length (  width ) undefined  lx )   width -   rep (  width , length.out =  lx )  if (    lx !=  0 undefined  (   (   !   is.list (  weight ) undefined  !   is (  weight ,  \"IntegerList\" ) ) ||    length (  weight ) ==  0 ) )   stop (  \"'weight' must be a non-empty list of integers\" )  if (    length (  weight ) undefined  lx )   weight -   rep (  weight , length.out =  lx )   indices -   names (  x )  if (   is.null (  indices ) )  {   indices -   seq_len (  lx ) } else  {  if (   is.null (   names (  shift ) ) )    names (  shift ) -  indices  if (    length (   setdiff (   names (  shift ) ,  indices ) ) undefined  0 )   stop (  \"'x' and 'shift' have mismatching names\" )  if (   is.null (   names (  width ) ) )    names (  width ) -  indices  if (    length (   setdiff (   names (  width ) ,  indices ) ) undefined  0 )   stop (  \"'x' and 'width' have mismatching names\" )  if (   is.null (   names (  weight ) ) )    names (  weight ) -  indices  if (    length (   setdiff (   names (  weight ) ,  indices ) ) undefined  0 )   stop (  \"'x' and 'weight' have mismatching names\" )    names (  indices ) -  indices }   newSimpleList (  \"SimpleRleList\" ,   lapply (  indices ,  function ( i )  {   coverage (   as (   x [[  i ] ] ,  \"IRanges\" ) , shift =   shift [[  i ] ] , width =   width [[  i ] ] , weight =   weight [[  i ] ] ) } ) , metadata =   metadata (  x ) , elementMetadata =   elementMetadata (  x ) ) } ",
    "filename": "coverage.txt"
  }
}

5.
{
  "old_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "RangedData",
    "parameters": "function ( x , start = structure ( rep ( list ( NA ) , length ( x ) ) , names = names ( x ) ) , end = structure ( rep ( list ( NA ) , length ( x ) ) , names = names ( x ) ) , shift = structure ( rep ( list ( 0L ) , length ( x ) ) , names = names ( x ) ) , width = structure ( rep ( list ( NULL ) , length ( x ) ) , names = names ( x ) ) , weight = structure ( rep ( list ( 1L ) , length ( x ) ) , names = names ( x ) ) )",
    "body": "{   ranges -   ranges (  x )  if (    length (   metadata (  x ) ) undefined  0 )    metadata (  ranges ) -   metadata (  x )  if (  !   is.null (   elementMetadata (  x ) ) )    elementMetadata (  x ) -   elementMetadata (  x )   varnames -   colnames (  x )  if (    isSingleString (  start ) undefined  (   start %in%  varnames ) )   start -    values (  x ) [ ,  start ]  if (    isSingleString (  end ) undefined  (   end %in%  varnames ) )   end -    values (  x ) [ ,  end ]  if (    isSingleString (  shift ) undefined  (   shift %in%  varnames ) )   shift -    values (  x ) [ ,  shift ]  if (    isSingleString (  width ) undefined  (   width %in%  varnames ) )   width -    values (  x ) [ ,  width ]  if (    isSingleString (  weight ) undefined  (   weight %in%  varnames ) )   weight -    values (  x ) [ ,  weight ]   coverage (  ranges , start =  start , end =  end , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "coverage.txt"
  },
  "new_function": {
    "name": "coverage",
    "representation": "coverage",
    "signature": "RangedData",
    "parameters": "function ( x , shift = structure ( rep ( list ( 0L ) , length ( x ) ) , names = names ( x ) ) , width = structure ( rep ( list ( NULL ) , length ( x ) ) , names = names ( x ) ) , weight = structure ( rep ( list ( 1L ) , length ( x ) ) , names = names ( x ) ) )",
    "body": "{   ranges -   ranges (  x )  if (    length (   metadata (  x ) ) undefined  0 )    metadata (  ranges ) -   metadata (  x )  if (  !   is.null (   elementMetadata (  x ) ) )    elementMetadata (  x ) -   elementMetadata (  x )   varnames -   colnames (  x )  if (    isSingleString (  shift ) undefined  (   shift %in%  varnames ) )   shift -    values (  x ) [ ,  shift ]  if (    isSingleString (  width ) undefined  (   width %in%  varnames ) )   width -    values (  x ) [ ,  width ]  if (    isSingleString (  weight ) undefined  (   weight %in%  varnames ) )   weight -    values (  x ) [ ,  weight ]   coverage (  ranges , shift =  shift , width =  width , weight =  weight ) } ",
    "filename": "coverage.txt"
  }
}

6.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  IntervalTree )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "{   query -   as (  query ,  \"IRanges\" )   query_ord -  NULL  if (   is.unsorted (   start (  query ) ) )  { ## query must be sorted   query_ord -   order (  query )   query -   query [  query_ord ] }  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be logical of length 1\" )  if (   maxgap !=  0 )  {  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0 )   stop (  \"'maxgap' must be a single, non-negative, non-NA number\" ) ## Another option would be to do ##   query ##                          end = end(query) + maxgap) ## instead of the 2 lines below. More readable? (but maybe not as ## efficient)   query -   shift (  query ,  -  maxgap )    width (  query ) -    width (  query ) +   2 *  maxgap # adds to end (weird...) }   fun -  \"overlap\"  if (  multiple )   fun -   paste (  fun ,  \"_multiple\" , sep =  \"\" )   validObject (  query )   result -   .IntervalTreeCall (  subject ,  fun ,  query )  if (  !   is.null (  query_ord ) )  {  if (  multiple )  {   mat -   matchMatrix (  result )    mat [ ,  1 ] -   query_ord [   mat [ ,  1 ] ]    result @ matchMatrix -  mat } else  {   query_rev_ord -   integer (   length (  query_ord ) )    query_rev_ord [  query_ord ] -   seq_along (  query_ord )   result -   result [  query_rev_ord ] } }  result } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  IntervalTree )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0L )   stop (  \"'maxgap' must be a single, non-negative integer\" )  if (   !   isSingleNumber (  minoverlap ) ||   minoverlap undefined  1L )   stop (  \"'minoverlap' must be a single, positive integer\" )   type -   match.arg (  type )   select -   match.arg (  select )   origSelect -  select  if (    type !=  \"any\" ||   minoverlap undefined  1L )   select -  \"all\"   query -   as (  query ,  \"IRanges\" )   query_ord -  NULL   origQuery -  query   adjust -    maxgap -  minoverlap +  1L  if (   adjust undefined  0L )   query -   resize (  query ,    width (  query ) +   2L *  adjust , fix =  \"center\" )   unsortedQuery -  query  if (   isNotSorted (   start (  query ) ) )  { ## query must be sorted   query_ord -   sort.list (   start (  query ) , method =  \"quick\" , na.last =  NA )   query -   query [  query_ord ] } else  {   query_ord -   seq_len (   length (  query ) ) }   validObject (  query )   fun -   paste (  \"overlap_\" ,  select , sep =  \"\" )   result -   .IntervalTreeCall (  subject ,  fun ,  query ,  query_ord )  if (    type !=  \"any\" ||   minoverlap undefined  1L )  {   m -   as.matrix (  result )  if (   minoverlap undefined  1L )  {   r -   ranges (  result ,  unsortedQuery ,  subject )   m -   m [    width (  r ) =  minoverlap , , drop =  FALSE ]    result @ matchMatrix -  m }   query -  origQuery   filterMatrix -  function ( fun )   m [    abs (     fun (  query ) [   m [ ,  1L ] ] -    fun (  subject ) [   m [ ,  2L ] ] ) =  maxgap , , drop =  FALSE ]  if (   type ==  \"within\" )  {   r -   ranges (  result ,  query ,  subject )   m -   m [      width (  query ) [   m [ ,  1L ] ] -   width (  r ) =  maxgap , , drop =  FALSE ] } else  if (   type ==  \"start\" )  {   m -   filterMatrix (  start ) } else  if (   type ==  \"end\" )  {   m -   filterMatrix (  end ) } else  if (   type ==  \"equal\" )  {   m -   filterMatrix (  start )   m -   filterMatrix (  end ) }  if (   origSelect !=  \"all\" )  {   m -   m [  !   duplicated (   m [ ,  1L ] ) , , drop =  FALSE ]   result -   rep.int (  NA_integer_ ,   length (  query ) )    result [   m [ ,  1L ] ] -   m [ ,  2L ] } else  {    result @ matchMatrix -  m } }  result } ",
    "filename": "IntervalTree-utils.txt"
  }
}

7.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "{   findOverlaps (  query ,   IntervalTree (  subject ) ,  maxgap ,  multiple ) } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (  query ,   IntervalTree (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  }
}

8.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "findOverlaps ( IRanges ( query , query ) , subject , maxgap , multiple )",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   IRanges (  query ,  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  }
}

9.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "{   subject -   ranges (  subject )   query -   ranges (  query )   callGeneric ( ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

10.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "{   query -   ranges (  query )   callGeneric ( ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

11.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE )",
    "body": "{   subject -   ranges (  subject )   callGeneric ( ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

12.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0 , multiple = TRUE , drop = FALSE )",
    "body": "{   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else   subject -   subject [   seq_along (  query ) ] ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] ,  maxgap ,  multiple ) } )    names (  ans ) -   names (  subject )  if (  multiple )   ans -   RangesMatchingList (  ans ,   names (  origSubject ) ) else  if (  drop )  {   off -   head (   c (  0 ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep (   unname (  off ) ,   sapply (  ans ,  length ) ) } else   ans -   IntegerList (  ans )  ans } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   type -   match.arg (  type )   select -   match.arg (  select )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   RangesMatchingList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "RangesList-class.txt"
  }
}

13.
{
  "old_function": {
    "name": "solveUserSEW",
    "representation": "solveUserSEW",
    "parameters": "function ( refwidths , start = NA , end = NA , width = NA , translate.negative.coord = TRUE , allow.nonnarrowing = FALSE )",
    "body": "{  if (  !   is.numeric (  refwidths ) )   stop (  \"'refwidths' must be a vector of integers\" )  if (  !   is.integer (  refwidths ) )   refwidths -   as.integer (  refwidths )   start -   .normargSEW (  start ,  \"start\" )   end -   .normargSEW (  end ,  \"end\" )   width -   .normargSEW (  width ,  \"width\" ) ## From here, 'refwidths', 'start', 'end' and 'width' are guaranteed to be ## integer vectors. NAs in 'start', 'end' and 'width' are OK but not in ## 'refwidths' so this needs to be checked by C function solve_user_SEW().   l1 -   length (  start )   l2 -   length (  end )   l3 -   length (  width )   min123 -   min (  l1 ,  l2 ,  l3 )   max123 -   max (  l1 ,  l2 ,  l3 )  if (    length (  refwidths ) ==  0L )  {  if (    max123 !=  min123 ||   max123 undefined  1L )   stop (  \"'start', 'end' and 'width' must have the same length \" ,  \"and it must be 0 or 1 when 'refwidths' is empty\" ) } else  {  if (   max123 undefined   length (  refwidths ) )   stop (  \"'start', 'end' or 'width' has more elements than 'refwidths'\" )  if (   min123 ==  0L )   stop (  \"'start', 'end' or 'width' is empty but 'refwidths' is not\" ) }  if (  !   isTRUEorFALSE (  translate.negative.coord ) )   stop (  \"'translate.negative.coord' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  allow.nonnarrowing ) )   stop (  \"'allow.nonnarrowing' must be TRUE or FALSE\" )   .Call (  \"solve_user_SEW\" ,  refwidths ,  start ,  end ,  width ,  translate.negative.coord ,  allow.nonnarrowing , PACKAGE =  \"IRanges\" ) } ",
    "filename": "IRanges-constructor.txt"
  },
  "new_function": {
    "name": "solveUserSEW",
    "representation": "solveUserSEW",
    "parameters": "function ( refwidths , start = NA , end = NA , width = NA , rep.refwidths = FALSE , translate.negative.coord = TRUE , allow.nonnarrowing = FALSE )",
    "body": "{  if (  !   is.numeric (  refwidths ) )   stop (  \"'refwidths' must be a vector of integers\" )  if (  !   is.integer (  refwidths ) )   refwidths -   as.integer (  refwidths )  if (  !   isTRUEorFALSE (  rep.refwidths ) )   stop (  \"'rep.refwidths' must be TRUE or FALSE\" )  if (   rep.refwidths undefined    length (  refwidths ) !=  1L )   stop (  \"use 'rep.refwidths=TRUE' only when 'refwidths' is of length 1\" )   start -   .normargSEW (  start ,  \"start\" )   end -   .normargSEW (  end ,  \"end\" )   width -   .normargSEW (  width ,  \"width\" ) ## From here, 'refwidths', 'start', 'end' and 'width' are guaranteed to be ## integer vectors. NAs in 'start', 'end' and 'width' are OK but not in ## 'refwidths' so this needs to be checked by C function solve_user_SEW().   Lsew -   c (   length (  start ) ,   length (  end ) ,   length (  width ) )   maxLsew -   max (  Lsew )  if (     min (  Lsew ) ==  0L undefined   maxLsew !=  0L )   stop (  \"'start', 'end' and 'width' cannot be a mix of zero-length \" ,  \"and non zero-length vectors\" )  if (  rep.refwidths )  {   refwidths -   rep.int (  refwidths ,  maxLsew ) } else  {  if (    maxLsew undefined   length (  refwidths ) undefined   maxLsew undefined  1L )   stop (  \"'start', 'end' or 'width' is longer than 'refwidths'\" )  if (     length (  refwidths ) !=  0L undefined   maxLsew ==  0L )   stop (  \"cannot recycle empty 'start', 'end' and 'width'\" ) }  if (  !   isTRUEorFALSE (  translate.negative.coord ) )   stop (  \"'translate.negative.coord' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  allow.nonnarrowing ) )   stop (  \"'allow.nonnarrowing' must be TRUE or FALSE\" )   .Call (  \"solve_user_SEW\" ,  refwidths ,  start ,  end ,  width ,  translate.negative.coord ,  allow.nonnarrowing , PACKAGE =  \"IRanges\" ) } ",
    "filename": "IRanges-constructor.txt"
  }
}

14.
{
  "old_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "Ranges",
    "parameters": "function ( x , width , start = TRUE , use.names = TRUE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   resize (  ir , width =  width , start =  start , use.names =  use.names )   as (  y ,   class (  x ) ) } ",
    "filename": "Ranges-class.txt"
  },
  "new_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "Ranges",
    "parameters": "function ( x , width , fix = \"start\" , use.names = TRUE , start = TRUE , symmetric = FALSE )",
    "body": "{   lx -   length (  x )  if (   !   is.numeric (  width ) ||   anyMissing (  width ) )   stop (  \"'width' must be a numeric vector without NA's\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   anyMissingOrOutside (  width ,  0L ) )   stop (  \"'width' values must be non-negative\" )  if (    missing (  start ) undefined   missing (  symmetric ) )  {  if (    !  (    is.character (  fix ) ||  (    is (  fix ,  \"Rle\" ) undefined   is.character (   runValue (  fix ) ) ) ) ||  (    length (  fix ) ==  0 ) ||  (    length (   setdiff (   unique (  fix ) ,   c (  \"start\" ,  \"end\" ,  \"center\" ) ) ) undefined  0 ) )  {   stop (  \"'fix' must be a character vector or character Rle \" ,  \"with values in \\\"start\\\", \\\"end\\\", and \\\"center\\\"\" ) }  if (  !   is (  fix ,  \"Rle\" ) )   fix -   Rle (  fix )  if (    length (  fix ) !=  lx )   fix -   rep (  fix , length.out =  lx ) } else  {   fix -   Rle (  \"start\" ,  lx )  if (  !   missing (  start ) )  {  if (   !   is.logical (  start ) ||   anyMissing (  start ) )   stop (  \"'start' must be a logical vector without NA's\" )   warning (  \"argument 'start' is deprecated; use 'fix'.\" )   fix -   Rle (   ifelse (  start ,  \"start\" ,  \"end\" ) ,  lx ) }  if (  !   missing (  symmetric ) )  {  if (  !   isTRUEorFALSE (  symmetric ) )   stop (  \"'symmetric' must be TRUE or FALSE\" )   warning (  \"argument 'symmetric' is deprecated; use 'fix'.\" )  if (  symmetric )   fix -   Rle (  \"center\" ,  lx ) } }   ans_width -   recycleVector (  width ,  lx )   ans_start -   start (  x )  if (  !   identical (   runValue (  fix ) ,  \"start\" ) )  {   fixEnd -   as (   fix ==  \"end\" ,  \"IRanges\" )  if (    length (  fixEnd ) undefined  0 )  {    seqselect (  ans_start ,  fixEnd ) -    seqselect (  ans_start ,  fixEnd ) +  (    seqselect (   width (  x ) ,  fixEnd ) -   seqselect (  ans_width ,  fixEnd ) ) }   fixCenter -   as (   fix ==  \"center\" ,  \"IRanges\" )  if (    length (  fixCenter ) undefined  0 )  {    seqselect (  ans_start ,  fixCenter ) -    seqselect (  ans_start ,  fixCenter ) +   (    seqselect (   width (  x ) ,  fixCenter ) -   seqselect (  ans_width ,  fixCenter ) ) %/%  2L } }   x -   update (  x , start =  ans_start , width =  ans_width , check =  FALSE )  if (  !   normargUseNames (  use.names ) )    names (  x ) -  NULL  x } ",
    "filename": "Ranges-utils.txt"
  }
}

15.
{
  "old_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "RangesList",
    "parameters": "function ( x , width , start = TRUE , use.names = TRUE )",
    "body": "{   endoapply (  x ,  resize , width =  width , start =  start , use.names =  use.names ) } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "RangesList",
    "parameters": "function ( x , width , fix = \"start\" , use.names = TRUE )",
    "body": "{   lx -   length (  x )   width -   normargAtomicList1 (  width ,  IntegerList ,  lx )   fix -   normargAtomicList1 (  fix ,  CharacterList ,  lx )   mendoapply (  resize , x =  x , width =  width , fix =  fix , MoreArgs =   list ( use.names =  use.names ) ) } ",
    "filename": "RangesList-class.txt"
  }
}

16.
{
  "old_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , width , start = TRUE , use.names = TRUE )",
    "body": "{    slot (  x ,  \"unlistData\" , check =  FALSE ) -   resize (   x @ unlistData , width =  width , start =  start , use.names =  use.names )  x } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , width , fix = \"start\" , use.names = TRUE )",
    "body": "{   lx -   length (  x )   eln -   elementLengths (  x )   width -   normargAtomicList2 (  width ,  IntegerList ,  lx ,  eln )   fix -   normargAtomicList2 (  fix ,  CharacterList ,  lx ,  eln )    slot (  x ,  \"unlistData\" , check =  FALSE ) -   resize (   x @ unlistData , width =  width , fix =  fix , use.names =  use.names )  x } ",
    "filename": "RangesList-class.txt"
  }
}

17.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call (  \"IRanges_reduce\" ,  x ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "IRanges-utils.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call (  \"IRanges_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "IRanges-utils.txt"
  }
}

18.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , by , with.inframe.attrib = FALSE )",
    "body": "{   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1 ] ]   values -    values (  y ) [[  1 ] ]   inds -   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (    ncol (  x ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , with.inframe.attrib =  with.inframe.attrib )   initialize (  x , ranges =  ranges , values =   newCompressedList (  \"CompressedSplitDataFrameList\" ,   new2 (  \"DataFrame\" , nrows =   sum (   elementLengths (  ranges ) ) , check =  FALSE ) , end =   cumsum (   elementLengths (  ranges ) ) , NAMES =   names (  ranges ) ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , by , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1L ] ]   values -    values (  y ) [[  1L ] ]   inds -   unname (   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (    ncol (  x ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   initialize (  x , ranges =  ranges , values =   newCompressedList (  \"CompressedSplitDataFrameList\" ,   new2 (  \"DataFrame\" , nrows =   sum (   elementLengths (  ranges ) ) , check =  FALSE ) , end =   cumsum (   elementLengths (  ranges ) ) , NAMES =   names (  ranges ) ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "RangedData-utils.txt"
  }
}

19.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir ,  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "Ranges-class.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "Ranges-utils.txt"
  }
}

20.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , with.inframe.attrib = FALSE )",
    "body": "{   endoapply (  x ,  reduce , with.inframe.attrib =  with.inframe.attrib ) } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.inframe.attrib = with.inframe.attrib )",
    "filename": "RangesList-class.txt"
  }
}

21.
{
  "old_function": {
    "name": "sub",
    "representation": "sub",
    "signature": "",
    "parameters": "function ( pattern , replacement , x , ignore.case = FALSE , extended = TRUE , perl = FALSE , fixed = FALSE , useBytes = FALSE )",
    "body": "Rle ( values = sub ( pattern = pattern , replacement = replacement , x = runValue ( x ) , ignore.case = ignore.case , extended = extended , perl = perl , fixed = fixed , useBytes = useBytes ) , lengths = runLength ( x ) , check = FALSE )",
    "filename": "Rle-class.txt"
  },
  "new_function": {
    "name": "sub",
    "representation": "sub",
    "signature": "",
    "parameters": "function ( pattern , replacement , x , ignore.case = FALSE , perl = FALSE , fixed = FALSE , useBytes = FALSE )",
    "body": "{  if (   is.factor (   runValue (  x ) ) )  {    levels (  x ) -   sub ( pattern =  pattern , replacement =  replacement , x =   levels (  x ) , ignore.case =  ignore.case , perl =  perl , fixed =  fixed , useBytes =  useBytes ) } else  {    runValue (  x ) -   sub ( pattern =  pattern , replacement =  replacement , x =   runValue (  x ) , ignore.case =  ignore.case , perl =  perl , fixed =  fixed , useBytes =  useBytes ) }  x } ",
    "filename": "Rle-class.txt"
  }
}

22.
{
  "old_function": {
    "name": "gsub",
    "representation": "gsub",
    "signature": "",
    "parameters": "function ( pattern , replacement , x , ignore.case = FALSE , extended = TRUE , perl = FALSE , fixed = FALSE , useBytes = FALSE )",
    "body": "Rle ( values = gsub ( pattern = pattern , replacement = replacement , x = runValue ( x ) , ignore.case = ignore.case , extended = extended , perl = perl , fixed = fixed , useBytes = useBytes ) , lengths = runLength ( x ) , check = FALSE )",
    "filename": "Rle-class.txt"
  },
  "new_function": {
    "name": "gsub",
    "representation": "gsub",
    "signature": "",
    "parameters": "function ( pattern , replacement , x , ignore.case = FALSE , perl = FALSE , fixed = FALSE , useBytes = FALSE )",
    "body": "{  if (   is.factor (   runValue (  x ) ) )  {    levels (  x ) -   gsub ( pattern =  pattern , replacement =  replacement , x =   levels (  x ) , ignore.case =  ignore.case , perl =  perl , fixed =  fixed , useBytes =  useBytes ) } else  {    runValue (  x ) -   gsub ( pattern =  pattern , replacement =  replacement , x =   runValue (  x ) , ignore.case =  ignore.case , perl =  perl , fixed =  fixed , useBytes =  useBytes ) }  x } ",
    "filename": "Rle-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_6 iranges_release_2_7

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_6 iranges_release_2_7",
    "desc_release_old": "1.6.17",
    "desc_release_new": "1.8.9",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 1,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 2
}

##########
Functions Removed
##########

isSingleIntegerOrNA


##########
Functions Added
##########

fold
breakInChunks
seqby
ifelse


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ANY ,  missing )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , ignoreSelf = FALSE , ignoreRedundant = FALSE )",
    "body": "{  if (   !  multiple undefined  !  ignoreSelf ) # silly case   seq (   length (  query ) ) else  {   result -   findOverlaps (  query ,  query , maxgap =  maxgap , multiple =  multiple , type =  type , minoverlap =  minoverlap )   mat -   matchMatrix (  result )  if (  ignoreSelf )   mat -   mat [    mat [ ,  1L ] !=   mat [ ,  2L ] , , drop =  FALSE ]  if (  ignoreRedundant )  {   norm_mat -   cbind (   pmin.int (   mat [ ,  1L ] ,   mat [ ,  2L ] ) ,   pmax.int (   mat [ ,  1L ] ,   mat [ ,  2L ] ) )   mat -   mat [  !   duplicated (  norm_mat ) , , drop =  FALSE ] }    result @ matchMatrix -  mat  result } } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ANY ,  missing )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , ignoreSelf = FALSE , ignoreRedundant = FALSE )",
    "body": "{   select -   match.arg (  select )   result -   findOverlaps (  query ,  query , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  \"all\" )   processSelfMatching (  result ,  select ,  ignoreSelf ,  ignoreRedundant ) } ",
    "filename": "IntervalTree-utils.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_7 iranges_release_2_8

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_7 iranges_release_2_8",
    "desc_release_old": "1.8.9",
    "desc_release_new": "1.10.6",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 1,
    "function_additions": 9,
    "parameter_removals": 1,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 2
}

##########
Functions Removed
##########

coverage.normargWidth


##########
Functions Added
##########

distance
compact
evalSeparately
subsetByFilter
iteratorFun
iteratorFun<-
which.max
which.min
merge


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , by , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1L ] ]   values -    values (  y ) [[  1L ] ]   inds -   unname (   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (    ncol (  x ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   initialize (  x , ranges =  ranges , values =   newCompressedList (  \"CompressedSplitDataFrameList\" ,   new2 (  \"DataFrame\" , nrows =   sum (   elementLengths (  ranges ) ) , check =  FALSE ) , end =   cumsum (   elementLengths (  ranges ) ) , NAMES =   names (  ranges ) ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , by = character ( ) , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1L ] ]   values -    values (  y ) [[  1L ] ]   inds -   unname (   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (     ncol (  x ) ==  0 ||    length (  by ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   initialize (  x , ranges =  ranges , values =   newCompressedList (  \"CompressedSplitDataFrameList\" ,   new2 (  \"DataFrame\" , nrows =   sum (   elementLengths (  ranges ) ) , check =  FALSE ) , end =   cumsum (   elementLengths (  ranges ) ) , NAMES =   names (  ranges ) ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "RangedData-utils.txt"
  }
}



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "RDApplyParams",
    "representation": "RDApplyParams",
    "parameters": "function ( rangedData , applyFun , applyParams , filterRules , simplify , reducerFun , reducerParams )",
    "body": "{   params -   new (  \"RDApplyParams\" , applyFun =  applyFun , applyParams =  applyParams , filterRules =  filterRules , simplify =  simplify , reducerFun =  reducerFun , reducerParams =  reducerParams )    params @ rangedData -  rangedData ## set rangedData last for efficiency  params } ",
    "filename": "RDApplyParams-class.txt"
  },
  "new_function": {
    "name": "RDApplyParams",
    "representation": "RDApplyParams",
    "parameters": "function ( rangedData , applyFun , applyParams , filterRules , simplify , reducerFun , reducerParams , iteratorFun )",
    "body": "{   params -   new (  \"RDApplyParams\" , applyFun =  applyFun , applyParams =  applyParams , filterRules =  filterRules , simplify =  simplify , reducerFun =  reducerFun , reducerParams =  reducerParams , iteratorFun =  iteratorFun )    params @ rangedData -  rangedData ## set rangedData last for efficiency  params } ",
    "filename": "RDApplyParams-class.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "RDApplyParams",
    "representation": "RDApplyParams",
    "parameters": "function ( rangedData , applyFun , applyParams , filterRules , simplify , reducerFun , reducerParams )",
    "body": "{   params -   new (  \"RDApplyParams\" , applyFun =  applyFun , applyParams =  applyParams , filterRules =  filterRules , simplify =  simplify , reducerFun =  reducerFun , reducerParams =  reducerParams )    params @ rangedData -  rangedData ## set rangedData last for efficiency  params } ",
    "filename": "RDApplyParams-class.txt"
  },
  "new_function": {
    "name": "RDApplyParams",
    "representation": "RDApplyParams",
    "parameters": "function ( rangedData , applyFun , applyParams , filterRules , simplify , reducerFun , reducerParams , iteratorFun )",
    "body": "{   params -   new (  \"RDApplyParams\" , applyFun =  applyFun , applyParams =  applyParams , filterRules =  filterRules , simplify =  simplify , reducerFun =  reducerFun , reducerParams =  reducerParams , iteratorFun =  iteratorFun )    params @ rangedData -  rangedData ## set rangedData last for efficiency  params } ",
    "filename": "RDApplyParams-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_8 iranges_release_2_9

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_8 iranges_release_2_9",
    "desc_release_old": "1.10.6",
    "desc_release_new": "1.12.6",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 4,
    "function_additions": 8,
    "parameter_removals": 4,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 8,
    "total_count": 12
}

##########
Functions Removed
##########

normargShift
normargWeight
overlap
countOverlap


##########
Functions Added
##########

.Call2
recycleIntegerArg
recycleNumericArg
XVectorList
unlist_list_of_XVectorList
unsplit_list_of_XVectorList
distanceToNearest
relist


##########
Removed Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "as.vector",
    "representation": "as.vector",
    "signature": "AtomicList",
    "parameters": "function ( x , mode )",
    "body": "as.vector ( unlist ( x , use.names = FALSE ) , mode = mode )",
    "filename": "AtomicList-impl.txt"
  },
  "new_function": {
    "name": "as.vector",
    "representation": "as.vector",
    "signature": "AtomicList",
    "parameters": "function ( x , mode = \"any\" )",
    "body": "as.vector ( as.vectorORfactor ( x ) , mode = mode )",
    "filename": "AtomicList-impl.txt"
  }
}

1.
{
  "old_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "Ranges",
    "parameters": "function ( x , shift , use.names = TRUE )",
    "body": "{   shift -   normargShift (  shift ,   length (  x ) )   x -   update (  x , start =    start (  x ) +  shift , width =   width (  x ) , check =  FALSE )  if (  !   normargUseNames (  use.names ) )    names (  x ) -  NULL  x } ",
    "filename": "Ranges-utils.txt"
  },
  "new_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "Ranges",
    "parameters": "function ( x , shift = 0L , use.names = TRUE )",
    "body": "{   shift -   recycleIntegerArg (  shift ,  \"shift\" ,   length (  x ) )   x -   update (  x , start =    start (  x ) +  shift , width =   width (  x ) , check =  FALSE )  if (  !   normargUseNames (  use.names ) )    names (  x ) -  NULL  x } ",
    "filename": "Ranges-utils.txt"
  }
}

2.
{
  "old_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "RangesList",
    "parameters": "function ( x , shift , use.names = TRUE )",
    "body": "{   lx -   length (  x )   shift -   normargAtomicList1 (  shift ,  IntegerList ,  lx )   mendoapply (  \"shift\" , x =  x , shift =  shift , MoreArgs =   list ( use.names =  use.names ) ) } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "RangesList",
    "parameters": "function ( x , shift = 0L , use.names = TRUE )",
    "body": "{   lx -   length (  x )   shift -   normargAtomicList1 (  shift ,  IntegerList ,  lx )   mendoapply (  \"shift\" , x =  x , shift =  shift , MoreArgs =   list ( use.names =  use.names ) ) } ",
    "filename": "RangesList-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , shift , use.names = TRUE )",
    "body": "{   lx -   length (  x )   eln -   elementLengths (  x )   shift -   normargAtomicList2 (  shift ,  IntegerList ,  lx ,  eln )    slot (  x ,  \"unlistData\" , check =  FALSE ) -   shift (   x @ unlistData , shift =  shift , use.names =  use.names )  x } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "shift",
    "representation": "shift",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , shift = 0L , use.names = TRUE )",
    "body": "{   lx -   length (  x )   eln -   elementLengths (  x )   shift -   normargAtomicList2 (  shift ,  IntegerList ,  lx ,  eln )    slot (  x ,  \"unlistData\" , check =  FALSE ) -   shift (   x @ unlistData , shift =  shift , use.names =  use.names )  x } ",
    "filename": "RangesList-class.txt"
  }
}



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  IntervalTree )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0L )   stop (  \"'maxgap' must be a single, non-negative integer\" )  if (   !   isSingleNumber (  minoverlap ) ||   minoverlap undefined  1L )   stop (  \"'minoverlap' must be a single, positive integer\" )   type -   match.arg (  type )   select -   match.arg (  select )   origSelect -  select  if (    type !=  \"any\" ||   minoverlap undefined  1L )   select -  \"all\"   query -   as (  query ,  \"IRanges\" )   query_ord -  NULL   origQuery -  query   adjust -    maxgap -  minoverlap +  1L  if (   adjust undefined  0L )   query -   resize (  query ,    width (  query ) +   2L *  adjust , fix =  \"center\" )   unsortedQuery -  query  if (   isNotSorted (   start (  query ) ) )  { ## query must be sorted   query_ord -   sort.list (   start (  query ) , method =  \"quick\" , na.last =  NA )   query -   query [  query_ord ] } else  {   query_ord -   seq_len (   length (  query ) ) }   validObject (  query )   fun -   paste (  \"overlap_\" ,  select , sep =  \"\" )   result -   .IntervalTreeCall (  subject ,  fun ,  query ,  query_ord )  if (    type !=  \"any\" ||   minoverlap undefined  1L )  {   m -   as.matrix (  result )  if (   minoverlap undefined  1L )  {   r -   ranges (  result ,  unsortedQuery ,  subject )   m -   m [    width (  r ) =  minoverlap , , drop =  FALSE ]    result @ matchMatrix -  m }   query -  origQuery   filterMatrix -  function ( fun )   m [    abs (     fun (  query ) [   m [ ,  1L ] ] -    fun (  subject ) [   m [ ,  2L ] ] ) =  maxgap , , drop =  FALSE ]  if (   type ==  \"within\" )  {   r -   ranges (  result ,  query ,  subject )   m -   m [      width (  query ) [   m [ ,  1L ] ] -   width (  r ) =  maxgap , , drop =  FALSE ] } else  if (   type ==  \"start\" )  {   m -   filterMatrix (  start ) } else  if (   type ==  \"end\" )  {   m -   filterMatrix (  end ) } else  if (   type ==  \"equal\" )  {   m -   filterMatrix (  start )   m -   filterMatrix (  end ) }  if (   origSelect !=  \"all\" )  {   m -   m [  !   duplicated (   m [ ,  1L ] ) , , drop =  FALSE ]   result -   rep.int (  NA_integer_ ,   length (  query ) )    result [   m [ ,  1L ] ] -   m [ ,  2L ] } else  {    result @ matchMatrix -  m } }  result } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  IntervalTree )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0L )   stop (  \"'maxgap' must be a single, non-negative integer\" )  if (   !   isSingleNumber (  minoverlap ) ||   minoverlap undefined  1L )   stop (  \"'minoverlap' must be a single, positive integer\" )   type -   match.arg (  type )   select -   match.arg (  select )   origSelect -  select  if (    type !=  \"any\" ||   minoverlap undefined  1L )   select -  \"all\"   query -   as (  query ,  \"IRanges\" )   query_ord -  NULL   origQuery -  query   adjust -    maxgap -  minoverlap +  1L  if (   adjust undefined  0L )   query -   resize (  query ,    width (  query ) +   2L *  adjust , fix =  \"center\" )   unsortedQuery -  query  if (   isNotSorted (   start (  query ) ) )  { ## query must be sorted   query_ord -   sort.list (   start (  query ) , method =  \"quick\" , na.last =  NA )   query -   query [  query_ord ] } else  {   query_ord -   seq_len (   length (  query ) ) }   validObject (  query )   fun -   paste (  \"overlap_\" ,  select , sep =  \"\" )   result -   .IntervalTreeCall (  subject ,  fun ,  query ,  query_ord )  if (    type !=  \"any\" ||   minoverlap undefined  1L )  {   m -   as.matrix (  result )  if (   minoverlap undefined  1L )  {   r -   ranges (  result ,  unsortedQuery ,  subject )   m -   m [    width (  r ) =  minoverlap , , drop =  FALSE ]    result @ matchMatrix -  m }   query -  origQuery   filterMatrix -  function ( fun )   m [    abs (     fun (  query ) [   m [ ,  1L ] ] -    fun (  subject ) [   m [ ,  2L ] ] ) =  maxgap , , drop =  FALSE ]  if (   type ==  \"within\" )  {   r -   ranges (  result ,  query ,  subject )   m -   m [      width (  query ) [   m [ ,  1L ] ] -   width (  r ) =  maxgap , , drop =  FALSE ] } else  if (   type ==  \"start\" )  {   m -   filterMatrix (  start ) } else  if (   type ==  \"end\" )  {   m -   filterMatrix (  end ) } else  if (   type ==  \"equal\" )  {   m -   filterMatrix (  start )   m -   filterMatrix (  end ) }  if (   origSelect !=  \"all\" )  {   m -   m [  !   duplicated (   m [ ,  1L ] ) , , drop =  FALSE ]   result -   rep.int (  NA_integer_ ,   length (  query ) )    result [   m [ ,  1L ] ] -   m [ ,  2L ] } else  {    result @ matchMatrix -  m } }  result } ",
    "filename": "IntervalTree-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (  query ,   IntervalTree (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (  query ,   IntervalTree (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  }
}

2.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   IRanges (  query ,  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (   IRanges (  query ,  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "IntervalTree-utils.txt"
  }
}

3.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

4.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

5.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "RangedData-utils.txt"
  }
}

6.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , multiple = TRUE , drop = FALSE )",
    "body": "{  if (   !   missing (  multiple ) undefined  !  multiple )  {  if (  !   isTRUEorFALSE (  multiple ) )   stop (  \"'multiple' must be TRUE or FALSE\" )   warning (  \"argument 'multiple' is deprecated; use 'select'.\" )   select -  \"arbitrary\" }   type -   match.arg (  type )   select -   match.arg (  select )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   RangesMatchingList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "RangesList-class.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   RangesMatchingList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "RangesList-class.txt"
  }
}

7.
{
  "old_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "Ranges",
    "parameters": "function ( x , width , fix = \"start\" , use.names = TRUE , start = TRUE , symmetric = FALSE )",
    "body": "{   lx -   length (  x )  if (   !   is.numeric (  width ) ||   anyMissing (  width ) )   stop (  \"'width' must be a numeric vector without NA's\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   anyMissingOrOutside (  width ,  0L ) )   stop (  \"'width' values must be non-negative\" )  if (    missing (  start ) undefined   missing (  symmetric ) )  {  if (    !  (    is.character (  fix ) ||  (    is (  fix ,  \"Rle\" ) undefined   is.character (   runValue (  fix ) ) ) ) ||  (    length (  fix ) ==  0 ) ||  (    length (   setdiff (   unique (  fix ) ,   c (  \"start\" ,  \"end\" ,  \"center\" ) ) ) undefined  0 ) )  {   stop (  \"'fix' must be a character vector or character Rle \" ,  \"with values in \\\"start\\\", \\\"end\\\", and \\\"center\\\"\" ) }  if (  !   is (  fix ,  \"Rle\" ) )   fix -   Rle (  fix )  if (    length (  fix ) !=  lx )   fix -   rep (  fix , length.out =  lx ) } else  {   fix -   Rle (  \"start\" ,  lx )  if (  !   missing (  start ) )  {  if (   !   is.logical (  start ) ||   anyMissing (  start ) )   stop (  \"'start' must be a logical vector without NA's\" )   warning (  \"argument 'start' is deprecated; use 'fix'.\" )   fix -   Rle (   ifelse (  start ,  \"start\" ,  \"end\" ) ,  lx ) }  if (  !   missing (  symmetric ) )  {  if (  !   isTRUEorFALSE (  symmetric ) )   stop (  \"'symmetric' must be TRUE or FALSE\" )   warning (  \"argument 'symmetric' is deprecated; use 'fix'.\" )  if (  symmetric )   fix -   Rle (  \"center\" ,  lx ) } }   ans_width -   recycleVector (  width ,  lx )   ans_start -   start (  x )  if (  !   identical (   runValue (  fix ) ,  \"start\" ) )  {   fixEnd -   as (   fix ==  \"end\" ,  \"IRanges\" )  if (    length (  fixEnd ) undefined  0 )  {    seqselect (  ans_start ,  fixEnd ) -    seqselect (  ans_start ,  fixEnd ) +  (    seqselect (   width (  x ) ,  fixEnd ) -   seqselect (  ans_width ,  fixEnd ) ) }   fixCenter -   as (   fix ==  \"center\" ,  \"IRanges\" )  if (    length (  fixCenter ) undefined  0 )  {    seqselect (  ans_start ,  fixCenter ) -    seqselect (  ans_start ,  fixCenter ) +   (    seqselect (   width (  x ) ,  fixCenter ) -   seqselect (  ans_width ,  fixCenter ) ) %/%  2L } }   x -   update (  x , start =  ans_start , width =  ans_width , check =  FALSE )  if (  !   normargUseNames (  use.names ) )    names (  x ) -  NULL  x } ",
    "filename": "Ranges-utils.txt"
  },
  "new_function": {
    "name": "resize",
    "representation": "resize",
    "signature": "Ranges",
    "parameters": "function ( x , width , fix = \"start\" , use.names = TRUE )",
    "body": "{   lx -   length (  x )  if (   !   is.numeric (  width ) ||   anyMissing (  width ) )   stop (  \"'width' must be a numeric vector without NA's\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width )  if (   anyMissingOrOutside (  width ,  0L ) )   stop (  \"'width' values must be non-negative\" )  if (    !  (    is.character (  fix ) ||  (    is (  fix ,  \"Rle\" ) undefined   is.character (   runValue (  fix ) ) ) ) ||  (    length (  fix ) ==  0 ) ||  (    length (   setdiff (   unique (  fix ) ,   c (  \"start\" ,  \"end\" ,  \"center\" ) ) ) undefined  0 ) )  {   stop (  \"'fix' must be a character vector or character Rle \" ,  \"with values in \\\"start\\\", \\\"end\\\", and \\\"center\\\"\" ) }  if (  !   is (  fix ,  \"Rle\" ) )   fix -   Rle (  fix )  if (    length (  fix ) !=  lx )   fix -   rep (  fix , length.out =  lx )   ans_width -   recycleVector (  width ,  lx )   ans_start -   start (  x )  if (  !   identical (   runValue (  fix ) ,  \"start\" ) )  {   fixEnd -   as (   fix ==  \"end\" ,  \"IRanges\" )  if (    length (  fixEnd ) undefined  0 )  {    seqselect (  ans_start ,  fixEnd ) -    seqselect (  ans_start ,  fixEnd ) +  (    seqselect (   width (  x ) ,  fixEnd ) -   seqselect (  ans_width ,  fixEnd ) ) }   fixCenter -   as (   fix ==  \"center\" ,  \"IRanges\" )  if (    length (  fixCenter ) undefined  0 )  {    seqselect (  ans_start ,  fixCenter ) -    seqselect (  ans_start ,  fixCenter ) +   (    seqselect (   width (  x ) ,  fixCenter ) -   seqselect (  ans_width ,  fixCenter ) ) %/%  2L } }   x -   update (  x , start =  ans_start , width =  ans_width , check =  FALSE )  if (  !   normargUseNames (  use.names ) )    names (  x ) -  NULL  x } ",
    "filename": "Ranges-utils.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_9 iranges_release_2_11

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_9 iranges_release_2_11",
    "desc_release_old": "1.12.6",
    "desc_release_new": "1.16.6",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 1,
    "function_additions": 35,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 5,
    "total_count": 6
}

##########
Functions Removed
##########

Binning


##########
Functions Added
##########

splitAsListReturnedClass
splitAsList
mcols
mcols<-
rename
multisplit
revElements
compare
rangeComparisonCodeToLetter
tofactor
params
remapHits
hits
map
pmap
Loffset
Roffset
encoding
flippedQuery
Lencoding
Rencoding
Lngap
Rngap
encodeOverlaps1
RangesList_encodeOverlaps
encodeOverlaps
drop
mstack
split<-
unsplit
queryLength
subjectLength
countQueryHits
countSubjectHits
expand


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "DataFrameList",
    "parameters": "function ( x , indName = \"space\" )",
    "body": "{   DataFrame (   .stack.ind (  x ,  indName ) ,  x , row.names =   unlist (   lapply (  x ,  rownames ) ) ) } ",
    "filename": "DataFrameList-utils.txt"
  },
  "new_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "DataFrameList",
    "parameters": "function ( x , index.var = \"name\" )",
    "body": "{   DataFrame (   .stack.ind (  x ,  index.var ) ,  x , row.names =   unlist (   lapply (  x ,  rownames ) ) ) } ",
    "filename": "DataFrameList-utils.txt"
  }
}

1.
{
  "old_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "List",
    "parameters": "function ( x , indName = \"space\" , valuesName = \"values\" )",
    "body": "{   df -   DataFrame (   .stack.ind (  x ,  indName ) ,   as (   unlist (  x , use.names =  FALSE ) ,  \"DataFrame\" ) )     colnames (  df ) [  2 ] -  valuesName  df } ",
    "filename": "List-class.txt"
  },
  "new_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "List",
    "parameters": "function ( x , index.var = \"name\" , value.var = \"value\" )",
    "body": "{   df -   DataFrame (   .stack.ind (  x ,  index.var ) ,   as (   unlist (  x , use.names =  FALSE ) ,  \"DataFrame\" ) )     colnames (  df ) [  2 ] -  value.var  df } ",
    "filename": "List-class.txt"
  }
}

2.
{
  "old_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "RangedDataList",
    "parameters": "function ( x , indName = \"sample\" )",
    "body": "{   rd -   do.call (  rbind ,   unname (   as.list (  x ) ) )   spaces -   unlist (   lapply (  x ,  space ) , use.names =  FALSE )   ids -   names (  x )  if (   is.null (  ids ) )   ids -   seq_len (   length (  x ) )   spaceOrd -   order (   factor (  spaces ,   names (  rd ) ) )    rd [[  indName ] ] -    rep (   factor (  ids ) ,   sapply (  x ,  nrow ) ) [  spaceOrd ]  rd } ",
    "filename": "RangedData-class.txt"
  },
  "new_function": {
    "name": "stack",
    "representation": "stack",
    "signature": "RangedDataList",
    "parameters": "function ( x , index.var = \"name\" )",
    "body": "{   rd -   do.call (  rbind ,   unname (   as.list (  x ) ) )   spaces -   unlist (   lapply (  x ,  space ) , use.names =  FALSE )   ids -   names (  x )  if (   is.null (  ids ) )   ids -   seq_len (   length (  x ) )   spaceOrd -   order (   factor (  spaces ,   names (  rd ) ) )    rd [[  index.var ] ] -    rep (   factor (  ids ) ,   sapply (  x ,  nrow ) ) [  spaceOrd ]  rd } ",
    "filename": "RangedData-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "PartitioningByEnd",
    "representation": "PartitioningByEnd",
    "parameters": "function ( end = integer ( ) , names = NULL )",
    "body": "{  if (  !   is.numeric (  end ) )   stop (  \"'end' must contain integer values\" )  if (  !   is.integer (  end ) )   end -   as.integer (  end )   new2 (  \"PartitioningByEnd\" , end =   unname (  end ) , NAMES =  names , check =  FALSE ) } ",
    "filename": "Grouping-class.txt"
  },
  "new_function": {
    "name": "PartitioningByEnd",
    "representation": "PartitioningByEnd",
    "parameters": "function ( x = integer ( ) , NG = NULL , names = NULL )",
    "body": "{  if (   is (  x ,  \"CompressedList\" ) )  { ## Behaves like a getter for the 'partitioning' slot.  if (  !   is.null (  NG ) )   warning (  \"when 'x' is a CompressedList object, \" ,  \"the 'NG' argument is ignored\" )  if (  !   is.null (  names ) )   warning (  \"when 'x' is a CompressedList object, \" ,  \"the 'names' argument is ignored\" )   return (   x @ partitioning ) }  if (    is.list (  x ) ||   is (  x ,  \"List\" ) )  {  if (  !   is.null (  NG ) )   warning (  \"'NG' argument is ignored when 'x' is \" ,  \"a CompressedList object\" )   x -   cumsum (   elementLengths (  x ) ) } else  {  if (  !   is.numeric (  x ) )   stop (  \"'x' must be either a list-like object \" ,  \"or a sorted integer vector\" )  if (  !   is.integer (  x ) )   x -   as.integer (  x )  if (   isNotSorted (  x ) )   stop (  \"when 'x' is an integer vector, it must be sorted\" )  if (  !   is.null (  NG ) )  { ## When 'NG' (number of groups) is supplied, then 'x' is considered ## to represent the group assignment of a collection of 'length(x)' ## objects. Therefore the values in 'x' must be ## ADDITIONALLY, 'x' must be *sorted* (not strictly) so it can be ## reconstructed from the object returned by PartitioningByEnd() ## by doing togroup() on that object.  if (  !   isSingleNumber (  NG ) )   stop (  \"'NG' must be either NULL or a single integer\" )  if (  !   is.integer (  NG ) )   NG -   as.integer (  NG )   NO -   length (  x ) # nb of objects  if (   NG ==  0L )  {  if (   NO !=  0L )   stop (  \"when 'NG' is 0, 'x' must be of length 0\" ) } else  { ## 'x' is expected to be non-decreasing and with values ## and   x -   cumsum (   tabulate (  x , nbins =  NG ) ) ## 'x[NG]' is guaranteed to be  if (    x [  NG ] !=  NO )   stop (  \"when 'NG' is supplied, values in 'x' must \" ,  \"be ) } } }  if (   is.null (  names ) )  {   ans_names -   names (  x ) } else  {  if (   !   is.character (  names ) ||    length (  names ) !=   length (  x ) )   stop (  \"'names' must be either NULL or a character vector of length \" ,  \"'NG' (if supplied) or 'length(x)' (if 'NG' is not supplied)\" )   ans_names -  names }   new2 (  \"PartitioningByEnd\" , end =   unname (  x ) , NAMES =  ans_names , check =  FALSE ) } ",
    "filename": "Grouping-class.txt"
  }
}

4.
{
  "old_function": {
    "name": "PartitioningByWidth",
    "representation": "PartitioningByWidth",
    "parameters": "function ( width = integer ( ) , names = NULL )",
    "body": "{  if (    is (  width ,  \"List\" ) ||   is.list (  width ) )   width -   elementLengths (  width )  if (  !   is.numeric (  width ) )   stop (  \"'width' must contain integer values\" )  if (  !   is.integer (  width ) )   width -   as.integer (  width )   new2 (  \"PartitioningByWidth\" , width =   unname (  width ) , NAMES =  names , check =  FALSE ) } ",
    "filename": "Grouping-class.txt"
  },
  "new_function": {
    "name": "PartitioningByWidth",
    "representation": "PartitioningByWidth",
    "parameters": "function ( x = integer ( ) , NG = NULL , names = NULL )",
    "body": "{  if (    is.list (  x ) ||   is (  x ,  \"List\" ) )  {  if (  !   is.null (  NG ) )   warning (  \"'NG' argument is ignored when 'x' is \" ,  \"a CompressedList object\" )   x -   elementLengths (  x ) } else  {  if (  !   is.numeric (  x ) )   stop (  \"'x' must be either a list-like object or an integer vector\" )  if (  !   is.integer (  x ) )   x -   as.integer (  x )  if (  !   is.null (  NG ) )  { ## When 'NG' (number of groups) is supplied, then 'x' is considered ## to represent the group assignment of a collection of 'length(x)' ## objects. Therefore the values in 'x' must be ## ADDITIONALLY, 'x' must be *sorted* (not strictly) so it can be ## reconstructed from the object returned by PartitioningByWidth() ## by doing togroup() on that object.  if (   isNotSorted (  x ) )   stop (  \"when 'x' is an integer vector, it must be sorted\" )  if (  !   isSingleNumber (  NG ) )   stop (  \"'NG' must be either NULL or a single integer\" )  if (  !   is.integer (  NG ) )   NG -   as.integer (  NG )   NO -   length (  x ) # nb of objects  if (   NG ==  0L )  {  if (   NO !=  0L )   stop (  \"when 'NG' is 0, 'x' must be of length 0\" ) } else  { ## 'x' is expected to be non-decreasing and with values ## and   x -   tabulate (  x , nbins =  NG ) ## 'sum(x)' is guaranteed to be  if (    sum (  x ) !=  NO )   stop (  \"when 'NG' is supplied, values in 'x' must \" ,  \"be ) } } }  if (   is.null (  names ) )  {   ans_names -   names (  x ) } else  {  if (   !   is.character (  names ) ||    length (  names ) !=   length (  x ) )   stop (  \"'names' must be either NULL or a character vector of length \" ,  \"'NG' (if supplied) or 'length(x)' (if 'NG' is not supplied)\" )   ans_names -  names }   new2 (  \"PartitioningByWidth\" , width =   unname (  x ) , NAMES =  ans_names , check =  FALSE ) } ",
    "filename": "Grouping-class.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_11 iranges_release_2_12

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_11 iranges_release_2_12",
    "desc_release_old": "1.16.6",
    "desc_release_new": "1.18.4",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 2,
    "function_additions": 55,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 5,
    "total_count": 7
}

##########
Functions Removed
##########

matchMatrix
nlevels


##########
Functions Added
##########

as.list.List
as.list.SimpleList
as.list.CompressedList
as.list.Rle
as.list.CompressedNormalIRangesList
as.list.Hits
duplicated.Ranges
duplicated.Dups
duplicated.DataTable
duplicated.Rle
duplicated.AtomicList
duplicated.CompressedAtomicList
duplicated.XRawList
levels.Rle
levels.OverlapEncodings
sort.Vector
sort.Rle
sort.RleList
unique.Vector
unique.DataTable
unique.Rle
unique.CompressedAtomicList
unique.CompressedRleList
unique.SimpleRleList
window.Vector
window.NULL
window.vector
window.factor
window.DataTable
window.IRanges
window.Rle
window.GappedRanges
window.XVector
window.GroupedIRanges
window.XVectorList
window<-.Vector
window<-.vector
window<-.factor
window<-.DataTable
window<-.RangedData
setMethods
%over%
%within%
subsetByRanges
findMatches
countMatches
promoters
overlapsAny
classNameForDisplay
$<-
`window<-`.Vector
`window<-`.vector
`window<-`.factor
`window<-`.DataTable
`window<-`.RangedData


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"IRanges_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"Ranges_reduce\" ,   start (  x ) ,   width (  x ) ,  drop.empty.ranges ,  min.gapwidth ,  with.mapping ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ mapping )    mcols (  ans ) -   DataFrame ( mapping =  mapping ) }  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.mapping = with.mapping , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth , PACKAGE =  \"IRanges\" ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   C_ans -   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,  with.mapping , PACKAGE =  \"IRanges\" )   ans_unlistData -   new2 (  \"IRanges\" , start =   C_ans $ start , width =   C_ans $ width , check =  FALSE )  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ mapping )    mcols (  ans_unlistData ) -   DataFrame ( mapping =  mapping ) }   ans_partitioning -   PartitioningByEnd (   C_ans $ partitioning_by_end )    names (  ans_partitioning ) -   names (  x )   relist (  ans_unlistData ,  ans_partitioning ) } ",
    "filename": "inter-range-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_12 iranges_release_2_13

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_12 iranges_release_2_13",
    "desc_release_old": "1.18.4",
    "desc_release_new": "1.20.7",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 32,
    "function_additions": 28,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 32
}

##########
Functions Removed
##########

duplicated.XRawList
window.DataTable
window.IRanges
window.GappedRanges
window.XVector
window.GroupedIRanges
window.XVectorList
window<-.DataTable
window<-.RangedData
tofactor
SharedVector.compare
SharedVector.copy
SharedRaw
SharedRaw.readInts
SharedRaw.writeInts
SharedRaw.read
SharedRaw.write
SharedRaw.readComplexes
XRaw
XInteger
XDouble
XNumeric
XVectorList
unlist_list_of_XVectorList
unsplit_list_of_XVectorList
subseq
subseq<-
xvcopy
compact
toString
`window<-`.DataTable
`window<-`.RangedData


##########
Functions Added
##########

aggregate.Rle
as.data.frame.DataFrame
as.data.frame.DataFrameList
as.data.frame.GappedRanges
as.data.frame.Hits
as.data.frame.OverlapEncodings
as.data.frame.RangedData
as.data.frame.Ranges
as.data.frame.RangesList
as.data.frame.Rle
as.data.frame.Vector
diff.Rle
duplicated.Vector
head.Vector
mean.Rle
median.Rle
quantile.Rle
rev.Rle
summary.Rle
tail.Vector
IntervalForest
FilterMatrix
CompressedHitsList
%outside%
get_showHeadLines
get_showTailLines
showAsCell
selfmatch


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_13 iranges_release_2_14

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_13 iranges_release_2_14",
    "desc_release_old": "1.20.7",
    "desc_release_new": "1.22.10",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 20,
    "function_additions": 11,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 6,
    "total_count": 26
}

##########
Functions Removed
##########

as.data.frame.OverlapEncodings
as.list.CompressedList
duplicated.Ranges
duplicated.AtomicList
duplicated.CompressedAtomicList
levels.OverlapEncodings
sort.RleList
unique.CompressedAtomicList
encodeOverlaps1
RangesList_encodeOverlaps
Loffset
Roffset
encoding
flippedQuery
Lencoding
Rencoding
Lngap
Rngap
encodeOverlaps
mapply


##########
Functions Added
##########

duplicated.CompressedList
sort.List
unique.CompressedList
phead
ptail
List
unstrsplit
relistToClass
extractList
tile
fixedColumnNames


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"Ranges_reduce\" ,   start (  x ) ,   width (  x ) ,  drop.empty.ranges ,  min.gapwidth ,  with.mapping ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ mapping )    mcols (  ans ) -   DataFrame ( mapping =  mapping ) }  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   identical (  with.mapping ,  FALSE ) )  {   msg -   c (  \"  The 'with.mapping' argument is deprecated.\\n\" ,  \"  Please use the 'with.revmap' argument instead.\" )   .Deprecated ( msg =  msg )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (   with.revmap undefined  with.mapping )   stop (  \"'with.revmap' and 'with.mapping' cannot be \" ,  \"both set to TRUE\" ) }  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"Ranges_reduce\" ,   start (  x ) ,   width (  x ) ,  drop.empty.ranges ,  min.gapwidth ,   with.revmap ||  with.mapping ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans ) -   DataFrame ( revmap =  revmap ) }  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ revmap )    mcols (  ans ) -   DataFrame ( mapping =  mapping ) }  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.mapping = with.mapping , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.revmap = with.revmap , with.mapping = FALSE , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   C_ans -   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,  with.mapping , PACKAGE =  \"IRanges\" )   ans_unlistData -   new2 (  \"IRanges\" , start =   C_ans $ start , width =   C_ans $ width , check =  FALSE )  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ mapping )    mcols (  ans_unlistData ) -   DataFrame ( mapping =  mapping ) }   ans_partitioning -   PartitioningByEnd (   C_ans $ partitioning_by_end )    names (  ans_partitioning ) -   names (  x )   relist (  ans_unlistData ,  ans_partitioning ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   identical (  with.mapping ,  FALSE ) )  {   msg -   c (  \"  The 'with.mapping' argument is deprecated.\\n\" ,  \"  Please use the 'with.revmap' argument instead.\" )   .Deprecated ( msg =  msg )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (   with.revmap undefined  with.mapping )   stop (  \"'with.revmap' and 'with.mapping' cannot be \" ,  \"both set to TRUE\" ) }  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   C_ans -   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,   with.revmap ||  with.mapping , PACKAGE =  \"IRanges\" )   ans_unlistData -   new2 (  \"IRanges\" , start =   C_ans $ start , width =   C_ans $ width , check =  FALSE )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans_unlistData ) -   DataFrame ( revmap =  revmap ) }  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ revmap )    mcols (  ans_unlistData ) -   DataFrame ( mapping =  mapping ) }   ans_partitioning -   PartitioningByEnd (   C_ans $ partitioning_by_end )    names (  ans_partitioning ) -   names (  x )   relist (  ans_unlistData ,  ans_partitioning ) } ",
    "filename": "inter-range-methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IntervalForest",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !  drop.empty.ranges )   stop (  \"'drop.empty.ranges' must be FALSE in \" ,  \"'reduce,IntervalForest'\" )  if (  with.mapping )   stop (  \"'with.mapping' muse be FALSE in 'reduce,IntervalForest'\" )   as (   reduce (   as (  x ,  \"CompressedIRangesList\" ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib ) ,  \"IntervalForest\" ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IntervalForest",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{  if (  !  drop.empty.ranges )   stop (  \"'drop.empty.ranges' must be TRUE in \" ,  \"'reduce,IntervalForest'\" )   as (   reduce (   as (  x ,  \"CompressedIRangesList\" ) , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib ) ,  \"IntervalForest\" ) } ",
    "filename": "inter-range-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_2_14 iranges_release_3_1

{
    "package": "IRanges",
    "release_versions": "iranges_release_2_14 iranges_release_3_1",
    "desc_release_old": "1.22.10",
    "desc_release_new": "2.2.9",
    "old_release_number": 10,
    "new_release_number": 11,
    "function_removals": 112,
    "function_additions": 14,
    "parameter_removals": 0,
    "parameter_additions": 1,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 16,
    "total_count": 128
}

##########
Functions Removed
##########

aggregate.Rle
as.data.frame.DataFrame
as.data.frame.DataFrameList
as.data.frame.RangesList
as.data.frame.Rle
as.data.frame.Vector
as.list.List
as.list.SimpleList
as.list.Rle
diff.Rle
duplicated.Vector
duplicated.DataTable
duplicated.Rle
head.Vector
levels.Rle
mean.Rle
median.Rle
quantile.Rle
rev.Rle
sort.Vector
sort.Rle
summary.Rle
tail.Vector
unique.Vector
unique.DataTable
unique.Rle
unique.CompressedRleList
unique.SimpleRleList
window.Vector
window.vector
window.factor
window.NULL
setValidity2
new2
setMethods
.Call2
isTRUEorFALSE
isSingleInteger
isSingleNumber
isSingleString
isSingleNumberOrNA
isSingleStringOrNA
recycleIntegerArg
recycleNumericArg
fold
safeExplode
strsplitAsListOfIntegerVectors
svn.time
phead
ptail
seqselect
seqselect<-
subsetByRanges
remapHits
hits
SimpleList
List
DataFrame
get_showHeadLines
get_showTailLines
isConstant
unstrsplit
metadata
metadata<-
elementMetadata
elementMetadata<-
mcols
mcols<-
rename
elementType
findMatches
countMatches
runValue
nrun
runLength<-
Rle
findRun
splitAsListReturnedClass
countQueryHits
countSubjectHits
map
pmap
$
as.logical
as.numeric
as.complex
as.character
as.raw
as.factor
!=
>=
<
>
head
tail
aggregate
substr
substring
levels
levels<-
ifelse
na.omit
na.exclude
complete.cases
sapply
Reduce
Filter
Find
Map
Position
xtabs
fixedColumnNames


##########
Functions Added
##########

as.list.Vector
unique.RleList
NCList
NCLists
PartitioningMap
FactorList
mapOrder
mapCoords
pmapCoords
mergeByOverlaps
anyDuplicated
xtfrm
transform
duplicated.CompressedIntegerList


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########

0.
{
  "old_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , chunksize )",
    "body": "{  if (  !   isSingleNumber (  totalsize ) )   stop (  \"'totalsize' must be a single integer\" )  if (  !   is.integer (  totalsize ) )   totalsize -   as.integer (  totalsize )  if (   totalsize undefined  0L )   stop (  \"'totalsize' must be a non-negative integer\" )  if (  !   isSingleNumber (  chunksize ) )   stop (  \"'chunksize' must be a single integer\" )  if (  !   is.integer (  chunksize ) )   chunksize -   as.integer (  chunksize )  if (   chunksize =  0L )   stop (  \"'chunksize' must be a positive integer\" )   quot -   totalsize %/%  chunksize   ans_width -   rep.int (  chunksize ,  quot )   rem -   totalsize %%  chunksize  if (   rem undefined  0L )   ans_width -   c (  ans_width ,  rem )   PartitioningByWidth (  ans_width ) } ",
    "filename": "IRanges-utils.txt"
  },
  "new_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , chunksize , nchunk )",
    "body": "{   totalsize -   .normarg_totalsize (  totalsize )  if (  !   missing (  chunksize ) )  {  if (  !   missing (  nchunk ) )   stop (  \"only one of 'chunksize' and 'nchunk' can be specified\" ) ## All chunks will have the requested size, except maybe the last one.   chunksize -   .normarg_chunksize_or_nchunk (  chunksize ,  totalsize ,  \"chunksize\" )  if (   totalsize ==  0L )   return (   PartitioningByEnd ( ) )   quot -   totalsize %/%  chunksize # integer division   ans_end -   cumsum (   rep.int (  chunksize ,  quot ) )  if (    quot ==  0L ||    ans_end [[  quot ] ] !=  totalsize )   ans_end -   c (  ans_end ,  totalsize ) } else  {  if (   missing (  nchunk ) )   stop (  \"one of 'chunksize' and 'nchunk' must be specified\" ) ## All chunks will have more or less the same size, with the difference ## between smallest and biggest chunks guaranteed to be   nchunk -   .normarg_chunksize_or_nchunk (  nchunk ,  totalsize ,  \"nchunk\" )  if (   nchunk ==  0L )   return (   PartitioningByEnd ( ) )   chunksize -   totalsize /  nchunk # floating point division   ans_end -   as.integer (   cumsum (   rep.int (  chunksize ,  nchunk ) ) ) ## The last value in 'ans_end' *should* be 'totalsize' but there is ## always some uncertainty about what coercing the result of a floating ## point operation to integer will produce. So we set this value ## manually to 'totalsize' just in case.    ans_end [[  nchunk ] ] -  totalsize }   PartitioningByEnd (  ans_end ) } ",
    "filename": "IRanges-utils.txt"
  }
}



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  IntervalForest )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{ # verify inputs  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0L )   stop (  \"'maxgap' must be a single, non-negative integer\" )  if (   !   isSingleNumber (  minoverlap ) ||   minoverlap undefined  1L )   stop (  \"'minoverlap' must be a single, positive integer\" )   type -   match.arg (  type )   select -   match.arg (  select )   origSelect -  select  if (    type !=  \"any\" ||   minoverlap undefined  1L )   select -  \"all\"  if (  !   is (  query ,  \"CompressedIRangesList\" ) )   query -   as (  query ,  \"CompressedIRangesList\" )   validObject (  query )   queryList -  query   query -   queryList @ unlistData   partitioning -   queryList @ partitioning # preprocess query   preprocRes -   .preProcess_findOverlaps_query (  query ,  maxgap ,  minoverlap ,  partitioning )   origQuery -   preprocRes $ origQuery   unsortedQuery -   preprocRes $ unsortedQuery   query -   preprocRes $ query   query_ord -   preprocRes $ query_ord   validObject (  query ) # match query partition to subject partition   partitionIndices -   match (   names (  partitioning ) ,   names (  subject ) ) # make initial findOverlaps call   fun -   paste (  \"overlap_\" ,  select , sep =  \"\" )   result -   .IntervalForestCall (  subject ,  fun ,  query ,  partitionIndices ,   elementLengths (  partitioning ) ,  query_ord ) # postprocess findOverlaps result   res -   .postProcess_findOverlaps_result (  result ,  unsortedQuery ,  origQuery ,  subject ,  type ,  minoverlap ,  maxgap ,  origSelect ) # turn it into compressed list  if (   origSelect ==  \"all\" )   return (   CompressedHitsList (  res ,  queryList ) )  if (  !  drop )  {   return (   newCompressedList0 (  \"CompressedIntegerList\" , unlistData =  res , partitioning =  partitioning ) ) }  res } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  IntervalForest )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{ # verify inputs  if (   !   isSingleNumber (  maxgap ) ||   maxgap undefined  0L )   stop (  \"'maxgap' must be a single, non-negative integer\" )  if (   !   isSingleNumber (  minoverlap ) ||   minoverlap undefined  1L )   stop (  \"'minoverlap' must be a single, positive integer\" )   type -   match.arg (  type )   select -   match.arg (  select )   algorithm -   match.arg (  algorithm )  if (   algorithm !=  \"nclist\" )   warning (  \"'algorithm' is ignored when 'subject' \" ,  \"is an IntervalForest object\" )   origSelect -  select  if (    type !=  \"any\" ||   minoverlap undefined  1L )   select -  \"all\"  if (  !   is (  query ,  \"CompressedIRangesList\" ) )   query -   as (  query ,  \"CompressedIRangesList\" )   validObject (  query )   queryList -  query   query -   queryList @ unlistData   partitioning -   queryList @ partitioning # preprocess query   preprocRes -   .preProcess_findOverlaps_query (  query ,  maxgap ,  minoverlap ,  partitioning )   origQuery -   preprocRes $ origQuery   unsortedQuery -   preprocRes $ unsortedQuery   query -   preprocRes $ query   query_ord -   preprocRes $ query_ord   validObject (  query ) # match query partition to subject partition   partitionIndices -   match (   names (  partitioning ) ,   names (  subject ) ) # make initial findOverlaps call   fun -   paste (  \"overlap_\" ,  select , sep =  \"\" )   result -   .IntervalForestCall (  subject ,  fun ,  query ,  partitionIndices ,   elementLengths (  partitioning ) ,  query_ord ) # postprocess findOverlaps result   res -   .postProcess_findOverlaps_result (  result ,  unsortedQuery ,  origQuery ,  subject ,  type ,  minoverlap ,  maxgap ,  origSelect ) # turn it into compressed list  if (   origSelect ==  \"all\" )   return (   CompressedHitsList (  res ,  queryList ) )  if (  !  drop )  {   return (   newCompressedList0 (  \"CompressedIntegerList\" , unlistData =  res , partitioning =  partitioning ) ) }  res } ",
    "filename": "findOverlaps-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   HitsList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   algorithm -   match.arg (  algorithm )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select , algorithm =  algorithm ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   HitsList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "findOverlaps-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

6.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

7.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

8.
{
  "old_function": {
    "name": "match",
    "representation": "match",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( x , table , nomatch = NA_integer_ , incomparables = NULL , method = c ( \"auto\" , \"quick\" , \"hash\" ) , match.if.overlap = FALSE )",
    "body": "{  if (  !   isSingleNumberOrNA (  nomatch ) )   stop (  \"'nomatch' must be a single number or NA\" )  if (  !   is.integer (  nomatch ) )   nomatch -   as.integer (  nomatch )  if (  !   is.null (  incomparables ) )   stop (  \"\\\"match\\\" method for Ranges objects \" ,  \"only accepts 'incomparables=NULL'\" )  if (  !   isTRUEorFALSE (  match.if.overlap ) )   stop (  \"'match.if.overlap' must be TRUE or FALSE\" )  if (  match.if.overlap )  {   msg -   c (  \"  Starting with BioC 2.14, \" ,  \"match() on Ranges objects\\n  does not support \" ,  \"the 'match.if.overlap' argument anymore. Please use\\n\\n\" ,  \"    findOverlaps(x, table, select=\\\"first\\\")\\n\\n\" ,  \"  if you need to do\\n\\n\" ,  \"    match(x, table, match.if.overlap=TRUE)\" )   .Defunct ( msg =  msg )   ans -   findOverlaps (  x ,  table , select =  \"first\" )  if (   !   is.na (  nomatch ) undefined   anyMissing (  ans ) )    ans [   is.na (  ans ) ] -  nomatch   return (  ans ) } ## Equivalent to (but faster than): ##     findOverlaps(x, table, type=\"equal\", select=\"first\") ## except when 'x' and 'table' both contain empty ranges.   matchIntegerPairs (   start (  x ) ,   width (  x ) ,   start (  table ) ,   width (  table ) , nomatch =  nomatch , method =  method ) } ",
    "filename": "Ranges-comparison.txt"
  },
  "new_function": {
    "name": "match",
    "representation": "match",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( x , table , nomatch = NA_integer_ , incomparables = NULL , method = c ( \"auto\" , \"quick\" , \"hash\" ) )",
    "body": "{  if (  !   is.null (  incomparables ) )   stop (  \"\\\"match\\\" method for Ranges objects \" ,  \"only accepts 'incomparables=NULL'\" ) ## Equivalent to (but faster than): ##     findOverlaps(x, table, type=\"equal\", select=\"first\") ## except when 'x' or 'table' contain empty ranges.   S4Vectors ::: matchIntegerPairs (   start (  x ) ,   width (  x ) ,   start (  table ) ,   width (  table ) , nomatch =  nomatch , method =  method ) } ",
    "filename": "Ranges-comparison.txt"
  }
}

9.
{
  "old_function": {
    "name": "selfmatch",
    "representation": "selfmatch",
    "signature": "Ranges",
    "parameters": "function ( x , method = c ( \"auto\" , \"quick\" , \"hash\" ) , match.if.overlap = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  match.if.overlap ) )   stop (  \"'match.if.overlap' must be TRUE or FALSE\" )  if (  match.if.overlap )  {   msg -   c (  \"  Starting with BioC 2.14), \" ,  \"selfmatch() on a Ranges object\\n  does not support \" ,  \"the 'match.if.overlap' argument anymore.\" )   .Defunct ( msg =  msg ) }   selfmatchIntegerPairs (   start (  x ) ,   width (  x ) , method =  method ) } ",
    "filename": "Ranges-comparison.txt"
  },
  "new_function": {
    "name": "selfmatch",
    "representation": "selfmatch",
    "signature": "Ranges",
    "parameters": "function ( x , method = c ( \"auto\" , \"quick\" , \"hash\" ) )",
    "body": "S4Vectors ::: selfmatchIntegerPairs ( start ( x ) , width ( x ) , method = method )",
    "filename": "Ranges-comparison.txt"
  }
}

10.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   identical (  with.mapping ,  FALSE ) )  {   msg -   c (  \"  The 'with.mapping' argument is deprecated.\\n\" ,  \"  Please use the 'with.revmap' argument instead.\" )   .Deprecated ( msg =  msg )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (   with.revmap undefined  with.mapping )   stop (  \"'with.revmap' and 'with.mapping' cannot be \" ,  \"both set to TRUE\" ) }  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"Ranges_reduce\" ,   start (  x ) ,   width (  x ) ,  drop.empty.ranges ,  min.gapwidth ,   with.revmap ||  with.mapping ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans ) -   DataFrame ( revmap =  revmap ) }  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ revmap )    mcols (  ans ) -   DataFrame ( mapping =  mapping ) }  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "IRanges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  with.inframe.attrib ) )   stop (  \"'with.inframe.attrib' must be TRUE or FALSE\" )   C_ans -   .Call2 (  \"Ranges_reduce\" ,   start (  x ) ,   width (  x ) ,  drop.empty.ranges ,  min.gapwidth ,  with.revmap ,  with.inframe.attrib , PACKAGE =  \"IRanges\" )   ans -   unsafe.update (  x , start =   C_ans $ start , width =   C_ans $ width , names =  NULL )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans ) -   DataFrame ( revmap =  revmap ) }  if (  with.inframe.attrib )  {   inframe -   new2 (  \"IRanges\" , start =   C_ans $ inframe.start , width =   width (  x ) , check =  FALSE )    attr (  ans ,  \"inframe\" ) -  inframe }  ans } ",
    "filename": "inter-range-methods.txt"
  }
}

11.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Ranges",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.inframe.attrib = FALSE )",
    "body": "{   ir -   as (  x ,  \"IRanges\" )   y -   reduce (  ir , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.inframe.attrib =  with.inframe.attrib )   as (  y ,   class (  x ) ) } ",
    "filename": "inter-range-methods.txt"
  }
}

12.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.mapping =  with.mapping , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "Views",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.inframe.attrib = FALSE )",
    "body": "{    x @ ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.revmap =  with.revmap , with.inframe.attrib =  with.inframe.attrib )  x } ",
    "filename": "inter-range-methods.txt"
  }
}

13.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.revmap = with.revmap , with.mapping = FALSE , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.inframe.attrib = FALSE )",
    "body": "endoapply ( x , reduce , drop.empty.ranges = drop.empty.ranges , min.gapwidth = min.gapwidth , with.revmap = with.revmap , with.inframe.attrib = with.inframe.attrib )",
    "filename": "inter-range-methods.txt"
  }
}

14.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.mapping = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   identical (  with.mapping ,  FALSE ) )  {   msg -   c (  \"  The 'with.mapping' argument is deprecated.\\n\" ,  \"  Please use the 'with.revmap' argument instead.\" )   .Deprecated ( msg =  msg )  if (  !   isTRUEorFALSE (  with.mapping ) )   stop (  \"'with.mapping' must be TRUE or FALSE\" )  if (   with.revmap undefined  with.mapping )   stop (  \"'with.revmap' and 'with.mapping' cannot be \" ,  \"both set to TRUE\" ) }  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   C_ans -   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,   with.revmap ||  with.mapping , PACKAGE =  \"IRanges\" )   ans_unlistData -   new2 (  \"IRanges\" , start =   C_ans $ start , width =   C_ans $ width , check =  FALSE )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans_unlistData ) -   DataFrame ( revmap =  revmap ) }  if (  with.mapping )  {   mapping -   IntegerList (   C_ans $ revmap )    mcols (  ans_unlistData ) -   DataFrame ( mapping =  mapping ) }   ans_partitioning -   PartitioningByEnd (   C_ans $ partitioning_by_end )    names (  ans_partitioning ) -   names (  x )   relist (  ans_unlistData ,  ans_partitioning ) } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "CompressedIRangesList",
    "parameters": "function ( x , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.revmap = FALSE , with.inframe.attrib = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )  if (  !   isTRUEorFALSE (  with.revmap ) )   stop (  \"'with.revmap' must be TRUE or FALSE\" )  if (  !   identical (  with.inframe.attrib ,  FALSE ) )   stop (  \"'with.inframe.attrib' argument not yet supported \" ,  \"when reducing a CompressedIRangesList object\" )   C_ans -   .Call2 (  \"CompressedIRangesList_reduce\" ,  x ,  drop.empty.ranges ,  min.gapwidth ,  with.revmap , PACKAGE =  \"IRanges\" )   ans_unlistData -   new2 (  \"IRanges\" , start =   C_ans $ start , width =   C_ans $ width , check =  FALSE )  if (  with.revmap )  {   revmap -   IntegerList (   C_ans $ revmap )    mcols (  ans_unlistData ) -   DataFrame ( revmap =  revmap ) }   ans_partitioning -   PartitioningByEnd (   C_ans $ partitioning_by_end )    names (  ans_partitioning ) -   names (  x )   relist (  ans_unlistData ,  ans_partitioning ) } ",
    "filename": "inter-range-methods.txt"
  }
}

15.
{
  "old_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , chunksize )",
    "body": "{  if (  !   isSingleNumber (  totalsize ) )   stop (  \"'totalsize' must be a single integer\" )  if (  !   is.integer (  totalsize ) )   totalsize -   as.integer (  totalsize )  if (   totalsize undefined  0L )   stop (  \"'totalsize' must be a non-negative integer\" )  if (  !   isSingleNumber (  chunksize ) )   stop (  \"'chunksize' must be a single integer\" )  if (  !   is.integer (  chunksize ) )   chunksize -   as.integer (  chunksize )  if (   chunksize =  0L )   stop (  \"'chunksize' must be a positive integer\" )   quot -   totalsize %/%  chunksize   ans_width -   rep.int (  chunksize ,  quot )   rem -   totalsize %%  chunksize  if (   rem undefined  0L )   ans_width -   c (  ans_width ,  rem )   PartitioningByWidth (  ans_width ) } ",
    "filename": "IRanges-utils.txt"
  },
  "new_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , chunksize , nchunk )",
    "body": "{   totalsize -   .normarg_totalsize (  totalsize )  if (  !   missing (  chunksize ) )  {  if (  !   missing (  nchunk ) )   stop (  \"only one of 'chunksize' and 'nchunk' can be specified\" ) ## All chunks will have the requested size, except maybe the last one.   chunksize -   .normarg_chunksize_or_nchunk (  chunksize ,  totalsize ,  \"chunksize\" )  if (   totalsize ==  0L )   return (   PartitioningByEnd ( ) )   quot -   totalsize %/%  chunksize # integer division   ans_end -   cumsum (   rep.int (  chunksize ,  quot ) )  if (    quot ==  0L ||    ans_end [[  quot ] ] !=  totalsize )   ans_end -   c (  ans_end ,  totalsize ) } else  {  if (   missing (  nchunk ) )   stop (  \"one of 'chunksize' and 'nchunk' must be specified\" ) ## All chunks will have more or less the same size, with the difference ## between smallest and biggest chunks guaranteed to be   nchunk -   .normarg_chunksize_or_nchunk (  nchunk ,  totalsize ,  \"nchunk\" )  if (   nchunk ==  0L )   return (   PartitioningByEnd ( ) )   chunksize -   totalsize /  nchunk # floating point division   ans_end -   as.integer (   cumsum (   rep.int (  chunksize ,  nchunk ) ) ) ## The last value in 'ans_end' *should* be 'totalsize' but there is ## always some uncertainty about what coercing the result of a floating ## point operation to integer will produce. So we set this value ## manually to 'totalsize' just in case.    ans_end [[  nchunk ] ] -  totalsize }   PartitioningByEnd (  ans_end ) } ",
    "filename": "IRanges-utils.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_1 iranges_release_3_2

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_1 iranges_release_3_2",
    "desc_release_old": "2.2.9",
    "desc_release_new": "2.4.8",
    "old_release_number": 11,
    "new_release_number": 12,
    "function_removals": 14,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 14
}

##########
Functions Removed
##########

window.Rle
seqapply
mseqapply
tseqapply
seqsplit
seqby
FilterRules
FilterMatrix
evalSeparately
subsetByFilter
params
window
split
eval


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_2 iranges_release_3_3

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_2 iranges_release_3_3",
    "desc_release_old": "2.4.8",
    "desc_release_new": "2.6.1",
    "old_release_number": 12,
    "new_release_number": 13,
    "function_removals": 35,
    "function_additions": 20,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 24,
    "total_count": 59
}

##########
Functions Removed
##########

as.data.frame.GappedRanges
as.data.frame.Hits
as.data.frame.RangedData
as.data.frame.Ranges
as.list.Vector
as.list.CompressedNormalIRangesList
as.list.Hits
duplicated.Dups
duplicated.CompressedList
sort.List
unique.RleList
unique.CompressedList
IntervalTree
IntervalForest
CompressedHitsList
newViews
mapCoords
pmapCoords
expand
as.table
==
<=
sort
rank
is.unsorted
t
updateObject
queryHits
subjectHits
queryLength
subjectLength
compare
shiftApply
elementLengths
duplicated.CompressedIntegerList


##########
Functions Added
##########

diff.IntegerList
diff.NumericList
diff.RleList
slidingIRanges
%pover%
%pwithin%
%poutside%
slidingViews
ManyToOneGrouping
findOverlapPairs
regroup
grouplengths
poverlaps
from
to
nLnode
nRnode
pcompare
pcompareRecursively
elementNROWS


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   algorithm -   match.arg (  algorithm )  if (   algorithm ==  \"intervaltree\" )  {   subject -   IntervalTree (  subject )   findOverlaps (  query ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } else  {   findOverlaps_Ranges (  query ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Ranges ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   findOverlaps_NCList (  query ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } ",
    "replacementFunction": "findOverlaps_Ranges",
    "filename": "findOverlaps-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   findOverlaps (   IRanges (  query ,  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  integer ,  Ranges )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (   IRanges (  query ,  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Views ,  Views )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Views ,  Views )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

3.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Views ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Views ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  Views )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  Views )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   algorithm -   match.arg (  algorithm )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   IRanges ( )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select , algorithm =  algorithm ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   HitsList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   type -   match.arg (  type )   select -   match.arg (  select )   query -   as.list (  query )   subject -   as.list (  subject )   origSubject -  subject  if (   !   is.null (   names (  subject ) ) undefined  !   is.null (   names (  query ) ) )  {   subject -   subject [   names (  query ) ]    names (  subject ) -   names (  query ) # get rid of NA's in names } else  {   subject -   subject [   seq_along (  query ) ] } ## NULL's are introduced where they do not match ## We replace those with empty IRanges    subject [   sapply (  subject ,  is.null ) ] -   list (   IRanges ( ) )   ans -   lapply (   seq_len (   length (  subject ) ) ,  function ( i )  {   findOverlaps (   query [[  i ] ] ,   subject [[  i ] ] , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , select =  select ) } )    names (  ans ) -   names (  subject )  if (   select ==  \"all\" )  {   ans -   HitsList (  ans ,  origSubject ) } else  if (  drop )  {   off -   head (   c (  0L ,   cumsum (   sapply (  origSubject ,  length ) ) ) ,  -  1 )    names (  off ) -   names (  origSubject )  if (   is.null (   names (  ans ) ) )   off -   off [   seq_along (  ans ) ] else   off -   off [   names (  ans ) ]   ans -    unlist (  ans , use.names =  FALSE ) +   rep.int (   unname (  off ) ,   sapply (  ans ,  length ) ) } else  {   ans -   IntegerList (  ans ) }  ans } ",
    "filename": "findOverlaps-methods.txt"
  }
}

6.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

7.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

8.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

9.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

10.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

11.
{
  "old_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , algorithm =   match.arg (  algorithm ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "findOverlaps",
    "representation": "findOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , select = c ( \"all\" , \"first\" , \"last\" , \"arbitrary\" ) , drop = FALSE )",
    "body": "{   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =   match.arg (  select ) , drop =  drop ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

12.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   IntegerList (   mapply (  countOverlaps ,  query ,  subject , MoreArgs =   list ( maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , algorithm =   match.arg (  algorithm ) ) , SIMPLIFY =  FALSE ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangesList ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   IntegerList (   mapply (  countOverlaps ,  query ,  subject , MoreArgs =   list ( maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) , SIMPLIFY =  FALSE ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

13.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  ViewsList ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

14.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  ViewsList ,  Vector )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =  type ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

15.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  Vector ,  ViewsList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =  type ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

16.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

17.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

18.
{
  "old_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   countOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , algorithm =   match.arg (  algorithm ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "countOverlaps",
    "representation": "countOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   countOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

19.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   query [   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) , algorithm =   match.arg (  algorithm ) ) , use.names =  FALSE ) , ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   query [   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE ) , ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}

20.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   query [   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) , algorithm =   match.arg (  algorithm ) ) , use.names =  FALSE ) , ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   query [   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE ) , ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}

21.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   query [  !   is.na (   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) , algorithm =   match.arg (  algorithm ) ) ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) )",
    "body": "{   query [  !   is.na (   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}

22.
{
  "old_function": {
    "name": "nearest",
    "representation": "nearest",
    "signature": "c (  Ranges ,  RangesORmissing )",
    "parameters": "function ( x , subject , select = c ( \"arbitrary\" , \"all\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   select -   match.arg (  select )  if (  !   missing (  subject ) )  {   ol -   findOverlaps (  x ,  subject , select =  select , algorithm =   match.arg (  algorithm ) ) } else  {   subject -  x   ol -   findOverlaps (  x , select =  select , algorithm =   match.arg (  algorithm ) , ignoreSelf =  TRUE ) }  if (   select ==  \"all\" )  {   olv -   selectHits (  ol , select =  \"first\" ) } else   olv -  ol   x -   x [   is.na (  olv ) ]   before -   precede (  x ,  subject ,  if (   select ==  \"all\" )  \"all\" else  \"first\" )   after -   follow (  x ,  subject ,  if (   select ==  \"all\" )  \"all\" else  \"last\" )  if (   select ==  \"all\" )  {   before0 -  before   before -   selectHits (  before , select =  \"first\" )   after0 -  after   after -   selectHits (  after , select =  \"first\" ) }   leftdist -  (     start (  subject ) [  before ] -   end (  x ) )   rightdist -  (    start (  x ) -    end (  subject ) [  after ] )   left -   leftdist undefined  rightdist    left [   is.na (  left ) ] -    is.na (  after ) [   is.na (  left ) ]  if (   select ==  \"all\" )  {   filterHits -  function ( hits , i )  {   m -   as.matrix (   hits [    as (  hits ,  \"IRanges\" ) [  i ] ] )    m [ ,  1L ] -   map [   m [ ,  1L ] ]  m }   map -   which (   is.na (  olv ) )   right -  !  left    left [   leftdist ==  rightdist ] -  TRUE   m -   rbind (   as.matrix (  ol ) ,   filterHits (  before0 ,  left ) ,   filterHits (  after0 ,  right ) )   m -   m [   S4Vectors ::: orderIntegerPairs (   m [ ,  1L ] ,   m [ ,  2L ] ) , , drop =  FALSE ] ## unname() required because in case 'm' has only 1 row ## 'm[ , 1L]' and 'm[ , 2L]' will return a named atomic vector    ol @ queryHits -   unname (   m [ ,  1L ] )    ol @ subjectHits -   unname (   m [ ,  2L ] ) } else  {    olv [   is.na (  olv ) ] -   ifelse (  left ,  before ,  after )   ol -  olv }  ol } ",
    "filename": "nearest-methods.txt"
  },
  "new_function": {
    "name": "nearest",
    "representation": "nearest",
    "signature": "c (  Ranges ,  RangesORmissing )",
    "parameters": "function ( x , subject , select = c ( \"arbitrary\" , \"all\" ) )",
    "body": "{   select -   match.arg (  select )  if (  !   missing (  subject ) )  {   ol -   findOverlaps (  x ,  subject , select =  select ) } else  {   subject -  x   ol -   findOverlaps (  x , select =  select , drop.self =  TRUE ) }  if (   select ==  \"all\" )  {   olv -   selectHits (  ol , select =  \"first\" ) } else   olv -  ol   x -   x [   is.na (  olv ) ]   before -   precede (  x ,  subject ,  if (   select ==  \"all\" )  \"all\" else  \"first\" )   after -   follow (  x ,  subject ,  if (   select ==  \"all\" )  \"all\" else  \"last\" )  if (   select ==  \"all\" )  {   before0 -  before   before -   selectHits (  before , select =  \"first\" )   after0 -  after   after -   selectHits (  after , select =  \"first\" ) }   leftdist -  (     start (  subject ) [  before ] -   end (  x ) )   rightdist -  (    start (  x ) -    end (  subject ) [  after ] )   left -   leftdist undefined  rightdist    left [   is.na (  left ) ] -    is.na (  after ) [   is.na (  left ) ]  if (   select ==  \"all\" )  {   filterHits -  function ( hits , i )  {   m -   as.matrix (   hits [    as (  hits ,  \"IRanges\" ) [  i ] ] )    m [ ,  1L ] -   map [   m [ ,  1L ] ]  m }   map -   which (   is.na (  olv ) )   right -  !  left    left [   leftdist ==  rightdist ] -  TRUE   m -   rbind (   as.matrix (  ol ) ,   filterHits (  before0 ,  left ) ,   filterHits (  after0 ,  right ) )   m -   m [   orderIntegerPairs (   m [ ,  1L ] ,   m [ ,  2L ] ) , , drop =  FALSE ] ## unname() required because in case 'm' has only 1 row ## 'm[ , 1L]' and 'm[ , 2L]' will return a named atomic vector    ol @ from -   unname (   m [ ,  1L ] )    ol @ to -   unname (   m [ ,  2L ] ) } else  {    olv [   is.na (  olv ) ] -   ifelse (  left ,  before ,  after )   ol -  olv }  ol } ",
    "filename": "nearest-methods.txt"
  }
}

23.
{
  "old_function": {
    "name": "distanceToNearest",
    "representation": "distanceToNearest",
    "signature": "c (  Ranges ,  RangesORmissing )",
    "parameters": "function ( x , subject , select = c ( \"arbitrary\" , \"all\" ) , algorithm = c ( \"nclist\" , \"intervaltree\" ) )",
    "body": "{   select -   match.arg (  select )  if (   missing (  subject ) )  {   subject -  x   x_nearest -   nearest (  x , select =  select , algorithm =   match.arg (  algorithm ) ) } else  {   x_nearest -   nearest (  x ,  subject , select =  select , algorithm =   match.arg (  algorithm ) ) }  if (   select ==  \"arbitrary\" )  {   queryHits -    seq_along (  x ) [  !   is.na (  x_nearest ) ]   subjectHits -   x_nearest [  !   is.na (  x_nearest ) ] } else  {   queryHits -   queryHits (  x_nearest )   subjectHits -   subjectHits (  x_nearest ) }  if (   !   length (  subjectHits ) ||   all (   is.na (  subjectHits ) ) )  {   Hits ( queryLength =   length (  x ) , subjectLength =   length (  subject ) , distance =   integer (  0 ) ) } else  {   distance =   distance (   x [  queryHits ] ,   subject [  subjectHits ] )   Hits (  queryHits ,  subjectHits ,   length (  x ) ,   length (  subject ) ,  distance ) } } ",
    "filename": "nearest-methods.txt"
  },
  "new_function": {
    "name": "distanceToNearest",
    "representation": "distanceToNearest",
    "signature": "c (  Ranges ,  RangesORmissing )",
    "parameters": "function ( x , subject , select = c ( \"arbitrary\" , \"all\" ) )",
    "body": "{   select -   match.arg (  select )  if (   missing (  subject ) )  {   subject -  x   x_nearest -   nearest (  x , select =  select ) } else  {   x_nearest -   nearest (  x ,  subject , select =  select ) }  if (   select ==  \"arbitrary\" )  {   queryHits -    seq_along (  x ) [  !   is.na (  x_nearest ) ]   subjectHits -   x_nearest [  !   is.na (  x_nearest ) ] } else  {   queryHits -   queryHits (  x_nearest )   subjectHits -   subjectHits (  x_nearest ) }  if (   !   length (  subjectHits ) ||   all (   is.na (  subjectHits ) ) )  {   Hits ( nLnode =   length (  x ) , nRnode =   length (  subject ) , distance =   integer (  0 ) , sort.by.query =  TRUE ) } else  {   distance =   distance (   x [  queryHits ] ,   subject [  subjectHits ] )   Hits (  queryHits ,  subjectHits ,   length (  x ) ,   length (  subject ) ,  distance , sort.by.query =  TRUE ) } } ",
    "filename": "nearest-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_3 iranges_release_3_4

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_3 iranges_release_3_4",
    "desc_release_old": "2.6.1",
    "desc_release_new": "2.8.2",
    "old_release_number": 13,
    "new_release_number": 14,
    "function_removals": 0,
    "function_additions": 6,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

ManyToManyGrouping
selectNearest
slidingWindows
arbind
acbind
ifelse


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , by = character ( ) , drop.empty.ranges = FALSE , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{   .Deprecated ( msg =   c (  \"the \\\"reduce\\\" method for RangedData object \" ,  \"is deprecated\" ) )  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1L ] ]   values -    values (  y ) [[  1L ] ]   inds -   unname (   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (     ncol (  x ) ==  0 ||    length (  by ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   listData -   S4Vectors ::: make_zero_col_DataFrame (   sum (   elementNROWS (  ranges ) ) )   end -   cumsum (   elementNROWS (  ranges ) )    names (  end ) -   names (  ranges )   partitioning -   PartitioningByEnd (  end )   initialize (  x , ranges =  ranges , values =   relist (  listData ,  partitioning ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "inter-range-methods.txt"
  },
  "new_function": {
    "name": "reduce",
    "representation": "reduce",
    "signature": "RangedData",
    "parameters": "function ( x , drop.empty.ranges = FALSE , by = character ( ) , min.gapwidth = 1L , with.inframe.attrib = FALSE )",
    "body": "{   .Defunct ( msg =   c (  \"the \\\"reduce\\\" method for RangedData object \" ,  \"is defunct\" ) )  if (  !   isTRUEorFALSE (  drop.empty.ranges ) )   stop (  \"'drop.empty.ranges' must be TRUE or FALSE\" )  if (  !   isSingleNumber (  min.gapwidth ) )   stop (  \"'min.gapwidth' must be a single integer\" )  if (  !   is.integer (  min.gapwidth ) )   min.gapwidth -   as.integer (  min.gapwidth )  if (   min.gapwidth undefined  0L )   stop (  \"'min.gapwidth' must be non-negative\" )   FUN -  function ( y )  {   name -   names (  y )   ranges -    ranges (  y ) [[  1L ] ]   values -    values (  y ) [[  1L ] ]   inds -   unname (   split (   seq_len (   nrow (  values ) ) ,   lapply (  values ,  as.vector ) ) )   rlist -   lapply (  inds ,  function ( i )  {   rngs -   reduce (   ranges [  i ] , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   list ( ranges =  rngs , values =   values [   rep (  i , length.out =   length (  rngs ) ) , , drop =  FALSE ] ) } )   ranges -   IRangesList (   do.call (  c ,   lapply (  rlist ,  \"[[\" ,  \"ranges\" ) ) )    names (  ranges ) -  name   values -   SplitDataFrameList (   do.call (  rbind ,   lapply (  rlist ,  \"[[\" ,  \"values\" ) ) )    names (  values ) -  name   new2 (   class (  y ) , ranges =  ranges , values =  values , check =  FALSE ) }  if (     ncol (  x ) ==  0 ||    length (  by ) ==  0 )  {   ranges -   reduce (   ranges (  x ) , drop.empty.ranges =  drop.empty.ranges , min.gapwidth =  min.gapwidth , with.inframe.attrib =  with.inframe.attrib )   listData -   S4Vectors ::: make_zero_col_DataFrame (   sum (   elementNROWS (  ranges ) ) )   end -   cumsum (   elementNROWS (  ranges ) )    names (  end ) -   names (  ranges )   partitioning -   PartitioningByEnd (  end )   initialize (  x , ranges =  ranges , values =   relist (  listData ,  partitioning ) ) } else  {   endoapply (   x [ ,  by ] ,  FUN ) } } ",
    "filename": "inter-range-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_4 iranges_release_3_5

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_4 iranges_release_3_5",
    "desc_release_old": "2.8.2",
    "desc_release_new": "2.10.5",
    "old_release_number": 14,
    "new_release_number": 15,
    "function_removals": 21,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 21
}

##########
Functions Removed
##########

RangedDataList
RDApplyParams
ngap
rangedData
rangedData<-
applyFun
applyFun<-
applyParams
applyParams<-
filterRules<-
simplify
simplify<-
reducerFun
reducerFun<-
reducerParams
reducerParams<-
iteratorFun
iteratorFun<-
rdapply
rep.int
filterRules


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_5 iranges_release_3_6

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_5 iranges_release_3_6",
    "desc_release_old": "2.10.5",
    "desc_release_new": "2.12.0",
    "old_release_number": 15,
    "new_release_number": 16,
    "function_removals": 8,
    "function_additions": 9,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 6,
    "total_count": 14
}

##########
Functions Removed
##########

diff.IntegerList
diff.NumericList
diff.RleList
grouplength
arbind
acbind
xtfrm
ifelse


##########
Functions Added
##########

diff.AtomicList
IPos
rglist
pos
overlapsRanges
ifelse2
as.character
as.factor
is.unsorted


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "Hits",
    "parameters": "function ( x , query , subject )",
    "body": "{  if (   !   is (  query ,  \"Ranges\" ) ||    length (  query ) !=   queryLength (  x ) )   stop (  \"'query' must be a Ranges of length equal to number of queries\" )  if (   !   is (  subject ,  \"Ranges\" ) ||    length (  subject ) !=   subjectLength (  x ) )   stop (  \"'subject' must be a Ranges of length equal to number of subjects\" )   m -   as.matrix (  x )   qstart -    start (  query ) [   m [ ,  1L ] ]   qend -    end (  query ) [   m [ ,  1L ] ]   sstart -    start (  subject ) [   m [ ,  2L ] ]   send -    end (  subject ) [   m [ ,  2L ] ]   IRanges (   pmax.int (  qstart ,  sstart ) ,   pmin.int (  send ,  qend ) ) } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "Hits",
    "parameters": "function ( x , use.names = TRUE , use.mcols = FALSE , query , subject )",
    "body": "{   msg -   c (  \"\\\"ranges\\\" method for Hits objects is deprecated. \" ,  \"Please use overlapsRanges() instead.\" )   .Deprecated ( msg =   wmsg (  msg ) )   query_is_missing -   missing (  query )   subject_is_missing -   missing (  subject )  if (   query_is_missing ||  subject_is_missing )  {   query -  if (  subject_is_missing )  use.names else  use.mcols   subject -  if (  query_is_missing )  use.mcols else  use.names }   overlapsRanges (  query ,  subject ,  x ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

1.
{
  "old_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "HitsList",
    "parameters": "function ( x , query , subject )",
    "body": "{  if (   !   is (  query ,  \"RangesList\" ) ||    length (  query ) !=   length (  x ) )   stop (  \"'query' must be a RangesList of length equal to that of 'x'\" )  if (   !   is (  subject ,  \"RangesList\" ) ||    length (  subject ) !=   length (  x ) )   stop (  \"'subject' must be a RangesList of length equal to that of 'x'\" )   els -   as.list (  x , use.names =  FALSE )   queries -   as.list (  query , use.names =  FALSE )   subjects -   as.list (  subject , use.names =  FALSE )   ans -   do.call (  RangesList ,   lapply (   seq_len (   length (  x ) ) ,  function ( i )  {   ranges (   els [[  i ] ] ,   queries [[  i ] ] ,   subjects [[  i ] ] ) } ) )    names (  ans ) -   names (  x )  ans } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "HitsList",
    "parameters": "function ( x , use.names = TRUE , use.mcols = FALSE , query , subject )",
    "body": "{   msg -   c (  \"\\\"ranges\\\" method for HitsList objects is deprecated. \" ,  \"Please use overlapsRanges() instead.\" )   .Deprecated ( msg =   wmsg (  msg ) )   query_is_missing -   missing (  query )   subject_is_missing -   missing (  subject )  if (   query_is_missing ||  subject_is_missing )  {   query -  if (  subject_is_missing )  use.names else  use.mcols   subject -  if (  query_is_missing )  use.mcols else  use.names }   overlapsRanges (  query ,  subject ,  x ) } ",
    "filename": "findOverlaps-methods.txt"
  }
}

2.
{
  "old_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "NCLists",
    "parameters": "function ( x , use.mcols = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  use.mcols ) )   stop (  \"'use.mcols' must be TRUE or FALSE\" )   ans -   x @ rglist  if (  use.mcols )    mcols (  ans ) -   mcols (  x )  ans } ",
    "filename": "NCList-class.txt"
  },
  "new_function": {
    "name": "ranges",
    "representation": "ranges",
    "signature": "NCLists",
    "parameters": "function ( x , use.names = TRUE , use.mcols = FALSE )",
    "body": "{  if (  !   isTRUEorFALSE (  use.names ) )   stop (  \"'use.names' must be TRUE or FALSE\" )  if (  !   isTRUEorFALSE (  use.mcols ) )   stop (  \"'use.mcols' must be TRUE or FALSE\" )   ans -   x @ rglist  if (  !  use.names )    names (  ans ) -  NULL  if (  use.mcols )    mcols (  ans ) -   mcols (  x )  ans } ",
    "filename": "NCList-class.txt"
  }
}

3.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   o -   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE )  if (  invert )   query [  !  o , ] else   query [  o , ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangedData )",
    "parameters": "function ( x , ranges , maxgap = - 1L , minoverlap = 0L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   .Deprecated ( msg =   wmsg (  .subsetByOverlaps_RangedData_deprecation_msg ) )   ov_any -   unlist (  !   is.na (   findOverlaps (   ranges (  x ) ,   ranges (  ranges ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE )  if (  invert )   ov_any -  !  ov_any   x [  ov_any ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}

4.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   o -   unlist (  !   is.na (   findOverlaps (   ranges (  query ) ,  subject , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE )  if (  invert )   query [  !  o , ] else   query [  o , ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangedData ,  RangesList )",
    "parameters": "function ( x , ranges , maxgap = - 1L , minoverlap = 0L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   .Deprecated ( msg =   wmsg (  .subsetByOverlaps_RangedData_deprecation_msg ) )   ov_any -   unlist (  !   is.na (   findOverlaps (   ranges (  x ) ,  ranges , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) ) , use.names =  FALSE )  if (  invert )   ov_any -  !  ov_any   x [  ov_any ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}

5.
{
  "old_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( query , subject , maxgap = 0L , minoverlap = 1L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   o -  !   is.na (   findOverlaps (  query ,   ranges (  subject ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) )  if (  invert )   query [  !  o ] else   query [  o ] } ",
    "filename": "findOverlaps-methods.txt"
  },
  "new_function": {
    "name": "subsetByOverlaps",
    "representation": "subsetByOverlaps",
    "signature": "c (  RangesList ,  RangedData )",
    "parameters": "function ( x , ranges , maxgap = - 1L , minoverlap = 0L , type = c ( \"any\" , \"start\" , \"end\" , \"within\" , \"equal\" ) , invert = FALSE )",
    "body": "{   .Deprecated ( msg =   wmsg (  .subsetByOverlaps_RangedData_deprecation_msg ) )   ov_any -  !   is.na (   findOverlaps (  x ,   ranges (  ranges ) , maxgap =  maxgap , minoverlap =  minoverlap , type =   match.arg (  type ) , select =  \"arbitrary\" ) )  if (  invert )   ov_any -  !  ov_any   x [  ov_any ] } ",
    "filename": "findOverlaps-methods.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_6 iranges_release_3_7

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_6 iranges_release_3_7",
    "desc_release_old": "2.12.0",
    "desc_release_new": "2.14.12",
    "old_release_number": 16,
    "new_release_number": 17,
    "function_removals": 5,
    "function_additions": 14,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 6
}

##########
Functions Removed
##########

$<-
subset
update
endoapply
mendoapply


##########
Functions Added
##########

heads
tails
INCOMPATIBLE_ARANGES_MSG
extractListFragments
equisplit
windows
update_ranges
cvg
updateObject
concatenateObjects
extractROWS
replaceROWS
getListElement
parallelSlotNames


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , chunksize , nchunk )",
    "body": "{   totalsize -   .normarg_totalsize (  totalsize )  if (  !   missing (  chunksize ) )  {  if (  !   missing (  nchunk ) )   stop (  \"only one of 'chunksize' and 'nchunk' can be specified\" ) ## All chunks will have the requested size, except maybe the last one.   chunksize -   .normarg_chunksize_or_nchunk (  chunksize ,  totalsize ,  \"chunksize\" )  if (   totalsize ==  0L )   return (   PartitioningByEnd ( ) )   quot -   totalsize %/%  chunksize # integer division   ans_end -   cumsum (   rep.int (  chunksize ,  quot ) )  if (    quot ==  0L ||    ans_end [[  quot ] ] !=  totalsize )   ans_end -   c (  ans_end ,  totalsize ) } else  {  if (   missing (  nchunk ) )   stop (  \"one of 'chunksize' and 'nchunk' must be specified\" ) ## All chunks will have more or less the same size, with the difference ## between smallest and biggest chunks guaranteed to be   nchunk -   .normarg_chunksize_or_nchunk (  nchunk ,  totalsize ,  \"nchunk\" )  if (   nchunk ==  0L )   return (   PartitioningByEnd ( ) )   chunksize -   totalsize /  nchunk # floating point division   ans_end -   as.integer (   cumsum (   rep.int (  chunksize ,  nchunk ) ) ) ## The last value in 'ans_end' *should* be 'totalsize' but there is ## always some uncertainty about what coercing the result of a floating ## point operation to integer will produce. So we set this value ## manually to 'totalsize' just in case.    ans_end [[  nchunk ] ] -  totalsize }   PartitioningByEnd (  ans_end ) } ",
    "filename": "IRanges-utils.txt"
  },
  "new_function": {
    "name": "breakInChunks",
    "representation": "breakInChunks",
    "parameters": "function ( totalsize , nchunk , chunksize )",
    "body": "{   totalsize -   .normarg_totalsize (  totalsize )  if (  !   missing (  nchunk ) )  {  if (  !   missing (  chunksize ) )   stop (  \"only one of 'nchunk' and 'chunksize' can be specified\" ) ## All chunks will have more or less the same size, with the difference ## between smallest and biggest chunks guaranteed to be   nchunk -   .normarg_nchunk_or_chunksize (  nchunk ,  totalsize ,  \"nchunk\" )  if (   nchunk ==  0L )   return (   PartitioningByEnd ( ) )   chunksize -   totalsize /  nchunk # floating point division   breakpoints -   as.integer (   cumsum (   rep.int (  chunksize ,  nchunk ) ) ) ## The last value in 'breakpoints' *should* be 'totalsize' but there is ## always some uncertainty about what coercing the result of a floating ## point operation to integer will produce. So we set this value ## manually to 'totalsize' just in case.    breakpoints [[  nchunk ] ] -  totalsize } else  {  if (   missing (  chunksize ) )   stop (  \"one of 'nchunk' and 'chunksize' must be specified\" ) ## All chunks will have the requested size, except maybe the last one.   chunksize -   .normarg_nchunk_or_chunksize (  chunksize ,  totalsize ,  \"chunksize\" )  if (   totalsize ==  0L )   return (   PartitioningByEnd ( ) )   quot -   totalsize %/%  chunksize # integer division   breakpoints -   cumsum (   rep.int (  chunksize ,  quot ) )  if (    quot ==  0L ||    breakpoints [[  quot ] ] !=  totalsize )   breakpoints -   c (  breakpoints ,  totalsize ) }   PartitioningByEnd (  breakpoints ) } ",
    "filename": "IRanges-utils.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_7 iranges_release_3_8

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_7 iranges_release_3_8",
    "desc_release_old": "2.14.12",
    "desc_release_new": "2.16.0",
    "old_release_number": 17,
    "new_release_number": 18,
    "function_removals": 3,
    "function_additions": 1,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 3
}

##########
Functions Removed
##########

rev
rep
concatenateObjects


##########
Functions Added
##########

bindROWS


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_8 iranges_release_3_9

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_8 iranges_release_3_9",
    "desc_release_old": "2.16.0",
    "desc_release_new": "2.18.3",
    "old_release_number": 18,
    "new_release_number": 19,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_9 iranges_release_3_11

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_9 iranges_release_3_11",
    "desc_release_old": "2.18.3",
    "desc_release_new": "2.22.2",
    "old_release_number": 19,
    "new_release_number": 20,
    "function_removals": 8,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 8
}

##########
Functions Removed
##########

splitAsList
score
score<-
c
%in%
with
within
parallelSlotNames


##########
Functions Added
##########

as.data.frame.IPosRanges
as.data.frame.IPos
vertical_slot_names


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_11 iranges_release_3_12

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_11 iranges_release_3_12",
    "desc_release_old": "2.22.2",
    "desc_release_new": "2.24.1",
    "old_release_number": 20,
    "new_release_number": 21,
    "function_removals": 7,
    "function_additions": 4,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 7
}

##########
Functions Removed
##########

RangedData
showAsCell
mstack
universe
universe<-
vertical_slot_names
relistToClass


##########
Functions Added
##########

summary.IPosRanges
summary.IPos
ROWNAMES
parallel_slot_names


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_12 iranges_release_3_13

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_12 iranges_release_3_13",
    "desc_release_old": "2.24.1",
    "desc_release_new": "2.26.0",
    "old_release_number": 21,
    "new_release_number": 22,
    "function_removals": 2,
    "function_additions": 5,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 2
}

##########
Functions Removed
##########

solveUserSEW0
RangesList


##########
Functions Added
##########

commonColnames
commonColnames<-
ROWNAMES<-
startsWith
endsWith


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_13 iranges_release_3_14

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_13 iranges_release_3_14",
    "desc_release_old": "2.26.0",
    "desc_release_new": "2.28.0",
    "old_release_number": 22,
    "new_release_number": 23,
    "function_removals": 2,
    "function_additions": 3,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 2
}

##########
Functions Removed
##########

values
values<-


##########
Functions Added
##########

dims
nrows
ncols


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  iranges_release_3_14 iranges_master

{
    "package": "IRanges",
    "release_versions": "iranges_release_3_14 iranges_master",
    "desc_release_old": "2.28.0",
    "desc_release_new": "2.29.1",
    "old_release_number": 23,
    "new_release_number": 24,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

