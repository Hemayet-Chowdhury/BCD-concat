
###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_4 fgsea_release_3_5

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_4 fgsea_release_3_5",
    "desc_release_old": "1.0.2",
    "desc_release_new": "1.2.1",
    "old_release_number": 0,
    "new_release_number": 1,
    "function_removals": 1,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 1
}

##########
Functions Removed
##########

calcGseaStatCumulative


##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_5 fgsea_release_3_6

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_5 fgsea_release_3_6",
    "desc_release_old": "1.2.1",
    "desc_release_new": "1.4.1",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_6 fgsea_release_3_7

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_6 fgsea_release_3_7",
    "desc_release_old": "1.4.1",
    "desc_release_new": "1.6.0",
    "old_release_number": 2,
    "new_release_number": 3,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

collapsePathways
fgseaLabel


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_7 fgsea_release_3_8

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_7 fgsea_release_3_8",
    "desc_release_old": "1.6.0",
    "desc_release_new": "1.8.0",
    "old_release_number": 3,
    "new_release_number": 4,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_8 fgsea_release_3_9

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_8 fgsea_release_3_9",
    "desc_release_old": "1.8.0",
    "desc_release_new": "1.10.1",
    "old_release_number": 4,
    "new_release_number": 5,
    "function_removals": 0,
    "function_additions": 2,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########

fgseaMultilevel
multilevelError


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_9 fgsea_release_3_11

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_9 fgsea_release_3_11",
    "desc_release_old": "1.10.1",
    "desc_release_new": "1.14.0",
    "old_release_number": 5,
    "new_release_number": 6,
    "function_removals": 0,
    "function_additions": 5,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########

collapsePathwaysORA
fgseaSimple
fora
mapIdsList
writeGmtPathways


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "fgseaMultilevel",
    "representation": "fgseaMultilevel",
    "parameters": "function ( pathways , stats , sampleSize = 101 , minSize = 1 , maxSize = Inf , absEps = 0 , nproc = 0 , BPPARAM = NULL )",
    "body": "{ # Error if pathways is not a list  if (  !   is.list (  pathways ) )  {   stop (  \"pathways should be a list with each element containing names of the stats argument\" ) } # Error if stats is not named  if (   is.null (   names (  stats ) ) )  {   stop (  \"stats should be named\" ) } # Warning message for ties in stats   ties -   sum (   duplicated (   stats [   stats !=  0 ] ) )  if (   ties !=  0 )  {   warning (  \"There are ties in the preranked stats (\" ,   paste (   round (    ties *  100 /   length (  stats ) , digits =  2 ) ) ,  \"% of the list).\\n\" ,  \"The order of those tied genes will be arbitrary, which may produce unexpected results.\" ) } # Warning message for duplicate gene names  if (   any (   duplicated (   names (  stats ) ) ) )  {   warning (  \"There are duplicate gene names, fgsea may produce unexpected results\" ) } # Warning message for to small value for sampleSize  if (   sampleSize undefined  3 )  {   warning (  \"sampleSize is too small, so sampleSize = 3 is set.\" )   sampleSize -   max (  3 ,  sampleSize ) } #To avoid warnings during the check   log2err =   nMoreExtreme =   pathway =   pval =   padj =  NULL   ES =   NES =   size =   leadingEdge =  NULL   . =  \"damn notes\"   nPermSimple -  1000 # number of samples for initial fgseaSimple run: fast and good enough   minSize -   max (  minSize ,  1 )   absEps -   max (  0 ,   min (  1 ,  absEps ) )   stats -   sort (  stats , decreasing =  TRUE )  if (    sampleSize %%  2 ==  0 )  {   sampleSize -   sampleSize +  1 }   pathwaysFiltered -   lapply (  pathways ,  function ( p )  {   as.vector (   na.omit (   fmatch (  p ,   names (  stats ) ) ) ) } )   pathwaysSizes -   sapply (  pathwaysFiltered ,  length )   toKeep -   which (    minSize =  pathwaysSizes undefined   pathwaysSizes =  maxSize )   m -   length (  toKeep )  if (   m ==  0 )  {   return (   data.table ( pathway =   character ( ) , pval =   numeric ( ) , padj =   numeric ( ) , log2err =   numeric ( ) , ES =   numeric ( ) , NES =   numeric ( ) , size =   integer ( ) , leadingEdge =   list ( ) ) ) }   pathwaysFiltered -   pathwaysFiltered [  toKeep ]   pathwaysSizes -   pathwaysSizes [  toKeep ]   gseaStatRes -   do.call (  rbind ,   lapply (  pathwaysFiltered ,  calcGseaStat , stats =  stats , returnLeadingEdge =  TRUE ) )   leadingEdges -   mapply (  \"[\" ,   list (   names (  stats ) ) ,   gseaStatRes [ ,  \"leadingEdge\" ] , SIMPLIFY =  FALSE )   pathwayScores -   unlist (   gseaStatRes [ ,  \"res\" ] )   universe -   seq_along (  stats )   seeds -   sample.int (   10 ^  9 ,  1 )   BPPARAM -   setUpBPPARAM ( nproc =  nproc , BPPARAM =  BPPARAM )   simpleFgseaRes -   fgseaSimpleImpl ( pathwayScores =  pathwayScores , pathwaysSizes =  pathwaysSizes , pathwaysFiltered =  pathwaysFiltered , leadingEdges =  leadingEdges , permPerProc =  nPermSimple , seeds =  seeds , toKeepLength =  m , stats =  stats , BPPARAM =   SerialParam ( ) )   simpleError -    1 /   log (  2 ) *   sqrt (    trigamma (   simpleFgseaRes $ nMoreExtreme ) -   trigamma (  nPermSimple ) )   multError -   sapply (   (    simpleFgseaRes $ nMoreExtreme +  1 ) /  nPermSimple ,  multilevelError ,  sampleSize )  if (   all (   multError undefined  simpleError ) )  {   simpleFgseaRes [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (  nMoreExtreme ) -   trigamma (  (  nPermSimple ) ) ) ]   setorder (  simpleFgseaRes ,  pathway )   simpleFgseaRes -   simpleFgseaRes [ ,   . (  pathway ,  pval ,  padj ,  log2err ,  ES ,  NES ,  size ,  leadingEdge ) ]   simpleFgseaRes -   simpleFgseaRes [ ]   return (  simpleFgseaRes ) }   dtSimpleFgsea -   simpleFgseaRes [   simpleError undefined  multError ]   dtSimpleFgsea [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (  nMoreExtreme ) -   trigamma (  nPermSimple ) ) ]   dtMultilevel -   simpleFgseaRes [   multError undefined  simpleError ]   multilevelPathwaysList -   split (  dtMultilevel , by =  \"size\" ) # In most cases, this gives a speed increase with parallel launches.   indxs -   sample (   1 :   length (  multilevelPathwaysList ) )   multilevelPathwaysList -   multilevelPathwaysList [  indxs ]   seed =   sample.int (  1e9 , size =  1 )   pvals -   multilevelImpl (  multilevelPathwaysList ,  stats ,  sampleSize ,  seed ,  absEps , BPPARAM =  BPPARAM )   result -   rbindlist (  multilevelPathwaysList )   result [ ,   pval :=   unlist (  pvals ) ]   result [ ,   log2err :=    sqrt (    floor (   -   log2 (  pval ) +  1 ) *  (    trigamma (   (   sampleSize +  1 ) /  2 ) -   trigamma (   sampleSize +  1 ) ) ) /   log (  2 ) ]   result -   rbindlist (   list (  result ,  dtSimpleFgsea ) , use.names =  TRUE )   result [   pval undefined  absEps ,    c (  \"pval\" ,  \"log2err\" ) :=   list (  absEps ,  NA ) ]   result [ ,   padj :=   p.adjust (  pval , method =  \"BH\" ) ]   result -   result [ ,   . (  pathway ,  pval ,  padj ,  log2err ,  ES ,  NES ,  size ,  leadingEdge ) ]   setorder (  result ,  pathway )   result -   result [ ]  result } ",
    "filename": "fgseaMultilevel.txt"
  },
  "new_function": {
    "name": "fgseaMultilevel",
    "representation": "fgseaMultilevel",
    "parameters": "function ( pathways , stats , sampleSize = 101 , minSize = 1 , maxSize = Inf , eps = 1e-10 , scoreType = c ( \"std\" , \"pos\" , \"neg\" ) , nproc = 0 , gseaParam = 1 , BPPARAM = NULL , absEps = NULL )",
    "body": "{   scoreType -   match.arg (  scoreType )   pp -   preparePathwaysAndStats (  pathways ,  stats ,  minSize ,  maxSize ,  gseaParam ,  scoreType )   pathwaysFiltered -   pp $ filtered   pathwaysSizes -   pp $ sizes   stats -   pp $ stats   m -   length (  pathwaysFiltered )  if (   m ==  0 )  {   return (   data.table ( pathway =   character ( ) , pval =   numeric ( ) , padj =   numeric ( ) , log2err =   numeric ( ) , ES =   numeric ( ) , NES =   numeric ( ) , size =   integer ( ) , leadingEdge =   list ( ) ) ) } # Warning message for deprecated absEps parameter  if (  !   is.null (  absEps ) )  {   warning (  \"You are using deprecated argument `absEps`. \" ,  \"Use `eps` argument instead. \" ,  \"`absEps` was assigned to `eps`.\" )   eps -  absEps } # Warning message for to small value for sampleSize  if (   sampleSize undefined  3 )  {   warning (  \"sampleSize is too small, so sampleSize = 3 is set.\" )   sampleSize -   max (  3 ,  sampleSize ) } #To avoid warnings during the check   log2err =   nMoreExtreme =   pathway =   pval =   padj =  NULL   nLeZero =   nGeZero =   leZeroMean =   geZeroMean =   nLeEs =   nGeEs =   isCpGeHalf =  NULL   ES =   NES =   size =   leadingEdge =  NULL   . =  \"damn notes\"   nPermSimple -  1000 # number of samples for initial fgseaSimple run: fast and good enough   minSize -   max (  minSize ,  1 )   eps -   max (  0 ,   min (  1 ,  eps ) )  if (    sampleSize %%  2 ==  0 )  {   sampleSize -   sampleSize +  1 }   gseaStatRes -   do.call (  rbind ,   lapply (  pathwaysFiltered ,  calcGseaStat , stats =  stats , returnLeadingEdge =  TRUE , scoreType =  scoreType ) )   leadingEdges -   mapply (  \"[\" ,   list (   names (  stats ) ) ,   gseaStatRes [ ,  \"leadingEdge\" ] , SIMPLIFY =  FALSE )   pathwayScores -   unlist (   gseaStatRes [ ,  \"res\" ] )   seeds -   sample.int (   10 ^  9 ,  1 )   BPPARAM -   setUpBPPARAM ( nproc =  nproc , BPPARAM =  BPPARAM )   simpleFgseaRes -   fgseaSimpleImpl ( pathwayScores =  pathwayScores , pathwaysSizes =  pathwaysSizes , pathwaysFiltered =  pathwaysFiltered , leadingEdges =  leadingEdges , permPerProc =  nPermSimple , seeds =  seeds , toKeepLength =  m , stats =  stats , BPPARAM =   SerialParam ( ) , scoreType =  scoreType )   simpleFgseaRes [ ,   leZeroMean :=  NULL ]   simpleFgseaRes [ ,   geZeroMean :=  NULL ]   simpleFgseaRes [ ,   nLeEs :=  NULL ]   simpleFgseaRes [ ,   nGeEs :=  NULL ]   simpleFgseaRes [ ,   nLeZero :=  NULL ]   simpleFgseaRes [ ,   nGeZero :=  NULL ]   unbalanced -   simpleFgseaRes [   is.na (  pval ) ]   unbalanced [ ,   padj :=   as.numeric (  NA ) ]   unbalanced [ ,   log2err :=   as.numeric (  NA ) ]  if (    nrow (  unbalanced ) undefined  0 )  {   warning (  \"There were \" ,   paste (   nrow (  unbalanced ) ) ,  \" pathways for which P-values were not calculated properly due to \" ,  \"unbalanced (positive and negative) gene-level statistic values.\" ) }   simpleFgseaRes -   simpleFgseaRes [  !   is.na (  pval ) ]   simpleError -    1 /   log (  2 ) *   sqrt (    trigamma (    simpleFgseaRes $ nMoreExtreme +  1 ) -   trigamma (   nPermSimple +  1 ) )   multError -   sapply (   (    simpleFgseaRes $ nMoreExtreme +  1 ) /  (   nPermSimple +  1 ) ,  multilevelError ,  sampleSize )  if (   all (   multError =  simpleError ) )  {   simpleFgseaRes [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (  (   nPermSimple +  1 ) ) ) ]   simpleFgseaRes -   rbindlist (   list (  simpleFgseaRes ,  unbalanced ) , use.names =  TRUE )   setorder (  simpleFgseaRes ,  pathway )   simpleFgseaRes [ ,   \"nMoreExtreme\" :=  NULL ]   setcolorder (  simpleFgseaRes ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   simpleFgseaRes -   simpleFgseaRes [ ]   return (  simpleFgseaRes ) }   dtSimpleFgsea -   simpleFgseaRes [   multError =  simpleError ]   dtSimpleFgsea [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (   nPermSimple +  1 ) ) ]   dtMultilevel -   simpleFgseaRes [   multError undefined  simpleError ]   multilevelPathwaysList -   split (  dtMultilevel , by =  \"size\" ) # In most cases, this gives a speed increase with parallel launches.   indxs -   sample (   1 :   length (  multilevelPathwaysList ) )   multilevelPathwaysList -   multilevelPathwaysList [  indxs ]   seed =   sample.int (  1e9 , size =  1 )   sign -  if (   scoreType %in%   c (  \"pos\" ,  \"neg\" ) )  TRUE else  FALSE   cpp.res -   multilevelImpl (  multilevelPathwaysList ,  stats ,  sampleSize ,  seed ,  eps , sign =  sign , BPPARAM =  BPPARAM )   cpp.res -   rbindlist (  cpp.res )   result -   rbindlist (  multilevelPathwaysList )   result [ ,   pval :=   cpp.res $ cppMPval ]   result [ ,   isCpGeHalf :=   cpp.res $ cppIsCpGeHalf ]   result [ ,   log2err :=   multilevelError (  pval , sampleSize =  sampleSize ) ]   result [   isCpGeHalf ==  FALSE ,   log2err :=  NA ]  if (  !   all (   result $ isCpGeHalf ) )  {   warning (  \"For some of the pathways the P-values were likely overestimated. \" ,  \"For such pathways log2err is set to NA.\" ) }   result [ ,   isCpGeHalf :=  NULL ]   result -   rbindlist (   list (  result ,  dtSimpleFgsea ,  unbalanced ) , use.names =  TRUE )   result [ ,   nMoreExtreme :=  NULL ]   result [   pval undefined  eps ,    c (  \"pval\" ,  \"log2err\" ) :=   list (  eps ,  NA ) ]   result [ ,   padj :=   p.adjust (  pval , method =  \"BH\" ) ]  if (   nrow (   result [    pval ==  eps undefined   is.na (  log2err ) ] ) )  {   warning (  \"For some pathways, in reality P-values are less than \" ,   paste (  eps ) ,  \". You can set the `eps` argument to zero for better estimation.\" ) }   setcolorder (  result ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   setorder (  result ,  pathway )   result -   result [ ]  result } ",
    "filename": "fgseaMultilevel.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_11 fgsea_release_3_12

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_11 fgsea_release_3_12",
    "desc_release_old": "1.14.0",
    "desc_release_new": "1.16.0",
    "old_release_number": 6,
    "new_release_number": 7,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 1,
    "total_count": 1
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "fgseaMultilevel",
    "representation": "fgseaMultilevel",
    "parameters": "function ( pathways , stats , sampleSize = 101 , minSize = 1 , maxSize = Inf , eps = 1e-10 , scoreType = c ( \"std\" , \"pos\" , \"neg\" ) , nproc = 0 , gseaParam = 1 , BPPARAM = NULL , absEps = NULL )",
    "body": "{   scoreType -   match.arg (  scoreType )   pp -   preparePathwaysAndStats (  pathways ,  stats ,  minSize ,  maxSize ,  gseaParam ,  scoreType )   pathwaysFiltered -   pp $ filtered   pathwaysSizes -   pp $ sizes   stats -   pp $ stats   m -   length (  pathwaysFiltered )  if (   m ==  0 )  {   return (   data.table ( pathway =   character ( ) , pval =   numeric ( ) , padj =   numeric ( ) , log2err =   numeric ( ) , ES =   numeric ( ) , NES =   numeric ( ) , size =   integer ( ) , leadingEdge =   list ( ) ) ) } # Warning message for deprecated absEps parameter  if (  !   is.null (  absEps ) )  {   warning (  \"You are using deprecated argument `absEps`. \" ,  \"Use `eps` argument instead. \" ,  \"`absEps` was assigned to `eps`.\" )   eps -  absEps } # Warning message for to small value for sampleSize  if (   sampleSize undefined  3 )  {   warning (  \"sampleSize is too small, so sampleSize = 3 is set.\" )   sampleSize -   max (  3 ,  sampleSize ) } #To avoid warnings during the check   log2err =   nMoreExtreme =   pathway =   pval =   padj =  NULL   nLeZero =   nGeZero =   leZeroMean =   geZeroMean =   nLeEs =   nGeEs =   isCpGeHalf =  NULL   ES =   NES =   size =   leadingEdge =  NULL   . =  \"damn notes\"   nPermSimple -  1000 # number of samples for initial fgseaSimple run: fast and good enough   minSize -   max (  minSize ,  1 )   eps -   max (  0 ,   min (  1 ,  eps ) )  if (    sampleSize %%  2 ==  0 )  {   sampleSize -   sampleSize +  1 }   gseaStatRes -   do.call (  rbind ,   lapply (  pathwaysFiltered ,  calcGseaStat , stats =  stats , returnLeadingEdge =  TRUE , scoreType =  scoreType ) )   leadingEdges -   mapply (  \"[\" ,   list (   names (  stats ) ) ,   gseaStatRes [ ,  \"leadingEdge\" ] , SIMPLIFY =  FALSE )   pathwayScores -   unlist (   gseaStatRes [ ,  \"res\" ] )   seeds -   sample.int (   10 ^  9 ,  1 )   BPPARAM -   setUpBPPARAM ( nproc =  nproc , BPPARAM =  BPPARAM )   simpleFgseaRes -   fgseaSimpleImpl ( pathwayScores =  pathwayScores , pathwaysSizes =  pathwaysSizes , pathwaysFiltered =  pathwaysFiltered , leadingEdges =  leadingEdges , permPerProc =  nPermSimple , seeds =  seeds , toKeepLength =  m , stats =  stats , BPPARAM =   SerialParam ( ) , scoreType =  scoreType )   simpleFgseaRes [ ,   leZeroMean :=  NULL ]   simpleFgseaRes [ ,   geZeroMean :=  NULL ]   simpleFgseaRes [ ,   nLeEs :=  NULL ]   simpleFgseaRes [ ,   nGeEs :=  NULL ]   simpleFgseaRes [ ,   nLeZero :=  NULL ]   simpleFgseaRes [ ,   nGeZero :=  NULL ]   unbalanced -   simpleFgseaRes [   is.na (  pval ) ]   unbalanced [ ,   padj :=   as.numeric (  NA ) ]   unbalanced [ ,   log2err :=   as.numeric (  NA ) ]  if (    nrow (  unbalanced ) undefined  0 )  {   warning (  \"There were \" ,   paste (   nrow (  unbalanced ) ) ,  \" pathways for which P-values were not calculated properly due to \" ,  \"unbalanced (positive and negative) gene-level statistic values.\" ) }   simpleFgseaRes -   simpleFgseaRes [  !   is.na (  pval ) ]   simpleError -    1 /   log (  2 ) *   sqrt (    trigamma (    simpleFgseaRes $ nMoreExtreme +  1 ) -   trigamma (   nPermSimple +  1 ) )   multError -   sapply (   (    simpleFgseaRes $ nMoreExtreme +  1 ) /  (   nPermSimple +  1 ) ,  multilevelError ,  sampleSize )  if (   all (   multError =  simpleError ) )  {   simpleFgseaRes [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (  (   nPermSimple +  1 ) ) ) ]   simpleFgseaRes -   rbindlist (   list (  simpleFgseaRes ,  unbalanced ) , use.names =  TRUE )   setorder (  simpleFgseaRes ,  pathway )   simpleFgseaRes [ ,   \"nMoreExtreme\" :=  NULL ]   setcolorder (  simpleFgseaRes ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   simpleFgseaRes -   simpleFgseaRes [ ]   return (  simpleFgseaRes ) }   dtSimpleFgsea -   simpleFgseaRes [   multError =  simpleError ]   dtSimpleFgsea [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (   nPermSimple +  1 ) ) ]   dtMultilevel -   simpleFgseaRes [   multError undefined  simpleError ]   multilevelPathwaysList -   split (  dtMultilevel , by =  \"size\" ) # In most cases, this gives a speed increase with parallel launches.   indxs -   sample (   1 :   length (  multilevelPathwaysList ) )   multilevelPathwaysList -   multilevelPathwaysList [  indxs ]   seed =   sample.int (  1e9 , size =  1 )   sign -  if (   scoreType %in%   c (  \"pos\" ,  \"neg\" ) )  TRUE else  FALSE   cpp.res -   multilevelImpl (  multilevelPathwaysList ,  stats ,  sampleSize ,  seed ,  eps , sign =  sign , BPPARAM =  BPPARAM )   cpp.res -   rbindlist (  cpp.res )   result -   rbindlist (  multilevelPathwaysList )   result [ ,   pval :=   cpp.res $ cppMPval ]   result [ ,   isCpGeHalf :=   cpp.res $ cppIsCpGeHalf ]   result [ ,   log2err :=   multilevelError (  pval , sampleSize =  sampleSize ) ]   result [   isCpGeHalf ==  FALSE ,   log2err :=  NA ]  if (  !   all (   result $ isCpGeHalf ) )  {   warning (  \"For some of the pathways the P-values were likely overestimated. \" ,  \"For such pathways log2err is set to NA.\" ) }   result [ ,   isCpGeHalf :=  NULL ]   result -   rbindlist (   list (  result ,  dtSimpleFgsea ,  unbalanced ) , use.names =  TRUE )   result [ ,   nMoreExtreme :=  NULL ]   result [   pval undefined  eps ,    c (  \"pval\" ,  \"log2err\" ) :=   list (  eps ,  NA ) ]   result [ ,   padj :=   p.adjust (  pval , method =  \"BH\" ) ]  if (   nrow (   result [    pval ==  eps undefined   is.na (  log2err ) ] ) )  {   warning (  \"For some pathways, in reality P-values are less than \" ,   paste (  eps ) ,  \". You can set the `eps` argument to zero for better estimation.\" ) }   setcolorder (  result ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   setorder (  result ,  pathway )   result -   result [ ]  result } ",
    "filename": "fgseaMultilevel.txt"
  },
  "new_function": {
    "name": "fgseaMultilevel",
    "representation": "fgseaMultilevel",
    "parameters": "function ( pathways , stats , sampleSize = 101 , minSize = 1 , maxSize = Inf , eps = 1e-10 , scoreType = c ( \"std\" , \"pos\" , \"neg\" ) , nproc = 0 , gseaParam = 1 , BPPARAM = NULL , nPermSimple = 1000 , absEps = NULL )",
    "body": "{   scoreType -   match.arg (  scoreType )   pp -   preparePathwaysAndStats (  pathways ,  stats ,  minSize ,  maxSize ,  gseaParam ,  scoreType )   pathwaysFiltered -   pp $ filtered   pathwaysSizes -   pp $ sizes   stats -   pp $ stats   m -   length (  pathwaysFiltered )  if (   m ==  0 )  {   return (   data.table ( pathway =   character ( ) , pval =   numeric ( ) , padj =   numeric ( ) , log2err =   numeric ( ) , ES =   numeric ( ) , NES =   numeric ( ) , size =   integer ( ) , leadingEdge =   list ( ) ) ) } # Warning message for deprecated absEps parameter  if (  !   is.null (  absEps ) )  {   warning (  \"You are using deprecated argument `absEps`. \" ,  \"Use `eps` argument instead. \" ,  \"`absEps` was assigned to `eps`.\" )   eps -  absEps } # Warning message for to small value for sampleSize  if (   sampleSize undefined  3 )  {   warning (  \"sampleSize is too small, so sampleSize = 3 is set.\" )   sampleSize -   max (  3 ,  sampleSize ) } #To avoid warnings during the check   log2err =   nMoreExtreme =   pathway =   pval =   padj =  NULL   nLeZero =   nGeZero =   leZeroMean =   geZeroMean =   nLeEs =   nGeEs =   isCpGeHalf =  NULL   ES =   NES =   size =   leadingEdge =  NULL   . =  \"damn notes\"   minSize -   max (  minSize ,  1 )   eps -   max (  0 ,   min (  1 ,  eps ) )  if (    sampleSize %%  2 ==  0 )  {   sampleSize -   sampleSize +  1 }   gseaStatRes -   do.call (  rbind ,   lapply (  pathwaysFiltered ,  calcGseaStat , stats =  stats , returnLeadingEdge =  TRUE , scoreType =  scoreType ) )   leadingEdges -   mapply (  \"[\" ,   list (   names (  stats ) ) ,   gseaStatRes [ ,  \"leadingEdge\" ] , SIMPLIFY =  FALSE )   pathwayScores -   unlist (   gseaStatRes [ ,  \"res\" ] )   seeds -   sample.int (   10 ^  9 ,  1 )   BPPARAM -   setUpBPPARAM ( nproc =  nproc , BPPARAM =  BPPARAM )   simpleFgseaRes -   fgseaSimpleImpl ( pathwayScores =  pathwayScores , pathwaysSizes =  pathwaysSizes , pathwaysFiltered =  pathwaysFiltered , leadingEdges =  leadingEdges , permPerProc =  nPermSimple , seeds =  seeds , toKeepLength =  m , stats =  stats , BPPARAM =   SerialParam ( ) , scoreType =  scoreType )   switch (  scoreType , std =   simpleFgseaRes [ ,   modeFraction :=   ifelse (   ES =  0 ,  nGeZero ,  nLeZero ) ] , pos =   simpleFgseaRes [ ,   modeFraction :=  nGeZero ] , neg =   simpleFgseaRes [ ,   modeFraction :=  nLeZero ] )   simpleFgseaRes [ ,   leZeroMean :=  NULL ]   simpleFgseaRes [ ,   geZeroMean :=  NULL ]   simpleFgseaRes [ ,   nLeEs :=  NULL ]   simpleFgseaRes [ ,   nGeEs :=  NULL ]   simpleFgseaRes [ ,   nLeZero :=  NULL ]   simpleFgseaRes [ ,   nGeZero :=  NULL ]   simpleFgseaRes [   modeFraction undefined  10 ,   pval :=   as.numeric (  NA ) ]   simpleFgseaRes [   modeFraction undefined  10 ,   padj :=   as.numeric (  NA ) ]   simpleFgseaRes [   modeFraction undefined  10 ,   NES :=   as.numeric (  NA ) ]  if (   any (    simpleFgseaRes $ modeFraction undefined  10 ) )  {   warning (  \"There were \" ,   paste (   sum (    simpleFgseaRes $ modeFraction undefined  10 ) ) ,  \" pathways for which P-values were not calculated properly due to \" ,  \"unbalanced (positive and negative) gene-level statistic values. \" ,  \"For such pathways pval, padj, NES, log2err are set to NA. \" ,  \"You can try to increase the value of the argument nPermSimple (for example set it nPermSimple = \" ,   paste0 (   format (   nPermSimple *  10 , scientific =  FALSE ) ,  \")\" ) ) } # Storing NA fgseaSimple results in a separate data.table   naSimpleRes -   simpleFgseaRes [   is.na (  pval ) ]   naSimpleRes [ ,   padj :=   as.numeric (  NA ) ]   naSimpleRes [ ,   log2err :=   as.numeric (  NA ) ]   naSimpleRes [ ,   modeFraction :=  NULL ]   simpleFgseaRes -   simpleFgseaRes [  !   is.na (  pval ) ]   leftBorder -   log2 (   qbeta (  0.025 , shape1 =   simpleFgseaRes $ nMoreExtreme , shape2 =    nPermSimple -   simpleFgseaRes $ nMoreExtreme +  1 ) )   rightBorder -   log2 (   qbeta (   1 -  0.025 , shape1 =    simpleFgseaRes $ nMoreExtreme +  1 , shape2 =   nPermSimple -   simpleFgseaRes $ nMoreExtreme ) )   crudeEstimator -   log2 (   (    simpleFgseaRes $ nMoreExtreme +  1 ) /  (   nPermSimple +  1 ) )   simpleError -   0.5 *   pmax (   crudeEstimator -  leftBorder ,   rightBorder -  crudeEstimator )   multError -   sapply (   (    simpleFgseaRes $ nMoreExtreme +  1 ) /  (   nPermSimple +  1 ) ,  multilevelError ,  sampleSize )  if (   all (   multError =  simpleError ) )  {   simpleFgseaRes [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (  (   nPermSimple +  1 ) ) ) ]   simpleFgseaRes [ ,   modeFraction :=  NULL ]   simpleFgseaRes -   rbindlist (   list (  simpleFgseaRes ,  naSimpleRes ) , use.names =  TRUE )   setorder (  simpleFgseaRes ,  pathway )   simpleFgseaRes [ ,   \"nMoreExtreme\" :=  NULL ]   setcolorder (  simpleFgseaRes ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   simpleFgseaRes -   simpleFgseaRes [ ]   return (  simpleFgseaRes ) }   dtSimpleFgsea -   simpleFgseaRes [   multError =  simpleError ]   dtSimpleFgsea [ ,   log2err :=    1 /   log (  2 ) *   sqrt (    trigamma (   nMoreExtreme +  1 ) -   trigamma (   nPermSimple +  1 ) ) ]   dtSimpleFgsea [ ,   modeFraction :=  NULL ]   dtMultilevel -   simpleFgseaRes [   multError undefined  simpleError ] # Probability estimation in the denominator of the multilevel algortihm # (s_r(q)   dtMultilevel [ ,   \"denomProb\" :=   (   modeFraction +  1 ) /  (   nPermSimple +  1 ) ]   multilevelPathwaysList -   split (  dtMultilevel , by =  \"size\" ) # In most cases, this gives a speed increase with parallel launches.   indxs -   sample (   1 :   length (  multilevelPathwaysList ) )   multilevelPathwaysList -   multilevelPathwaysList [  indxs ]   seed =   sample.int (  1e9 , size =  1 )   sign -  if (   scoreType %in%   c (  \"pos\" ,  \"neg\" ) )  TRUE else  FALSE   cpp.res -   multilevelImpl (  multilevelPathwaysList ,  stats ,  sampleSize ,  seed ,  eps , sign =  sign , BPPARAM =  BPPARAM )   cpp.res -   rbindlist (  cpp.res )   result -   rbindlist (  multilevelPathwaysList ) # `cppMpval` - P-values that are computed in cpp code # `isCpGeHalf` is a flag that mathces: whether the conditional probability # is greater than or equal to 0.5 (see article for details)   result [ ,   pval :=   pmin (  1 ,    cpp.res $ cppMPval /  denomProb ) ]   result [ ,   isCpGeHalf :=   cpp.res $ cppIsCpGeHalf ]   result [ ,   log2err :=   multilevelError (  pval , sampleSize =  sampleSize ) ]   result [   isCpGeHalf ==  FALSE ,   log2err :=  NA ]  if (  !   all (   result $ isCpGeHalf ) )  {   warning (  \"For some of the pathways the P-values were likely overestimated. \" ,  \"For such pathways log2err is set to NA.\" ) }   result [ ,   isCpGeHalf :=  NULL ]   result [ ,   modeFraction :=  NULL ]   result [ ,   denomProb :=  NULL ]   result -   rbindlist (   list (  result ,  dtSimpleFgsea ,  naSimpleRes ) , use.names =  TRUE )   result [ ,   nMoreExtreme :=  NULL ]   result [   pval undefined  eps ,    c (  \"pval\" ,  \"log2err\" ) :=   list (  eps ,  NA ) ]   result [ ,   padj :=   p.adjust (  pval , method =  \"BH\" ) ]  if (   nrow (   result [    pval ==  eps undefined   is.na (  log2err ) ] ) )  {   warning (  \"For some pathways, in reality P-values are less than \" ,   paste (  eps ) ,  \". You can set the `eps` argument to zero for better estimation.\" ) }   setcolorder (  result ,   c (  \"pathway\" ,  \"pval\" ,  \"padj\" ,  \"log2err\" ,  \"ES\" ,  \"NES\" ,  \"size\" ,  \"leadingEdge\" ) )   setorder (  result ,  pathway )   result -   result [ ]  result } ",
    "filename": "fgseaMultilevel.txt"
  }
}


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_12 fgsea_release_3_13

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_12 fgsea_release_3_13",
    "desc_release_old": "1.16.0",
    "desc_release_new": "1.18.0",
    "old_release_number": 7,
    "new_release_number": 8,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_13 fgsea_release_3_14

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_13 fgsea_release_3_14",
    "desc_release_old": "1.18.0",
    "desc_release_new": "1.20.0",
    "old_release_number": 8,
    "new_release_number": 9,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########


###############################
###############################
###############################
###############################
Checking Versions:  fgsea_release_3_14 fgsea_master

{
    "package": "fgsea",
    "release_versions": "fgsea_release_3_14 fgsea_master",
    "desc_release_old": "1.20.0",
    "desc_release_new": "1.21.2",
    "old_release_number": 9,
    "new_release_number": 10,
    "function_removals": 0,
    "function_additions": 0,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 0,
    "total_count": 0
}

##########
Functions Removed
##########



##########
Functions Added
##########



##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

