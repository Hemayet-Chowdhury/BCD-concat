
###############################
###############################
###############################
###############################
Checking Versions:  scater_release_3_5 scater_release_3_6

{
    "package": "single_test_new",
    "release_versions": "scater_release_3_5 scater_release_3_6",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 79,
    "function_additions": 14,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 0,
    "parameter_default_changes": 0,
    "parameter_overall_changes": 3,
    "total_count": 82
}

##########
Functions Removed
##########

cellDist<-
cellNames<-
cellPairwiseDistances<-
cpm<-
featDist<-
featureControlInfo<-
featurePairwiseDistances<-
is_exprs<-
norm_counts<-
norm_cpm<-
norm_fpkm<-
norm_tpm<-
redDim<-
reducedDimension<-
setSpike<-
set_exprs<-
tpm<-
arrange.SCESet
bootstraps.SCESet
cellDist
cellDistSCESet
cellNames
cellPairwiseDistances
cellPairwiseDistances.SCESet
counts.SCESet
cpm
cpmSCESet
featDist
featDistSCESet
featureControlInfo
featureControlInfo.SCESet
featurePairwiseDistances
featurePairwiseDistancesSCESet
filter.SCESet
fpkm.SCESet
get_exprs
get_exprs.SCESet
isSpike
is_exprs
is_exprs.SCESet
mergeSCESet
mutate.SCESet
norm_counts
norm_counts.SCESet
norm_cpm
norm_cpm.SCESet
norm_exprs.SCESet
norm_fpkm
norm_fpkm.SCESet
norm_tpm
norm_tpm.SCESet
normalize.SCESet
plotDiffusionMapSCESet
plotExpressionSCESet
plotMDSSCESet
plotPCASCESet
plotReducedDim.SCESet
plotReducedDim.default
plotSCESet
redDim
redDim.SCESet
reducedDimension
reducedDimension.SCESet
rename.SCESet
sizeFactors.SCESet
spikes
stand_exprs.SCESet
tpm
tpm.SCESet
whichSpike
writeSCESet
[
counts<-
fData<-
pData<-
sizeFactors<-
counts
plot
sizeFactors


##########
Functions Added
##########

downsampleCounts
exprs
normalizeSCE
plotCellData
plotColData
plotPCASCE
plotReducedDimDefault
plotRowData
plotScater
read10xResults
runDiffusionMap
runPCA
runTSNE
toSingleCellExperiment


##########
Removed Non Default Parameters
##########



##########
Added Non Default Parameters
##########



##########
All Parameter Breaking Changes
##########

0.
{
  "old_function": {
    "name": "scater_gui",
    "representation": "scater_gui",
    "parameters": "function ( sce_set )",
    "body": "{   pd -   names (   pData (  sce_set ) )   pd.plot -   pd [   !   grepl (  \"filter_\" ,  pd ) undefined  !   grepl (  \"is_\" ,  pd ) ]   featurenames -   featureNames (  sce_set )   exprs_values -   names (   Biobase :: assayData (  sce_set ) )   exprs_values -   exprs_values [  !   grepl (  \"is_exprs\" ,  exprs_values ) ]   shinyApp (   ui -   dashboardPage (   dashboardHeader ( title =  \"scater\" ) ,   dashboardSidebar (   sidebarMenu (   menuItem (  \"plot\" , tabName =  \"plot\" ) ,   menuItem (  \"plotQC\" , tabName =  \"plotQC\" ) ,   menuItem (  \"plotPCA - QC metrics\" , tabName =  \"plotPCA_QC\" ) ,   menuItem (  \"plotPCA - expression\" , tabName =  \"plotPCA\" ) ,   menuItem (  \"plotTSNE\" , tabName =  \"plotTSNE\" ) ,   menuItem (  \"plotDiffusionMap\" , tabName =  \"plotDiffusionMap\" ) ,   menuItem (  \"plotExpression\" , tabName =  \"plotExpression\" ) ) ) ,   dashboardBody (   tabItems (   tabItem ( tabName =  \"plot\" ,   fluidRow (   box (   HTML (  [1311 chars quoted with '\"'] ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plot\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"block1\" ,  \"block1:\" ,  pd.plot , selected =   pd.plot [  2 ] ) ,   selectInput (  \"block2\" ,  \"block2:\" ,  pd.plot , selected =   pd.plot [  3 ] ) ,   selectInput (  \"colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ) ) ) ,   tabItem ( tabName =  \"plotQC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   box (   plotOutput (  \"plotQC\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCtype\" , label =  \"Choose a type of QC plot\" , choices =   c (  \"highest-expression\" ,  \"explanatory-variables\" ,  \"exprs-freq-vs-mean\" ) , selected =  \"highest-expression\" ) , width =  4 ) ) ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ,   box (   plotOutput (  \"plotQCfindpc\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCvar\" , label =  \"Choose a variable of interest\" , choices =  pd.plot , selected =  \"total_features\" ) , width =  4 ) ) ) ,   tabItem ( tabName =  \"plotPCA_QC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA_QC\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   checkboxInput (  \"pcaqc_detect_outliers\" ,  \"detect outliers?\" , value =  TRUE ) ,   selectInput (  \"pcaqc_selected_vars\" ,  \"variables to use for PCA:\" ,  pd.plot , selected =   c (  \"pct_counts_top_100_features\" ,  \"total_features\" ,  \"pct_counts_feature_controls\" ,  \"n_detected_feature_controls\" ,  \"log10_counts_endogenous_features\" ,  \"log10_counts_feature_controls\" ) , multiple =  TRUE ) ,   textInput (  \"pcaqc_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pcaqc_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pcaqc_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   numericInput (  \"pcaqc_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pcaqc_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotPCA\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 , # selectInput(\"pca_colour_by\", \"colour_by (either cell metadata or feature expression):\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"pca_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pca_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pca_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"pca_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"pca_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"pca_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pca_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotTSNE\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotTSNE\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"tsne_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"tsne_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"tsne_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"tsne_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"tsne_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"tsne_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"tsne_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"tsne_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ) ) ) ,   tabItem ( tabName =  \"plotDiffusionMap\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotDiffusionMap\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"diffmap_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"diffmap_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"diffmap_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"diffmap_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"diffmap_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"diffmap_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"diffmap_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"diffmap_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ,   radioButtons (  \"diffmap_distance\" , label =  \"Choose a distance metric\" , choices =   c (  \"euclidean\" ,  \"cosine\" ,  \"rankcor\" ) , selected =  \"euclidean\" ) ) ) ) ,   tabItem ( tabName =  \"plotExpression\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotExpression\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"exprs_features\" ,  \"features:\" ,  featurenames , selected =   featurenames [   1 :  6 ] , multiple =  TRUE ) , # selectInput(\"exprs_x\", \"x-axis variable:\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"exprs_x\" ,  \"x-axis variable (either cell metadata variable or feature name):\" ,   pd.plot [  4 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"exprs_colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"exprs_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"exprs_ncols\" ,  \"number of columns:\" ,  2 , min =  1 , max =  8 ) ,   checkboxInput (  \"exprs_show_median\" ,  \"show median?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_show_violin\" ,  \"show violin?\" , value =  TRUE ) ,   checkboxInput (  \"exprs_show_smooth\" ,  \"show smoothed fit?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_log2\" ,  \"transform expression values to log2 scale?\" , value =  FALSE ) ) ) ) ) ) ) ,   server -  function ( input , output , session )  {    output $ plot -   renderPlot (  {   plot (  sce_set , exprs_values =   input $ exprs_values , block1 =   input $ block1 , block2 =   input $ block2 , colour_by =   input $ colour_by ) } )    output $ plotQC -   renderPlot (  {   plotQC (  sce_set , type =   input $ QCtype ) } )    output $ plotQCfindpc -   renderPlot (  {   plotQC (  sce_set , type =  \"find-pcs\" , variable =   input $ QCvar ) } )    output $ plotPCA_QC -   renderPlot (  {    plotPCA (  sce_set , ncomponents =   input $ pcaqc_ncomponents , pca_data_input =  \"pdata\" , selected_variables =   input $ pcaqc_selected_vars , detect_outliers =   input $ pcaqc_detect_outliers , colour_by =   input $ pcaqc_colour_by , size_by =   input $ pcaqc_size_by , shape_by =   input $ pcaqc_shape_by , scale_features =   input $ pcaqc_scale_features , legend =  \"all\" ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotPCA -   renderPlot (  {    plotPCA (  sce_set , ntop =   input $ pca_ntop , ncomponents =   input $ pca_ncomponents , exprs_values =   input $ pca_exprs_values , colour_by =   input $ pca_colour_by , size_by =   input $ pca_size_by , shape_by =   input $ pca_shape_by , scale_features =   input $ pca_scale_features ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotTSNE -   renderPlot (  {    plotTSNE (  sce_set , ntop =   input $ tsne_ntop , ncomponents =   input $ tsne_ncomponents , exprs_values =   input $ tsne_exprs_values , colour_by =   input $ tsne_colour_by , size_by =   input $ tsne_size_by , shape_by =   input $ tsne_shape_by , scale_features =   input $ tsne_scale_features , rand_seed =   input $ tsne_rand_seed ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotDiffusionMap -   renderPlot (  {    plotDiffusionMap (  sce_set , ntop =   input $ diffmap_ntop , ncomponents =   input $ diffmap_ncomponents , exprs_values =   input $ diffmap_exprs_values , colour_by =   input $ diffmap_colour_by , size_by =   input $ diffmap_size_by , shape_by =   input $ diffmap_shape_by , scale_features =   input $ diffmap_scale_features , rand_seed =   input $ diffmap_rand_seed , distance =   input $ diffmap_distance ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotExpression -   renderPlot (  {    plotExpression (  sce_set , features =   input $ exprs_features , x =   input $ exprs_x , exprs_values =   input $ exprs_exprs_values , colour_by =   input $ exprs_colour_by , size_by =   input $ exprs_size_by , shape_by =   input $ exprs_shape_by , ncol =   input $ exprs_ncols , show_median =   input $ exprs_show_median , show_violin =   input $ exprs_show_violin , show_smooth =   input $ exprs_show_smooth , log2_values =   input $ exprs_log2 ) +   theme ( legend.position =  \"bottom\" ) } )    session $ onSessionEnded (  function ( )  {   stopApp ( ) } ) } , options =   list ( launch.browser =  TRUE ) ) } ",
    "filename": "gui.txt"
  },
  "new_function": {
    "name": "scater_gui",
    "representation": "scater_gui",
    "parameters": "function ( object )",
    "body": "{   pd -   colnames (   colData (  object ) )   pd.plot -   pd [   !   grepl (  \"filter_\" ,  pd ) undefined  !   grepl (  \"is_\" ,  pd ) ]   featurenames -   rownames (  object )   exprs_values -   assayNames (  object )   exprs_values -   exprs_values [  !   grepl (  \"is_exprs\" ,  exprs_values ) ]   shinyApp (   ui -   dashboardPage (   dashboardHeader ( title =  \"scater\" ) ,   dashboardSidebar (   sidebarMenu (   menuItem (  \"plot\" , tabName =  \"plot\" ) ,   menuItem (  \"plotQC\" , tabName =  \"plotQC\" ) ,   menuItem (  \"plotPCA - QC metrics\" , tabName =  \"plotPCA_QC\" ) ,   menuItem (  \"plotPCA - expression\" , tabName =  \"plotPCA\" ) ,   menuItem (  \"plotTSNE\" , tabName =  \"plotTSNE\" ) ,   menuItem (  \"plotDiffusionMap\" , tabName =  \"plotDiffusionMap\" ) ,   menuItem (  \"plotExpression\" , tabName =  \"plotExpression\" ) ) ) ,   dashboardBody (   tabItems (   tabItem ( tabName =  \"plot\" ,   fluidRow (   box (   HTML (  [1311 chars quoted with '\"'] ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plot\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"block1\" ,  \"block1:\" ,  pd.plot , selected =   pd.plot [  2 ] ) ,   selectInput (  \"block2\" ,  \"block2:\" ,  pd.plot , selected =   pd.plot [  3 ] ) ,   selectInput (  \"colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ) ) ) ,   tabItem ( tabName =  \"plotQC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   box (   plotOutput (  \"plotQC\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCtype\" , label =  \"Choose a type of QC plot\" , choices =   c (  \"highest-expression\" ,  \"explanatory-variables\" ,  \"exprs-freq-vs-mean\" ) , selected =  \"highest-expression\" ) , width =  4 ) ) ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ,   box (   plotOutput (  \"plotQCfindpc\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCvar\" , label =  \"Choose a variable of interest\" , choices =  pd.plot , selected =  \"total_features\" ) , width =  4 ) ) ) ,   tabItem ( tabName =  \"plotPCA_QC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA_QC\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   checkboxInput (  \"pcaqc_detect_outliers\" ,  \"detect outliers?\" , value =  TRUE ) ,   selectInput (  \"pcaqc_selected_vars\" ,  \"variables to use for PCA:\" ,  pd.plot , selected =   c (  \"pct_counts_top_100_features\" ,  \"total_features\" ,  \"pct_counts_feature_controls\" ,  \"n_detected_feature_controls\" ,  \"log10_counts_endogenous_features\" ,  \"log10_counts_feature_controls\" ) , multiple =  TRUE ) ,   textInput (  \"pcaqc_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pcaqc_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pcaqc_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   numericInput (  \"pcaqc_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pcaqc_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotPCA\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 , # selectInput(\"pca_colour_by\", \"colour_by (either cell metadata or feature expression):\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"pca_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pca_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pca_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"pca_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"pca_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"pca_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pca_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotTSNE\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotTSNE\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"tsne_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"tsne_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"tsne_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"tsne_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"tsne_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"tsne_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"tsne_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"tsne_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ) ) ) ,   tabItem ( tabName =  \"plotDiffusionMap\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotDiffusionMap\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"diffmap_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"diffmap_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"diffmap_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"diffmap_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"diffmap_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"diffmap_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"diffmap_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"diffmap_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ,   radioButtons (  \"diffmap_distance\" , label =  \"Choose a distance metric\" , choices =   c (  \"euclidean\" ,  \"cosine\" ,  \"rankcor\" ) , selected =  \"euclidean\" ) ) ) ) ,   tabItem ( tabName =  \"plotExpression\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotExpression\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"exprs_features\" ,  \"features:\" ,  featurenames , selected =   featurenames [   1 :  6 ] , multiple =  TRUE ) , # selectInput(\"exprs_x\", \"x-axis variable:\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"exprs_x\" ,  \"x-axis variable (either cell metadata variable or feature name):\" ,   pd.plot [  4 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"exprs_colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"exprs_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"exprs_ncols\" ,  \"number of columns:\" ,  2 , min =  1 , max =  8 ) ,   checkboxInput (  \"exprs_show_median\" ,  \"show median?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_show_violin\" ,  \"show violin?\" , value =  TRUE ) ,   checkboxInput (  \"exprs_show_smooth\" ,  \"show smoothed fit?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_log2\" ,  \"transform expression values to log2 scale?\" , value =  FALSE ) ) ) ) ) ) ) ,   server -  function ( input , output , session )  {    output $ plot -   renderPlot (  {   plotScater (  object , exprs_values =   input $ exprs_values , block1 =   input $ block1 , block2 =   input $ block2 , colour_by =   input $ colour_by ) } )    output $ plotQC -   renderPlot (  {   plotQC (  object , type =   input $ QCtype ) } )    output $ plotQCfindpc -   renderPlot (  {   plotQC (  object , type =  \"find-pcs\" , variable =   input $ QCvar ) } )    output $ plotPCA_QC -   renderPlot (  {    plotPCA (  object , ncomponents =   input $ pcaqc_ncomponents , pca_data_input =  \"pdata\" , selected_variables =   input $ pcaqc_selected_vars , detect_outliers =   input $ pcaqc_detect_outliers , colour_by =   input $ pcaqc_colour_by , size_by =   input $ pcaqc_size_by , shape_by =   input $ pcaqc_shape_by , scale_features =   input $ pcaqc_scale_features , legend =  \"all\" ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotPCA -   renderPlot (  {    plotPCA (  object , ntop =   input $ pca_ntop , ncomponents =   input $ pca_ncomponents , exprs_values =   input $ pca_exprs_values , colour_by =   input $ pca_colour_by , size_by =   input $ pca_size_by , shape_by =   input $ pca_shape_by , scale_features =   input $ pca_scale_features ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotTSNE -   renderPlot (  {    plotTSNE (  object , ntop =   input $ tsne_ntop , ncomponents =   input $ tsne_ncomponents , exprs_values =   input $ tsne_exprs_values , colour_by =   input $ tsne_colour_by , size_by =   input $ tsne_size_by , shape_by =   input $ tsne_shape_by , scale_features =   input $ tsne_scale_features , rand_seed =   input $ tsne_rand_seed ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotDiffusionMap -   renderPlot (  {    plotDiffusionMap (  object , ntop =   input $ diffmap_ntop , ncomponents =   input $ diffmap_ncomponents , exprs_values =   input $ diffmap_exprs_values , colour_by =   input $ diffmap_colour_by , size_by =   input $ diffmap_size_by , shape_by =   input $ diffmap_shape_by , scale_features =   input $ diffmap_scale_features , rand_seed =   input $ diffmap_rand_seed , distance =   input $ diffmap_distance ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotExpression -   renderPlot (  {    plotExpression (  object , features =   input $ exprs_features , x =   input $ exprs_x , exprs_values =   input $ exprs_exprs_values , colour_by =   input $ exprs_colour_by , size_by =   input $ exprs_size_by , shape_by =   input $ exprs_shape_by , ncol =   input $ exprs_ncols , show_median =   input $ exprs_show_median , show_violin =   input $ exprs_show_violin , show_smooth =   input $ exprs_show_smooth , log2_values =   input $ exprs_log2 ) +   theme ( legend.position =  \"bottom\" ) } )    session $ onSessionEnded (  function ( )  {   stopApp ( ) } ) } , options =   list ( launch.browser =  TRUE ) ) } ",
    "filename": "gui.txt"
  }
}

1.
{
  "old_function": {
    "name": "plotExpressionDefault",
    "representation": "plotExpressionDefault",
    "parameters": "function ( object , aesth , ncol = 2 , xlab = NULL , ylab = NULL , show_median = FALSE , show_violin = TRUE , show_smooth = FALSE , alpha = 0.6 , size = NULL , scales = \"fixed\" , one_facet = FALSE , se = TRUE , jitter = \"swarm\" )",
    "body": "{  if (  !  (   \"Feature\" %in%   names (  object ) ) )   stop (  \"object needs a column named 'Feature' to define the feature(s) by which to plot expression.\" ) ## use x as group for violin plot if discrete   group_by_x -  (   show_violin undefined  (   !   is.numeric (   object [[   as.character (   aesth $ x ) ] ] ) ||    nlevels (   as.factor (   object [[   as.character (   aesth $ x ) ] ] ) ) =  5 ) )  if (  group_by_x )    aesth $ group -   aesth $ x else    aesth $ group -  1 ## Define the plot  if (  one_facet )  {  if (   is.null (   aesth $ colour ) )    aesth $ colour -   as.symbol (  \"Feature\" )   plot_out -     ggplot (  object ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) } else  {   plot_out -      ggplot (  object ,  aesth ) +   facet_wrap (  ~  Feature , ncol =  ncol , scales =  scales ) +   xlab (  xlab ) +   ylab (  ylab ) } ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) ) ## if x axis variable is not numeric, then jitter points horizontally  if (   is.numeric (   aesth $ x ) )  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) else   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } else  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , size =  size ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , size =  size , position =   position_jitter ( height =  0 ) ) } else  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , position =   position_jitter ( height =  0 ) ) } } ## show optional decorations on plot if desired  if (  show_violin )  {  if (   one_facet undefined  (    aesth $ colour ==   as.symbol (  \"Feature\" ) ) )  {   plot_out -   plot_out +   geom_violin (   aes_string ( fill =  \"Feature\" ) , colour =  \"gray60\" , alpha =  0.2 , scale =  \"width\" )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) , fill =  TRUE ) } else   plot_out -   plot_out +   geom_violin ( colour =  \"gray60\" , alpha =  0.3 , fill =  \"gray80\" , scale =  \"width\" ) }  if (  show_median )  {   plot_out -   plot_out +   stat_summary ( fun.y =  median , fun.ymin =  median , fun.ymax =  median , geom =  \"crossbar\" , width =  0.3 , alpha =  0.8 ) }  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) }  plot_out } ",
    "filename": "plotting.txt"
  },
  "new_function": {
    "name": "plotExpressionDefault",
    "representation": "plotExpressionDefault",
    "parameters": "function ( object , aesth , ncol = 2 , xlab = NULL , ylab = NULL , show_median = FALSE , show_violin = TRUE , show_smooth = FALSE , theme_size = 10 , alpha = 0.6 , size = NULL , scales = \"fixed\" , one_facet = FALSE , se = TRUE , jitter = \"swarm\" )",
    "body": "{  if (  !  (   \"Feature\" %in%   names (  object ) ) )   stop (  \"object needs a column named 'Feature' to define the feature(s) by which to plot expression.\" ) ## use x as group for violin plot if discrete   group_by_x -  (   show_violin undefined  (   !   is.numeric (   object [[   as.character (   aesth $ x ) ] ] ) ||    nlevels (   as.factor (   object [[   as.character (   aesth $ x ) ] ] ) ) =  5 ) )  if (  group_by_x )    aesth $ group -   aesth $ x else    aesth $ group -  1 ## Define the plot  if (  one_facet )  {  if (   is.null (   aesth $ colour ) )    aesth $ colour -   as.symbol (  \"Feature\" )   plot_out -     ggplot (  object ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) } else  {   plot_out -      ggplot (  object ,  aesth ) +   facet_wrap (  ~  Feature , ncol =  ncol , scales =  scales ) +   xlab (  xlab ) +   ylab (  ylab ) } ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) ) ## if x axis variable is not numeric, then jitter points horizontally  if (   is.numeric (   aesth $ x ) )  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) else   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } else  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , size =  size , groupOnX =  TRUE ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , size =  size , position =   position_jitter ( height =  0 ) ) } else  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , groupOnX =  TRUE ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , position =   position_jitter ( height =  0 ) ) } } ## show optional decorations on plot if desired  if (  show_violin )  {  if (   one_facet undefined  (    aesth $ colour ==   as.symbol (  \"Feature\" ) ) )  {   plot_out -   plot_out +   geom_violin (   aes_string ( fill =  \"Feature\" ) , colour =  \"gray60\" , alpha =  0.2 , scale =  \"width\" )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) , fill =  TRUE ) } else   plot_out -   plot_out +   geom_violin ( colour =  \"gray60\" , alpha =  0.3 , fill =  \"gray80\" , scale =  \"width\" ) }  if (  show_median )  {   plot_out -   plot_out +   stat_summary ( fun.y =  median , fun.ymin =  median , fun.ymax =  median , geom =  \"crossbar\" , width =  0.3 , alpha =  0.8 ) }  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) } ## Define plotting theme  if (   requireNamespace (  \"cowplot\" , quietly =  TRUE ) )   plot_out -   plot_out +   cowplot :: theme_cowplot (  theme_size ) else   plot_out -   plot_out +   theme_bw (  theme_size )  plot_out } ",
    "filename": "plotting.txt"
  }
}

2.
{
  "old_function": {
    "name": "calculateQCMetrics",
    "representation": "calculateQCMetrics",
    "parameters": "function ( object , feature_controls = NULL , cell_controls = NULL , nmads = 5 , pct_feature_controls_threshold = 80 )",
    "body": "{ ## We must have an SCESet object  if (  !   is (  object ,  \"SCESet\" ) )   stop (  \"object must be an SCESet object.\" ) ## the object must have some samples  if (    ncol (  object ) undefined  1 )   stop (  \"object must have at least one sample (column)\" )  if (    nrow (  object ) undefined  1 )   stop (  \"object must have at least one feature (row)\" ) ## See what versions of the expression data are available in the object   exprs_mat -   exprs (  object )   counts_mat -   counts (  object )   tpm_mat -   tpm (  object )   fpkm_mat -   fpkm (  object ) ## get number of sets of feature controls, and name them  if (   is.null (  feature_controls ) )  {   feature_controls -   list ( ) } else  if (  !   is.list (  feature_controls ) )  {   feature_controls -   list (  feature_controls ) }   n_sets_feature_controls -   length (  feature_controls )   counter -  1L  for  ( i in   seq_len (  n_sets_feature_controls ) )  {   curname -    names (  feature_controls ) [  i ]  if (    is.null (  curname ) ||   curname ==  \"\" )  {     names (  feature_controls ) [  i ] -   paste0 (  \"unnamed\" ,  counter )   counter -   counter +  1L } }    object @ featureControlInfo -   AnnotatedDataFrame (   data.frame ( name =   names (  feature_controls ) , stringsAsFactors =  FALSE ) )  if (  n_sets_feature_controls )  { ## Contributions from technical control features   tech_features -   .process_feature_controls (  object ,  feature_controls ,  pct_feature_controls_threshold ,  exprs_mat ,  counts_mat ,  tpm_mat ,  fpkm_mat )   feature_controls_pdata -   tech_features $ pData   feature_controls_fdata -   tech_features $ fData ## Combine all feature controls   is_feature_control -   apply (  feature_controls_fdata ,  1 ,  any )   feature_controls_fdata -   cbind (  feature_controls_fdata ,  is_feature_control ) } else  {   is_feature_control -   logical (   nrow (  object ) )   feature_controls_fdata -   data.frame (  is_feature_control )   feature_controls_pdata -   data.frame (   matrix (  0 , nrow =   ncol (  object ) , ncol =  0 ) ) }   n_detected_feature_controls -   nexprs (  object , subset_row =  is_feature_control )   df_pdata_this -   data.frame (  n_detected_feature_controls ) ## Compute metrics using all feature controls   okay.expr.vals -   c (  \"counts\" ,  \"cpm\" ,  \"tpm\" ,  \"fpkm\" )  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   df_pdata_current -   .get_qc_metrics_exprs_mat (  cur_mat ,  is_feature_control ,  pct_feature_controls_threshold , calc_top_features =  TRUE , exprs_type =  ex , compute_endog =  TRUE )   df_pdata_this -   cbind (  df_pdata_this ,  df_pdata_current ) }   feature_controls_pdata -   cbind (  feature_controls_pdata ,  df_pdata_this ) ## Compute total_features and find outliers   total_features -   nexprs (  object , subset_row =  !  is_feature_control )   filter_on_total_features -   isOutlier (  total_features ,  nmads , type =  \"lower\" ) ## Compute total_counts if counts are present  if (  !   is.null (  counts_mat ) )  {   total_counts -   colSums (  counts_mat )   filter_on_total_counts -   isOutlier (  total_counts ,  nmads , log =  TRUE ) } else  {   total_counts -   colSums (  exprs_mat )   filter_on_total_counts -   isOutlier (  total_counts ,  nmads , log =  FALSE ) } ## Define counts from endogenous features   qc_pdata -  feature_controls_pdata  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   cur_totals -   switch (  ex , counts =  total_counts ,   colSums (  cur_mat ) )    qc_pdata [[   paste0 (  ex ,  \"_endogenous_features\" ) ] ] -   cur_totals -   feature_controls_pdata [[   paste0 (  ex ,  \"_feature_controls\" ) ] ] } ## Define log10 read counts from feature controls   stat.cols -   sub (  \"_.*\" ,  \"\" ,   colnames (  qc_pdata ) )   cols_to_log -   which (   stat.cols %in%  okay.expr.vals )  if (   length (  cols_to_log ) )  {   log10_cols -   log10 (    qc_pdata [ ,  cols_to_log , drop =  FALSE ] +  1 )    colnames (  log10_cols ) -   paste0 (  \"log10_\" ,    colnames (  qc_pdata ) [  cols_to_log ] ) ## Combine into a big pdata object   qc_pdata -   cbind (  qc_pdata ,  log10_cols ) } ## Define cell controls ### Determine if vector or list  if (    is.null (  cell_controls ) |    length (  cell_controls ) ==  0 )  {   is_cell_control -   rep (  FALSE ,   ncol (  object ) )   cell_controls_pdata -   data.frame (  is_cell_control )   n_sets_cell_controls -  1 } else  {  if (   is.list (  cell_controls ) )  {   cell_controls_list -  cell_controls   n_sets_cell_controls -   length (  cell_controls ) } else  {   cell_controls_list -   list (  cell_controls )   n_sets_cell_controls -  1 }  for  ( i in   seq_len (  n_sets_cell_controls ) )  {   cc_set -   cell_controls_list [[  i ] ]   set_name -    names (  cell_controls_list ) [  i ]  if (   is.logical (  cc_set ) )  {   is_cell_control -  cc_set   cc_set -   which (  cc_set ) } else  {   is_cell_control -   rep (  FALSE ,   ncol (  object ) ) }  if (   is.character (  cc_set ) )   cc_set -   which (    cellNames (  object ) %in%  cc_set )    is_cell_control [  cc_set ] -  TRUE ## Construct data.frame for pData from this feature control set   is_cell_control -   as.data.frame (  is_cell_control )    colnames (  is_cell_control ) -   paste0 (  \"is_cell_control_\" ,  set_name )  if (   i undefined  1L )  {   cell_controls_pdata -   data.frame (  cell_controls_pdata ,  is_cell_control ) } else   cell_controls_pdata -  is_cell_control } } ## Check column names and get cell controls across all sets  if (   n_sets_cell_controls ==  1 )  {    colnames (  cell_controls_pdata ) -  \"is_cell_control\" } else  { ## Combine all cell controls   is_cell_control -   apply (  cell_controls_pdata ,  1 ,  any )   cell_controls_pdata -   cbind (  cell_controls_pdata ,  is_cell_control ) } ## Add cell-level QC metrics to pData   new_pdata -   as.data.frame (   pData (  object ) ) ### Remove columns to be replaced   to_replace -    colnames (  new_pdata ) %in%   c (   colnames (  qc_pdata ) ,   colnames (  cell_controls_pdata ) )   new_pdata -   new_pdata [ ,  !  to_replace , drop =  FALSE ] ### Add new QC metrics  if (  !   is.null (  counts_mat ) )  {    new_pdata $ total_counts -  total_counts    new_pdata $ log10_total_counts -   log10 (  total_counts )    new_pdata $ filter_on_total_counts -  filter_on_total_counts }    new_pdata $ total_features -  total_features    new_pdata $ log10_total_features -   log10 (  total_features )    new_pdata $ filter_on_total_features -  filter_on_total_features    new_pdata $ pct_dropout -   100 *  (   1 -    nexprs (  object , subset_row =  NULL ) /   nrow (  object ) )   new_pdata -   cbind (  new_pdata ,  qc_pdata ,  cell_controls_pdata )    pData (  object ) -   new (  \"AnnotatedDataFrame\" ,  new_pdata ) ## Add feature-level QC metrics to fData   new_fdata -   as.data.frame (   fData (  object ) ) ### Remove columns that are to be replaced   to_replace -    colnames (  new_fdata ) %in%   colnames (  feature_controls_fdata )   new_fdata -   new_fdata [ ,  !  to_replace , drop =  FALSE ] ### Add new QC information    new_fdata $ mean_exprs -   rowMeans (   exprs (  object ) )    new_fdata $ exprs_rank -   rank (   rowMeans (   exprs (  object ) ) )    new_fdata $ n_cells_exprs -   nexprs (  object , byrow =  TRUE )   total_exprs -   sum (  exprs_mat )    new_fdata $ total_feature_exprs -   rowSums (  exprs_mat )    new_fdata $ pct_total_exprs -    100 *   rowSums (  exprs_mat ) /  total_exprs    new_fdata $ pct_dropout -   100 *  (   1 -    new_fdata $ n_cells_exprs /   ncol (  object ) )  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   cur_totals -   sum (   as.double (   colSums (  cur_mat ) ) ) # avoid integer overflow   cur_feature_totals -   rowSums (  cur_mat )    new_fdata [[   paste0 (  \"total_feature_\" ,  ex ) ] ] -  cur_feature_totals    new_fdata [[   paste0 (  \"log10_total_feature_\" ,  ex ) ] ] -   log10 (   cur_feature_totals +  1 )    new_fdata [[   paste0 (  \"pct_total_\" ,  ex ) ] ] -    100 *  cur_feature_totals /  cur_totals } ## Add new fdata to object   new_fdata -   cbind (  new_fdata ,  feature_controls_fdata )    fData (  object ) -   new (  \"AnnotatedDataFrame\" ,  new_fdata ) ## Ensure sample names are correct and return object    sampleNames (  object ) -   colnames (   exprs (  object ) )  object } ",
    "filename": "qc.txt"
  },
  "new_function": {
    "name": "calculateQCMetrics",
    "representation": "calculateQCMetrics",
    "parameters": "function ( object , exprs_values = \"counts\" , feature_controls = NULL , cell_controls = NULL , nmads = 5 , pct_feature_controls_threshold = 80 )",
    "body": "{  if (  !   methods :: is (  object ,  \"SingleCellExperiment\" ) )   stop (  \"object must be a SingleCellExperiment\" )   exprs_mat -   assay (  object , i =  exprs_values )  if (    exprs_values ==  \"counts\" ||   exprs_values ==  \"cpm\" )  {   linear -  TRUE } else  {   linear -  FALSE } ## Adding general metrics for each cell.   cd -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  NULL , subset_type =  NULL , linear =  TRUE )   rd -   DataFrame ( is_feature_control =   logical (   nrow (  exprs_mat ) ) , row.names =   rownames (  exprs_mat ) ) ## Adding metrics for the technical controls.   n_feature_sets -   length (  feature_controls )  if (  n_feature_sets )  {  if (   is.null (   names (  feature_controls ) ) )  {   stop (  \"feature_controls should be named\" ) } # Converting to integer indices for all applications.   reindexed -   lapply (  feature_controls , FUN =  .subset2index , target =  exprs_mat )   is_fcon -   Reduce (  union ,  reindexed )     rd $ is_feature_control [  is_fcon ] -  TRUE # Adding feature controls.  for  ( f in   seq_len (  n_feature_sets ) )  {   cur.index -   logical (   nrow (  exprs_mat ) )    cur.index [   reindexed [[  f ] ] ] -  TRUE    rd [[   paste0 (  \"is_feature_control_\" ,    names (  reindexed ) [  f ] ) ] ] -  cur.index } # Running through all endogenous genes.   is_endog -   which (  !   rd $ is_feature_control )   cd_endog -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  is_endog , subset_type =  \"endogenous\" , linear =  linear ) # Running through all feature controls.   cd_fcon -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  is_fcon , subset_type =  \"feature_control\" , linear =  linear ) # Running through each of the feature controls.   cd_per_fcon -   vector (  \"list\" ,  n_feature_sets )  for  ( f in   seq_len (  n_feature_sets ) )  {    cd_per_fcon [[  f ] ] -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =   reindexed [[  f ] ] , subset_type =    names (  reindexed ) [  f ] , linear =  linear ) }   cd -   do.call (  cbind ,   c (   list (  cd ,  cd_endog ,  cd_fcon ) ,  cd_per_fcon ) ) } ## Define cell controls ### Determine if vector or list   rd_all -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  NULL , subset_type =  NULL , linear =  linear )   rd -   cbind (  rd ,  rd_all )    cd $ is_cell_control -   logical (   ncol (  exprs_mat ) )   n_cell_sets -   length (  cell_controls )  if (  n_cell_sets )  { # Converting indices to integer.   reindexed -   lapply (  cell_controls , FUN =  .subset2index , target =  exprs_mat , byrow =  FALSE )   is_ccon -   Reduce (  union ,  reindexed )     cd $ is_cell_control [  is_ccon ] -  TRUE # Adding sets to the colData.  for  ( cx in   seq_len (  n_cell_sets ) )  {   current_control -   logical (   ncol (  exprs_mat ) )    current_control [   reindexed [[  cx ] ] ] -  TRUE    cd [[   paste0 (  \"is_cell_control_\" ,    names (  reindexed ) [  cx ] ) ] ] -  current_control } # Adding statistics for non-control cells.   is_noncon -   which (  !   cd $ is_cell_control )   rd_noncon -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  is_noncon , subset_type =  \"non_control\" , linear =  linear ) # Adding statistics for all control cells.   rd_con -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  is_ccon , subset_type =  \"cell_control\" , linear =  linear ) # Adding statistics for each set of control cells.   rd_collected -   vector (  \"list\" ,  n_cell_sets )  for  ( cx in   seq_len (  n_cell_sets ) )  {   rd_current -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =   reindexed [[  cx ] ] , subset_type =    names (  reindexed ) [  cx ] , linear =  linear )    rd_collected [[  cx ] ] -  rd_current }   rd -   do.call (  cbind ,   c (   list (  rd ,  rd_con ,  rd_noncon ) ,  rd_collected ) ) } ### Remove columns to be replaced   old_rd -   rowData (  object )   old_rd -   old_rd [ ,  !  (    colnames (  old_rd ) %in%   colnames (  rd ) ) , drop =  FALSE ]   rd -   cbind (  old_rd ,  rd )    rowData (  object ) -  rd   old_cd -   colData (  object )   old_cd -   old_cd [ ,  !  (    colnames (  old_cd ) %in%   colnames (  cd ) ) , drop =  FALSE ]   cd -   cbind (  old_cd ,  cd )    colData (  object ) -  cd   return (  object ) } ",
    "filename": "qc.txt"
  }
}

