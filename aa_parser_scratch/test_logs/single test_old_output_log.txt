
###############################
###############################
###############################
###############################
Checking Versions:  scater_release_3_5 scater_release_3_6

{
    "package": "single_test_new",
    "release_versions": "scater_release_3_5 scater_release_3_6",
    "old_release_number": 1,
    "new_release_number": 2,
    "function_removals": 79,
    "function_additions": 14,
    "parameter_removals": 0,
    "parameter_additions": 0,
    "parameter_renames": 3,
    "parameter_default_changes": 5,
    "parameter_overall_changes": 0
}

##########
Functions Removed
##########

cellDist<-
cellNames<-
cellPairwiseDistances<-
cpm<-
featDist<-
featureControlInfo<-
featurePairwiseDistances<-
is_exprs<-
norm_counts<-
norm_cpm<-
norm_fpkm<-
norm_tpm<-
redDim<-
reducedDimension<-
setSpike<-
set_exprs<-
tpm<-
arrange.SCESet
bootstraps.SCESet
cellDist
cellDistSCESet
cellNames
cellPairwiseDistances
cellPairwiseDistances.SCESet
counts.SCESet
cpm
cpmSCESet
featDist
featDistSCESet
featureControlInfo
featureControlInfo.SCESet
featurePairwiseDistances
featurePairwiseDistancesSCESet
filter.SCESet
fpkm.SCESet
get_exprs
get_exprs.SCESet
isSpike
is_exprs
is_exprs.SCESet
mergeSCESet
mutate.SCESet
norm_counts
norm_counts.SCESet
norm_cpm
norm_cpm.SCESet
norm_exprs.SCESet
norm_fpkm
norm_fpkm.SCESet
norm_tpm
norm_tpm.SCESet
normalize.SCESet
plotDiffusionMapSCESet
plotExpressionSCESet
plotMDSSCESet
plotPCASCESet
plotReducedDim.SCESet
plotReducedDim.default
plotSCESet
redDim
redDim.SCESet
reducedDimension
reducedDimension.SCESet
rename.SCESet
sizeFactors.SCESet
spikes
stand_exprs.SCESet
tpm
tpm.SCESet
whichSpike
writeSCESet
[
counts<-
fData<-
pData<-
sizeFactors<-
counts
plot
sizeFactors


##########
Functions Added
##########

downsampleCounts
exprs
normalizeSCE
plotCellData
plotColData
plotPCASCE
plotReducedDimDefault
plotRowData
plotScater
read10xResults
runDiffusionMap
runPCA
runTSNE
toSingleCellExperiment


##########
Removed Parameters
##########



##########
Added Parameters
##########



##########
Renamed Parameters
##########

0.
{
  "old_function": {
    "name": "scater_gui",
    "representation": "scater_gui",
    "parameters": "function ( sce_set )",
    "body": "{   pd -   names (   pData (  sce_set ) )   pd.plot -   pd [   !   grepl (  \"filter_\" ,  pd ) undefined  !   grepl (  \"is_\" ,  pd ) ]   featurenames -   featureNames (  sce_set )   exprs_values -   names (   Biobase :: assayData (  sce_set ) )   exprs_values -   exprs_values [  !   grepl (  \"is_exprs\" ,  exprs_values ) ]   shinyApp (   ui -   dashboardPage (   dashboardHeader ( title =  \"scater\" ) ,   dashboardSidebar (   sidebarMenu (   menuItem (  \"plot\" , tabName =  \"plot\" ) ,   menuItem (  \"plotQC\" , tabName =  \"plotQC\" ) ,   menuItem (  \"plotPCA - QC metrics\" , tabName =  \"plotPCA_QC\" ) ,   menuItem (  \"plotPCA - expression\" , tabName =  \"plotPCA\" ) ,   menuItem (  \"plotTSNE\" , tabName =  \"plotTSNE\" ) ,   menuItem (  \"plotDiffusionMap\" , tabName =  \"plotDiffusionMap\" ) ,   menuItem (  \"plotExpression\" , tabName =  \"plotExpression\" ) ) ) ,   dashboardBody (   tabItems (   tabItem ( tabName =  \"plot\" ,   fluidRow (   box (   HTML (  [1311 chars quoted with '\"'] ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plot\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"block1\" ,  \"block1:\" ,  pd.plot , selected =   pd.plot [  2 ] ) ,   selectInput (  \"block2\" ,  \"block2:\" ,  pd.plot , selected =   pd.plot [  3 ] ) ,   selectInput (  \"colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ) ) ) ,   tabItem ( tabName =  \"plotQC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   box (   plotOutput (  \"plotQC\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCtype\" , label =  \"Choose a type of QC plot\" , choices =   c (  \"highest-expression\" ,  \"explanatory-variables\" ,  \"exprs-freq-vs-mean\" ) , selected =  \"highest-expression\" ) , width =  4 ) ) ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ,   box (   plotOutput (  \"plotQCfindpc\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCvar\" , label =  \"Choose a variable of interest\" , choices =  pd.plot , selected =  \"total_features\" ) , width =  4 ) ) ) ,   tabItem ( tabName =  \"plotPCA_QC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA_QC\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   checkboxInput (  \"pcaqc_detect_outliers\" ,  \"detect outliers?\" , value =  TRUE ) ,   selectInput (  \"pcaqc_selected_vars\" ,  \"variables to use for PCA:\" ,  pd.plot , selected =   c (  \"pct_counts_top_100_features\" ,  \"total_features\" ,  \"pct_counts_feature_controls\" ,  \"n_detected_feature_controls\" ,  \"log10_counts_endogenous_features\" ,  \"log10_counts_feature_controls\" ) , multiple =  TRUE ) ,   textInput (  \"pcaqc_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pcaqc_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pcaqc_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   numericInput (  \"pcaqc_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pcaqc_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotPCA\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 , # selectInput(\"pca_colour_by\", \"colour_by (either cell metadata or feature expression):\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"pca_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pca_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pca_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"pca_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"pca_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"pca_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pca_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotTSNE\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotTSNE\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"tsne_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"tsne_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"tsne_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"tsne_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"tsne_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"tsne_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"tsne_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"tsne_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ) ) ) ,   tabItem ( tabName =  \"plotDiffusionMap\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotDiffusionMap\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"diffmap_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"diffmap_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"diffmap_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"diffmap_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"diffmap_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"diffmap_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"diffmap_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"diffmap_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ,   radioButtons (  \"diffmap_distance\" , label =  \"Choose a distance metric\" , choices =   c (  \"euclidean\" ,  \"cosine\" ,  \"rankcor\" ) , selected =  \"euclidean\" ) ) ) ) ,   tabItem ( tabName =  \"plotExpression\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotExpression\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"exprs_features\" ,  \"features:\" ,  featurenames , selected =   featurenames [   1 :  6 ] , multiple =  TRUE ) , # selectInput(\"exprs_x\", \"x-axis variable:\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"exprs_x\" ,  \"x-axis variable (either cell metadata variable or feature name):\" ,   pd.plot [  4 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"exprs_colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"exprs_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"exprs\" ) ,   numericInput (  \"exprs_ncols\" ,  \"number of columns:\" ,  2 , min =  1 , max =  8 ) ,   checkboxInput (  \"exprs_show_median\" ,  \"show median?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_show_violin\" ,  \"show violin?\" , value =  TRUE ) ,   checkboxInput (  \"exprs_show_smooth\" ,  \"show smoothed fit?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_log2\" ,  \"transform expression values to log2 scale?\" , value =  FALSE ) ) ) ) ) ) ) ,   server -  function ( input , output , session )  {    output $ plot -   renderPlot (  {   plot (  sce_set , exprs_values =   input $ exprs_values , block1 =   input $ block1 , block2 =   input $ block2 , colour_by =   input $ colour_by ) } )    output $ plotQC -   renderPlot (  {   plotQC (  sce_set , type =   input $ QCtype ) } )    output $ plotQCfindpc -   renderPlot (  {   plotQC (  sce_set , type =  \"find-pcs\" , variable =   input $ QCvar ) } )    output $ plotPCA_QC -   renderPlot (  {    plotPCA (  sce_set , ncomponents =   input $ pcaqc_ncomponents , pca_data_input =  \"pdata\" , selected_variables =   input $ pcaqc_selected_vars , detect_outliers =   input $ pcaqc_detect_outliers , colour_by =   input $ pcaqc_colour_by , size_by =   input $ pcaqc_size_by , shape_by =   input $ pcaqc_shape_by , scale_features =   input $ pcaqc_scale_features , legend =  \"all\" ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotPCA -   renderPlot (  {    plotPCA (  sce_set , ntop =   input $ pca_ntop , ncomponents =   input $ pca_ncomponents , exprs_values =   input $ pca_exprs_values , colour_by =   input $ pca_colour_by , size_by =   input $ pca_size_by , shape_by =   input $ pca_shape_by , scale_features =   input $ pca_scale_features ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotTSNE -   renderPlot (  {    plotTSNE (  sce_set , ntop =   input $ tsne_ntop , ncomponents =   input $ tsne_ncomponents , exprs_values =   input $ tsne_exprs_values , colour_by =   input $ tsne_colour_by , size_by =   input $ tsne_size_by , shape_by =   input $ tsne_shape_by , scale_features =   input $ tsne_scale_features , rand_seed =   input $ tsne_rand_seed ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotDiffusionMap -   renderPlot (  {    plotDiffusionMap (  sce_set , ntop =   input $ diffmap_ntop , ncomponents =   input $ diffmap_ncomponents , exprs_values =   input $ diffmap_exprs_values , colour_by =   input $ diffmap_colour_by , size_by =   input $ diffmap_size_by , shape_by =   input $ diffmap_shape_by , scale_features =   input $ diffmap_scale_features , rand_seed =   input $ diffmap_rand_seed , distance =   input $ diffmap_distance ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotExpression -   renderPlot (  {    plotExpression (  sce_set , features =   input $ exprs_features , x =   input $ exprs_x , exprs_values =   input $ exprs_exprs_values , colour_by =   input $ exprs_colour_by , size_by =   input $ exprs_size_by , shape_by =   input $ exprs_shape_by , ncol =   input $ exprs_ncols , show_median =   input $ exprs_show_median , show_violin =   input $ exprs_show_violin , show_smooth =   input $ exprs_show_smooth , log2_values =   input $ exprs_log2 ) +   theme ( legend.position =  \"bottom\" ) } )    session $ onSessionEnded (  function ( )  {   stopApp ( ) } ) } , options =   list ( launch.browser =  TRUE ) ) } ",
    "filename": "gui.txt"
  },
  "new_function": {
    "name": "scater_gui",
    "representation": "scater_gui",
    "parameters": "function ( object )",
    "body": "{   pd -   colnames (   colData (  object ) )   pd.plot -   pd [   !   grepl (  \"filter_\" ,  pd ) undefined  !   grepl (  \"is_\" ,  pd ) ]   featurenames -   rownames (  object )   exprs_values -   assayNames (  object )   exprs_values -   exprs_values [  !   grepl (  \"is_exprs\" ,  exprs_values ) ]   shinyApp (   ui -   dashboardPage (   dashboardHeader ( title =  \"scater\" ) ,   dashboardSidebar (   sidebarMenu (   menuItem (  \"plot\" , tabName =  \"plot\" ) ,   menuItem (  \"plotQC\" , tabName =  \"plotQC\" ) ,   menuItem (  \"plotPCA - QC metrics\" , tabName =  \"plotPCA_QC\" ) ,   menuItem (  \"plotPCA - expression\" , tabName =  \"plotPCA\" ) ,   menuItem (  \"plotTSNE\" , tabName =  \"plotTSNE\" ) ,   menuItem (  \"plotDiffusionMap\" , tabName =  \"plotDiffusionMap\" ) ,   menuItem (  \"plotExpression\" , tabName =  \"plotExpression\" ) ) ) ,   dashboardBody (   tabItems (   tabItem ( tabName =  \"plot\" ,   fluidRow (   box (   HTML (  [1311 chars quoted with '\"'] ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plot\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"block1\" ,  \"block1:\" ,  pd.plot , selected =   pd.plot [  2 ] ) ,   selectInput (  \"block2\" ,  \"block2:\" ,  pd.plot , selected =   pd.plot [  3 ] ) ,   selectInput (  \"colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ) ) ) ,   tabItem ( tabName =  \"plotQC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   box (   plotOutput (  \"plotQC\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCtype\" , label =  \"Choose a type of QC plot\" , choices =   c (  \"highest-expression\" ,  \"explanatory-variables\" ,  \"exprs-freq-vs-mean\" ) , selected =  \"highest-expression\" ) , width =  4 ) ) ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ,   box (   plotOutput (  \"plotQCfindpc\" , height =  600 ) , width =  8 ) ,   box (   radioButtons (  \"QCvar\" , label =  \"Choose a variable of interest\" , choices =  pd.plot , selected =  \"total_features\" ) , width =  4 ) ) ) ,   tabItem ( tabName =  \"plotPCA_QC\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA_QC\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   checkboxInput (  \"pcaqc_detect_outliers\" ,  \"detect outliers?\" , value =  TRUE ) ,   selectInput (  \"pcaqc_selected_vars\" ,  \"variables to use for PCA:\" ,  pd.plot , selected =   c (  \"pct_counts_top_100_features\" ,  \"total_features\" ,  \"pct_counts_feature_controls\" ,  \"n_detected_feature_controls\" ,  \"log10_counts_endogenous_features\" ,  \"log10_counts_feature_controls\" ) , multiple =  TRUE ) ,   textInput (  \"pcaqc_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pcaqc_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pcaqc_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   numericInput (  \"pcaqc_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pcaqc_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotPCA\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotPCA\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 , # selectInput(\"pca_colour_by\", \"colour_by (either cell metadata or feature expression):\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"pca_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"pca_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"pca_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"pca_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"pca_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"pca_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"pca_scale_features\" ,  \"scale_features\" , value =  TRUE ) ) ) ) ,   tabItem ( tabName =  \"plotTSNE\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotTSNE\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"tsne_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"tsne_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"tsne_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"tsne_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"tsne_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"tsne_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"tsne_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"tsne_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ) ) ) ,   tabItem ( tabName =  \"plotDiffusionMap\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotDiffusionMap\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   textInput (  \"diffmap_colour_by\" ,  \"colour_by (either cell metadata or feature expression):\" ,   pd.plot [  3 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"diffmap_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"diffmap_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"diffmap_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"diffmap_ntop\" ,  \"number of most variable features to use:\" ,  500 , min =  50 , max =  10000 , step =  25 ) ,   numericInput (  \"diffmap_ncomponents\" ,  \"number of components:\" ,  2 , min =  2 , max =  15 ) ,   checkboxInput (  \"diffmap_scale_features\" ,  \"scale_features\" , value =  TRUE ) ,   numericInput (  \"diffmap_rand_seed\" ,  \"random seed to make plot reproducible:\" ,  5000 ) ,   radioButtons (  \"diffmap_distance\" , label =  \"Choose a distance metric\" , choices =   c (  \"euclidean\" ,  \"cosine\" ,  \"rankcor\" ) , selected =  \"euclidean\" ) ) ) ) ,   tabItem ( tabName =  \"plotExpression\" ,   fluidRow (   box (   HTML (  \" ) , width =  12 , status =  \"success\" ) ) ,   fluidRow (   column ( width =  8 ,   box (   plotOutput (  \"plotExpression\" , height =  700 ) , width =  NULL ) ) ,   column ( width =  4 ,   selectInput (  \"exprs_features\" ,  \"features:\" ,  featurenames , selected =   featurenames [   1 :  6 ] , multiple =  TRUE ) , # selectInput(\"exprs_x\", \"x-axis variable:\", #             pd.plot, #             selected = pd.plot[4]),   textInput (  \"exprs_x\" ,  \"x-axis variable (either cell metadata variable or feature name):\" ,   pd.plot [  4 ] , placeholder =  \"Gene_0082\" ) ,   selectInput (  \"exprs_colour_by\" ,  \"colour_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_shape_by\" ,  \"shape_by:\" ,  pd.plot , selected =   pd.plot [  4 ] ) ,   selectInput (  \"exprs_size_by\" ,  \"size_by:\" ,  pd.plot , selected =   pd.plot [  7 ] ) ,   selectInput (  \"exprs_exprs_values\" ,  \"exprs_values:\" ,  exprs_values , selected =  \"logcounts\" ) ,   numericInput (  \"exprs_ncols\" ,  \"number of columns:\" ,  2 , min =  1 , max =  8 ) ,   checkboxInput (  \"exprs_show_median\" ,  \"show median?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_show_violin\" ,  \"show violin?\" , value =  TRUE ) ,   checkboxInput (  \"exprs_show_smooth\" ,  \"show smoothed fit?\" , value =  FALSE ) ,   checkboxInput (  \"exprs_log2\" ,  \"transform expression values to log2 scale?\" , value =  FALSE ) ) ) ) ) ) ) ,   server -  function ( input , output , session )  {    output $ plot -   renderPlot (  {   plotScater (  object , exprs_values =   input $ exprs_values , block1 =   input $ block1 , block2 =   input $ block2 , colour_by =   input $ colour_by ) } )    output $ plotQC -   renderPlot (  {   plotQC (  object , type =   input $ QCtype ) } )    output $ plotQCfindpc -   renderPlot (  {   plotQC (  object , type =  \"find-pcs\" , variable =   input $ QCvar ) } )    output $ plotPCA_QC -   renderPlot (  {    plotPCA (  object , ncomponents =   input $ pcaqc_ncomponents , pca_data_input =  \"pdata\" , selected_variables =   input $ pcaqc_selected_vars , detect_outliers =   input $ pcaqc_detect_outliers , colour_by =   input $ pcaqc_colour_by , size_by =   input $ pcaqc_size_by , shape_by =   input $ pcaqc_shape_by , scale_features =   input $ pcaqc_scale_features , legend =  \"all\" ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotPCA -   renderPlot (  {    plotPCA (  object , ntop =   input $ pca_ntop , ncomponents =   input $ pca_ncomponents , exprs_values =   input $ pca_exprs_values , colour_by =   input $ pca_colour_by , size_by =   input $ pca_size_by , shape_by =   input $ pca_shape_by , scale_features =   input $ pca_scale_features ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotTSNE -   renderPlot (  {    plotTSNE (  object , ntop =   input $ tsne_ntop , ncomponents =   input $ tsne_ncomponents , exprs_values =   input $ tsne_exprs_values , colour_by =   input $ tsne_colour_by , size_by =   input $ tsne_size_by , shape_by =   input $ tsne_shape_by , scale_features =   input $ tsne_scale_features , rand_seed =   input $ tsne_rand_seed ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotDiffusionMap -   renderPlot (  {    plotDiffusionMap (  object , ntop =   input $ diffmap_ntop , ncomponents =   input $ diffmap_ncomponents , exprs_values =   input $ diffmap_exprs_values , colour_by =   input $ diffmap_colour_by , size_by =   input $ diffmap_size_by , shape_by =   input $ diffmap_shape_by , scale_features =   input $ diffmap_scale_features , rand_seed =   input $ diffmap_rand_seed , distance =   input $ diffmap_distance ) +   theme ( legend.position =  \"bottom\" ) } )    output $ plotExpression -   renderPlot (  {    plotExpression (  object , features =   input $ exprs_features , x =   input $ exprs_x , exprs_values =   input $ exprs_exprs_values , colour_by =   input $ exprs_colour_by , size_by =   input $ exprs_size_by , shape_by =   input $ exprs_shape_by , ncol =   input $ exprs_ncols , show_median =   input $ exprs_show_median , show_violin =   input $ exprs_show_violin , show_smooth =   input $ exprs_show_smooth , log2_values =   input $ exprs_log2 ) +   theme ( legend.position =  \"bottom\" ) } )    session $ onSessionEnded (  function ( )  {   stopApp ( ) } ) } , options =   list ( launch.browser =  TRUE ) ) } ",
    "filename": "gui.txt"
  }
}

1.
{
  "old_function": {
    "name": "plotExpressionDefault",
    "representation": "plotExpressionDefault",
    "parameters": "function ( object , aesth , ncol = 2 , xlab = NULL , ylab = NULL , show_median = FALSE , show_violin = TRUE , show_smooth = FALSE , alpha = 0.6 , size = NULL , scales = \"fixed\" , one_facet = FALSE , se = TRUE , jitter = \"swarm\" )",
    "body": "{  if (  !  (   \"Feature\" %in%   names (  object ) ) )   stop (  \"object needs a column named 'Feature' to define the feature(s) by which to plot expression.\" ) ## use x as group for violin plot if discrete   group_by_x -  (   show_violin undefined  (   !   is.numeric (   object [[   as.character (   aesth $ x ) ] ] ) ||    nlevels (   as.factor (   object [[   as.character (   aesth $ x ) ] ] ) ) =  5 ) )  if (  group_by_x )    aesth $ group -   aesth $ x else    aesth $ group -  1 ## Define the plot  if (  one_facet )  {  if (   is.null (   aesth $ colour ) )    aesth $ colour -   as.symbol (  \"Feature\" )   plot_out -     ggplot (  object ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) } else  {   plot_out -      ggplot (  object ,  aesth ) +   facet_wrap (  ~  Feature , ncol =  ncol , scales =  scales ) +   xlab (  xlab ) +   ylab (  ylab ) } ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) ) ## if x axis variable is not numeric, then jitter points horizontally  if (   is.numeric (   aesth $ x ) )  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) else   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } else  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , size =  size ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , size =  size , position =   position_jitter ( height =  0 ) ) } else  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , position =   position_jitter ( height =  0 ) ) } } ## show optional decorations on plot if desired  if (  show_violin )  {  if (   one_facet undefined  (    aesth $ colour ==   as.symbol (  \"Feature\" ) ) )  {   plot_out -   plot_out +   geom_violin (   aes_string ( fill =  \"Feature\" ) , colour =  \"gray60\" , alpha =  0.2 , scale =  \"width\" )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) , fill =  TRUE ) } else   plot_out -   plot_out +   geom_violin ( colour =  \"gray60\" , alpha =  0.3 , fill =  \"gray80\" , scale =  \"width\" ) }  if (  show_median )  {   plot_out -   plot_out +   stat_summary ( fun.y =  median , fun.ymin =  median , fun.ymax =  median , geom =  \"crossbar\" , width =  0.3 , alpha =  0.8 ) }  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) }  plot_out } ",
    "filename": "plotting.txt"
  },
  "new_function": {
    "name": "plotExpressionDefault",
    "representation": "plotExpressionDefault",
    "parameters": "function ( object , aesth , ncol = 2 , xlab = NULL , ylab = NULL , show_median = FALSE , show_violin = TRUE , show_smooth = FALSE , theme_size = 10 , alpha = 0.6 , size = NULL , scales = \"fixed\" , one_facet = FALSE , se = TRUE , jitter = \"swarm\" )",
    "body": "{  if (  !  (   \"Feature\" %in%   names (  object ) ) )   stop (  \"object needs a column named 'Feature' to define the feature(s) by which to plot expression.\" ) ## use x as group for violin plot if discrete   group_by_x -  (   show_violin undefined  (   !   is.numeric (   object [[   as.character (   aesth $ x ) ] ] ) ||    nlevels (   as.factor (   object [[   as.character (   aesth $ x ) ] ] ) ) =  5 ) )  if (  group_by_x )    aesth $ group -   aesth $ x else    aesth $ group -  1 ## Define the plot  if (  one_facet )  {  if (   is.null (   aesth $ colour ) )    aesth $ colour -   as.symbol (  \"Feature\" )   plot_out -     ggplot (  object ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) } else  {   plot_out -      ggplot (  object ,  aesth ) +   facet_wrap (  ~  Feature , ncol =  ncol , scales =  scales ) +   xlab (  xlab ) +   ylab (  ylab ) } ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) ) ## if x axis variable is not numeric, then jitter points horizontally  if (   is.numeric (   aesth $ x ) )  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) else   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } else  {  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , size =  size , groupOnX =  TRUE ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , size =  size , position =   position_jitter ( height =  0 ) ) } else  {  if (   jitter ==  \"swarm\" )   plot_out -   plot_out +   ggbeeswarm :: geom_quasirandom ( alpha =  alpha , groupOnX =  TRUE ) else   plot_out -   plot_out +   geom_jitter ( alpha =  alpha , position =   position_jitter ( height =  0 ) ) } } ## show optional decorations on plot if desired  if (  show_violin )  {  if (   one_facet undefined  (    aesth $ colour ==   as.symbol (  \"Feature\" ) ) )  {   plot_out -   plot_out +   geom_violin (   aes_string ( fill =  \"Feature\" ) , colour =  \"gray60\" , alpha =  0.2 , scale =  \"width\" )   plot_out -   .resolve_plot_colours (  plot_out ,   object [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) , fill =  TRUE ) } else   plot_out -   plot_out +   geom_violin ( colour =  \"gray60\" , alpha =  0.3 , fill =  \"gray80\" , scale =  \"width\" ) }  if (  show_median )  {   plot_out -   plot_out +   stat_summary ( fun.y =  median , fun.ymin =  median , fun.ymax =  median , geom =  \"crossbar\" , width =  0.3 , alpha =  0.8 ) }  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) } ## Define plotting theme  if (   requireNamespace (  \"cowplot\" , quietly =  TRUE ) )   plot_out -   plot_out +   cowplot :: theme_cowplot (  theme_size ) else   plot_out -   plot_out +   theme_bw (  theme_size )  plot_out } ",
    "filename": "plotting.txt"
  }
}

2.
{
  "old_function": {
    "name": "calculateQCMetrics",
    "representation": "calculateQCMetrics",
    "parameters": "function ( object , feature_controls = NULL , cell_controls = NULL , nmads = 5 , pct_feature_controls_threshold = 80 )",
    "body": "{ ## We must have an SCESet object  if (  !   is (  object ,  \"SCESet\" ) )   stop (  \"object must be an SCESet object.\" ) ## the object must have some samples  if (    ncol (  object ) undefined  1 )   stop (  \"object must have at least one sample (column)\" )  if (    nrow (  object ) undefined  1 )   stop (  \"object must have at least one feature (row)\" ) ## See what versions of the expression data are available in the object   exprs_mat -   exprs (  object )   counts_mat -   counts (  object )   tpm_mat -   tpm (  object )   fpkm_mat -   fpkm (  object ) ## get number of sets of feature controls, and name them  if (   is.null (  feature_controls ) )  {   feature_controls -   list ( ) } else  if (  !   is.list (  feature_controls ) )  {   feature_controls -   list (  feature_controls ) }   n_sets_feature_controls -   length (  feature_controls )   counter -  1L  for  ( i in   seq_len (  n_sets_feature_controls ) )  {   curname -    names (  feature_controls ) [  i ]  if (    is.null (  curname ) ||   curname ==  \"\" )  {     names (  feature_controls ) [  i ] -   paste0 (  \"unnamed\" ,  counter )   counter -   counter +  1L } }    object @ featureControlInfo -   AnnotatedDataFrame (   data.frame ( name =   names (  feature_controls ) , stringsAsFactors =  FALSE ) )  if (  n_sets_feature_controls )  { ## Contributions from technical control features   tech_features -   .process_feature_controls (  object ,  feature_controls ,  pct_feature_controls_threshold ,  exprs_mat ,  counts_mat ,  tpm_mat ,  fpkm_mat )   feature_controls_pdata -   tech_features $ pData   feature_controls_fdata -   tech_features $ fData ## Combine all feature controls   is_feature_control -   apply (  feature_controls_fdata ,  1 ,  any )   feature_controls_fdata -   cbind (  feature_controls_fdata ,  is_feature_control ) } else  {   is_feature_control -   logical (   nrow (  object ) )   feature_controls_fdata -   data.frame (  is_feature_control )   feature_controls_pdata -   data.frame (   matrix (  0 , nrow =   ncol (  object ) , ncol =  0 ) ) }   n_detected_feature_controls -   nexprs (  object , subset_row =  is_feature_control )   df_pdata_this -   data.frame (  n_detected_feature_controls ) ## Compute metrics using all feature controls   okay.expr.vals -   c (  \"counts\" ,  \"cpm\" ,  \"tpm\" ,  \"fpkm\" )  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   df_pdata_current -   .get_qc_metrics_exprs_mat (  cur_mat ,  is_feature_control ,  pct_feature_controls_threshold , calc_top_features =  TRUE , exprs_type =  ex , compute_endog =  TRUE )   df_pdata_this -   cbind (  df_pdata_this ,  df_pdata_current ) }   feature_controls_pdata -   cbind (  feature_controls_pdata ,  df_pdata_this ) ## Compute total_features and find outliers   total_features -   nexprs (  object , subset_row =  !  is_feature_control )   filter_on_total_features -   isOutlier (  total_features ,  nmads , type =  \"lower\" ) ## Compute total_counts if counts are present  if (  !   is.null (  counts_mat ) )  {   total_counts -   colSums (  counts_mat )   filter_on_total_counts -   isOutlier (  total_counts ,  nmads , log =  TRUE ) } else  {   total_counts -   colSums (  exprs_mat )   filter_on_total_counts -   isOutlier (  total_counts ,  nmads , log =  FALSE ) } ## Define counts from endogenous features   qc_pdata -  feature_controls_pdata  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   cur_totals -   switch (  ex , counts =  total_counts ,   colSums (  cur_mat ) )    qc_pdata [[   paste0 (  ex ,  \"_endogenous_features\" ) ] ] -   cur_totals -   feature_controls_pdata [[   paste0 (  ex ,  \"_feature_controls\" ) ] ] } ## Define log10 read counts from feature controls   stat.cols -   sub (  \"_.*\" ,  \"\" ,   colnames (  qc_pdata ) )   cols_to_log -   which (   stat.cols %in%  okay.expr.vals )  if (   length (  cols_to_log ) )  {   log10_cols -   log10 (    qc_pdata [ ,  cols_to_log , drop =  FALSE ] +  1 )    colnames (  log10_cols ) -   paste0 (  \"log10_\" ,    colnames (  qc_pdata ) [  cols_to_log ] ) ## Combine into a big pdata object   qc_pdata -   cbind (  qc_pdata ,  log10_cols ) } ## Define cell controls ### Determine if vector or list  if (    is.null (  cell_controls ) |    length (  cell_controls ) ==  0 )  {   is_cell_control -   rep (  FALSE ,   ncol (  object ) )   cell_controls_pdata -   data.frame (  is_cell_control )   n_sets_cell_controls -  1 } else  {  if (   is.list (  cell_controls ) )  {   cell_controls_list -  cell_controls   n_sets_cell_controls -   length (  cell_controls ) } else  {   cell_controls_list -   list (  cell_controls )   n_sets_cell_controls -  1 }  for  ( i in   seq_len (  n_sets_cell_controls ) )  {   cc_set -   cell_controls_list [[  i ] ]   set_name -    names (  cell_controls_list ) [  i ]  if (   is.logical (  cc_set ) )  {   is_cell_control -  cc_set   cc_set -   which (  cc_set ) } else  {   is_cell_control -   rep (  FALSE ,   ncol (  object ) ) }  if (   is.character (  cc_set ) )   cc_set -   which (    cellNames (  object ) %in%  cc_set )    is_cell_control [  cc_set ] -  TRUE ## Construct data.frame for pData from this feature control set   is_cell_control -   as.data.frame (  is_cell_control )    colnames (  is_cell_control ) -   paste0 (  \"is_cell_control_\" ,  set_name )  if (   i undefined  1L )  {   cell_controls_pdata -   data.frame (  cell_controls_pdata ,  is_cell_control ) } else   cell_controls_pdata -  is_cell_control } } ## Check column names and get cell controls across all sets  if (   n_sets_cell_controls ==  1 )  {    colnames (  cell_controls_pdata ) -  \"is_cell_control\" } else  { ## Combine all cell controls   is_cell_control -   apply (  cell_controls_pdata ,  1 ,  any )   cell_controls_pdata -   cbind (  cell_controls_pdata ,  is_cell_control ) } ## Add cell-level QC metrics to pData   new_pdata -   as.data.frame (   pData (  object ) ) ### Remove columns to be replaced   to_replace -    colnames (  new_pdata ) %in%   c (   colnames (  qc_pdata ) ,   colnames (  cell_controls_pdata ) )   new_pdata -   new_pdata [ ,  !  to_replace , drop =  FALSE ] ### Add new QC metrics  if (  !   is.null (  counts_mat ) )  {    new_pdata $ total_counts -  total_counts    new_pdata $ log10_total_counts -   log10 (  total_counts )    new_pdata $ filter_on_total_counts -  filter_on_total_counts }    new_pdata $ total_features -  total_features    new_pdata $ log10_total_features -   log10 (  total_features )    new_pdata $ filter_on_total_features -  filter_on_total_features    new_pdata $ pct_dropout -   100 *  (   1 -    nexprs (  object , subset_row =  NULL ) /   nrow (  object ) )   new_pdata -   cbind (  new_pdata ,  qc_pdata ,  cell_controls_pdata )    pData (  object ) -   new (  \"AnnotatedDataFrame\" ,  new_pdata ) ## Add feature-level QC metrics to fData   new_fdata -   as.data.frame (   fData (  object ) ) ### Remove columns that are to be replaced   to_replace -    colnames (  new_fdata ) %in%   colnames (  feature_controls_fdata )   new_fdata -   new_fdata [ ,  !  to_replace , drop =  FALSE ] ### Add new QC information    new_fdata $ mean_exprs -   rowMeans (   exprs (  object ) )    new_fdata $ exprs_rank -   rank (   rowMeans (   exprs (  object ) ) )    new_fdata $ n_cells_exprs -   nexprs (  object , byrow =  TRUE )   total_exprs -   sum (  exprs_mat )    new_fdata $ total_feature_exprs -   rowSums (  exprs_mat )    new_fdata $ pct_total_exprs -    100 *   rowSums (  exprs_mat ) /  total_exprs    new_fdata $ pct_dropout -   100 *  (   1 -    new_fdata $ n_cells_exprs /   ncol (  object ) )  for  ( ex in  okay.expr.vals )  {   cur_mat -   switch (  ex , counts =  counts_mat , tpm =  tpm_mat , fpkm =  fpkm_mat )  if (   is.null (  cur_mat ) )  {  next }   cur_totals -   sum (   as.double (   colSums (  cur_mat ) ) ) # avoid integer overflow   cur_feature_totals -   rowSums (  cur_mat )    new_fdata [[   paste0 (  \"total_feature_\" ,  ex ) ] ] -  cur_feature_totals    new_fdata [[   paste0 (  \"log10_total_feature_\" ,  ex ) ] ] -   log10 (   cur_feature_totals +  1 )    new_fdata [[   paste0 (  \"pct_total_\" ,  ex ) ] ] -    100 *  cur_feature_totals /  cur_totals } ## Add new fdata to object   new_fdata -   cbind (  new_fdata ,  feature_controls_fdata )    fData (  object ) -   new (  \"AnnotatedDataFrame\" ,  new_fdata ) ## Ensure sample names are correct and return object    sampleNames (  object ) -   colnames (   exprs (  object ) )  object } ",
    "filename": "qc.txt"
  },
  "new_function": {
    "name": "calculateQCMetrics",
    "representation": "calculateQCMetrics",
    "parameters": "function ( object , exprs_values = \"counts\" , feature_controls = NULL , cell_controls = NULL , nmads = 5 , pct_feature_controls_threshold = 80 )",
    "body": "{  if (  !   methods :: is (  object ,  \"SingleCellExperiment\" ) )   stop (  \"object must be a SingleCellExperiment\" )   exprs_mat -   assay (  object , i =  exprs_values )  if (    exprs_values ==  \"counts\" ||   exprs_values ==  \"cpm\" )  {   linear -  TRUE } else  {   linear -  FALSE } ## Adding general metrics for each cell.   cd -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  NULL , subset_type =  NULL , linear =  TRUE )   rd -   DataFrame ( is_feature_control =   logical (   nrow (  exprs_mat ) ) , row.names =   rownames (  exprs_mat ) ) ## Adding metrics for the technical controls.   n_feature_sets -   length (  feature_controls )  if (  n_feature_sets )  {  if (   is.null (   names (  feature_controls ) ) )  {   stop (  \"feature_controls should be named\" ) } # Converting to integer indices for all applications.   reindexed -   lapply (  feature_controls , FUN =  .subset2index , target =  exprs_mat )   is_fcon -   Reduce (  union ,  reindexed )     rd $ is_feature_control [  is_fcon ] -  TRUE # Adding feature controls.  for  ( f in   seq_len (  n_feature_sets ) )  {   cur.index -   logical (   nrow (  exprs_mat ) )    cur.index [   reindexed [[  f ] ] ] -  TRUE    rd [[   paste0 (  \"is_feature_control_\" ,    names (  reindexed ) [  f ] ) ] ] -  cur.index } # Running through all endogenous genes.   is_endog -   which (  !   rd $ is_feature_control )   cd_endog -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  is_endog , subset_type =  \"endogenous\" , linear =  linear ) # Running through all feature controls.   cd_fcon -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =  is_fcon , subset_type =  \"feature_control\" , linear =  linear ) # Running through each of the feature controls.   cd_per_fcon -   vector (  \"list\" ,  n_feature_sets )  for  ( f in   seq_len (  n_feature_sets ) )  {    cd_per_fcon [[  f ] ] -   .get_qc_metrics_per_cell (  exprs_mat , exprs_type =  exprs_values , subset_row =   reindexed [[  f ] ] , subset_type =    names (  reindexed ) [  f ] , linear =  linear ) }   cd -   do.call (  cbind ,   c (   list (  cd ,  cd_endog ,  cd_fcon ) ,  cd_per_fcon ) ) } ## Define cell controls ### Determine if vector or list   rd_all -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  NULL , subset_type =  NULL , linear =  linear )   rd -   cbind (  rd ,  rd_all )    cd $ is_cell_control -   logical (   ncol (  exprs_mat ) )   n_cell_sets -   length (  cell_controls )  if (  n_cell_sets )  { # Converting indices to integer.   reindexed -   lapply (  cell_controls , FUN =  .subset2index , target =  exprs_mat , byrow =  FALSE )   is_ccon -   Reduce (  union ,  reindexed )     cd $ is_cell_control [  is_ccon ] -  TRUE # Adding sets to the colData.  for  ( cx in   seq_len (  n_cell_sets ) )  {   current_control -   logical (   ncol (  exprs_mat ) )    current_control [   reindexed [[  cx ] ] ] -  TRUE    cd [[   paste0 (  \"is_cell_control_\" ,    names (  reindexed ) [  cx ] ) ] ] -  current_control } # Adding statistics for non-control cells.   is_noncon -   which (  !   cd $ is_cell_control )   rd_noncon -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  is_noncon , subset_type =  \"non_control\" , linear =  linear ) # Adding statistics for all control cells.   rd_con -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =  is_ccon , subset_type =  \"cell_control\" , linear =  linear ) # Adding statistics for each set of control cells.   rd_collected -   vector (  \"list\" ,  n_cell_sets )  for  ( cx in   seq_len (  n_cell_sets ) )  {   rd_current -   .get_qc_metrics_per_gene (  exprs_mat , exprs_type =  exprs_values , subset_col =   reindexed [[  cx ] ] , subset_type =    names (  reindexed ) [  cx ] , linear =  linear )    rd_collected [[  cx ] ] -  rd_current }   rd -   do.call (  cbind ,   c (   list (  rd ,  rd_con ,  rd_noncon ) ,  rd_collected ) ) } ### Remove columns to be replaced   old_rd -   rowData (  object )   old_rd -   old_rd [ ,  !  (    colnames (  old_rd ) %in%   colnames (  rd ) ) , drop =  FALSE ]   rd -   cbind (  old_rd ,  rd )    rowData (  object ) -  rd   old_cd -   colData (  object )   old_cd -   old_cd [ ,  !  (    colnames (  old_cd ) %in%   colnames (  cd ) ) , drop =  FALSE ]   cd -   cbind (  old_cd ,  cd )    colData (  object ) -  cd   return (  object ) } ",
    "filename": "qc.txt"
  }
}



##########
Parameter Default Value Changes
##########

0.
{
  "old_function": {
    "name": "calcIsExprs",
    "representation": "calcIsExprs",
    "parameters": "function ( object , lowerDetectionLimit = NULL , exprs_values = NULL )",
    "body": "{  if (  !   is (  object ,  \"SCESet\" ) )   stop (  \"Object must be an SCESet.\" ) ## Check that args are appropriate   exprs_values -   .exprs_hunter (  object ,  exprs_values )   dat_matrix -   get_exprs (  object ,  exprs_values , warning =  FALSE ) ## Extract lowerDetectionLimit if not provided  if (   is.null (  lowerDetectionLimit ) )   lowerDetectionLimit -   object @ lowerDetectionLimit ## Decide which observations are above detection limit and return matrix   isexprs -   dat_matrix undefined  lowerDetectionLimit    rownames (  isexprs ) -   rownames (  dat_matrix )    colnames (  isexprs ) -   colnames (  dat_matrix )  isexprs } ",
    "filename": "calculate-expression.txt"
  },
  "new_function": {
    "name": "calcIsExprs",
    "representation": "calcIsExprs",
    "parameters": "function ( object , lowerDetectionLimit = 0 , exprs_values = \"counts\" )",
    "body": "{    assay (  object , i =  exprs_values ) undefined  lowerDetectionLimit } ",
    "filename": "calculate-expression.txt"
  }
}

1.
{
  "old_function": {
    "name": "nexprs",
    "representation": "nexprs",
    "parameters": "function ( object , lowerDetectionLimit = NULL , exprs_values = NULL , byrow = FALSE , subset_row = NULL , subset_col = NULL )",
    "body": "{  if (  !   is (  object ,  \"SCESet\" ) )  {   stop (  \"'object' must be a SCESet\" ) }   is_exprs_mat -   is_exprs (  object )   exprs_values -   .exprs_hunter (  object ,  exprs_values )   exprs_mat -   suppressWarnings (   get_exprs (  object ,  exprs_values ) )  if (    is.null (  is_exprs_mat ) undefined   is.null (  exprs_mat ) )  {   stop (   sprintf (  \"either 'is_exprs(object)' or '%s(object)' must be non-NULL\" ,  exprs_values ) ) } # Setting the detection lowerDetectionLimit properly.  if (   is.null (  lowerDetectionLimit ) )  {   lowerDetectionLimit -   object @ lowerDetectionLimit }  if (  !   is.null (  exprs_mat ) )  {    storage.mode (  lowerDetectionLimit ) -   storage.mode (  exprs_mat ) }  if (  !  byrow )  {  if (  !   is.null (  is_exprs_mat ) )  { # Counting expressing genes per cell, using predefined 'is_exprs(object)'.  if (   is.null (  subset_row ) )  {   out -   colSums (  is_exprs_mat ) } else  {   subset_row -   .subset2index (  subset_row ,  is_exprs_mat )   out -   .checkedCall (  cxx_colsum_subset ,  is_exprs_mat ,   subset_row -  1L )    names (  out ) -   colnames (  is_exprs_mat ) } } else  { # Counting expressing genes per cell, using the counts to define 'expressing'.  if (   is.null (  subset_row ) )  {   subset_row -   seq_len (   nrow (  exprs_mat ) ) } else  {   subset_row -   .subset2index (  subset_row ,  exprs_mat ) }   out -   .checkedCall (  cxx_colsum_exprs_subset ,  exprs_mat ,  lowerDetectionLimit ,   subset_row -  1L )    names (  out ) -   colnames (  exprs_mat ) } } else  {  if (  !   is.null (  is_exprs_mat ) )  { # Counting expressing cells per gene, using predefined 'is_exprs(object)'.  if (   is.null (  subset_col ) )  {   out -   rowSums (  is_exprs_mat ) } else  {   subset_col -   .subset2index (  subset_col ,  is_exprs_mat , byrow =  FALSE )   out -   .checkedCall (  cxx_rowsum_subset ,  is_exprs_mat ,   subset_col -  1L )    names (  out ) -   rownames (  is_exprs_mat ) } } else  { # Counting expressing cells per gene, using the counts to define 'expressing'.  if (   is.null (  subset_col ) )  {   subset_col -   seq_len (   ncol (  exprs_mat ) ) } else  {   subset_col -   .subset2index (  subset_col ,  exprs_mat , byrow =  FALSE ) }   out -   .checkedCall (  cxx_rowsum_exprs_subset ,  exprs_mat ,  lowerDetectionLimit ,   subset_col -  1L )    names (  out ) -   rownames (  exprs_mat ) } }   return (  out ) } ",
    "filename": "calculate-expression.txt"
  },
  "new_function": {
    "name": "nexprs",
    "representation": "nexprs",
    "parameters": "function ( object , lowerDetectionLimit = 0 , exprs_values = \"counts\" , byrow = FALSE , subset_row = NULL , subset_col = NULL )",
    "body": "{   exprs_mat -   assay (  object , i =  exprs_values )   subset_row -   .subset2index (  subset_row , target =  exprs_mat , byrow =  TRUE )   subset_col -   .subset2index (  subset_col , target =  exprs_mat , byrow =  FALSE )  if (  !  byrow )  {   margin.stats -   .Call (  cxx_margin_summary ,  exprs_mat ,  lowerDetectionLimit ,   subset_row -  1L ,  FALSE )   return (    margin.stats [[  2 ] ] [  subset_col ] ) } else  {   margin.stats -   .Call (  cxx_margin_summary ,  exprs_mat ,  lowerDetectionLimit ,   subset_col -  1L ,  TRUE )   return (    margin.stats [[  2 ] ] [  subset_row ] ) } } ",
    "filename": "calculate-expression.txt"
  }
}

2.
{
  "old_function": {
    "name": "plotPlatePosition",
    "representation": "plotPlatePosition",
    "parameters": "function ( object , plate_position = NULL , colour_by = NULL , x_position = NULL , y_position = NULL , exprs_values = \"exprs\" , theme_size = 24 , legend = \"auto\" )",
    "body": "{ ## check object is SCESet object  if (  !   is (  object ,  \"SCESet\" ) )   stop (  \"Object must be of class SCESet.\" ) ## check legend argument   legend -   match.arg (  legend ,   c (  \"auto\" ,  \"none\" ,  \"all\" ) ) ## Checking colour validity   colour_by_out -   .choose_vis_values (  object ,  colour_by , cell_control_default =  TRUE , check_features =  TRUE , exprs_values =  exprs_values )   colour_by -   colour_by_out $ name   colour_by_vals -   colour_by_out $ val ## obtain well positions  if (  !   is.null (  plate_position ) )  {  if (    length (  plate_position ) !=   ncol (  object ) )   stop (  \"Supplied plate_position argument must have same length as number of columns of SCESet object.\" )   plate_position_char -  plate_position } else   plate_position_char -   object $ plate_position  if (   is.null (  plate_position_char ) )  {  if (    is.null (  x_position ) ||   is.null (  y_position ) )   stop (  \"If plate_position is NULL then both x_position and y_position must be supplied.\" )   plate_position_x -  x_position   plate_position_y -  y_position } else  {   plate_position_y -   gsub (  \"[0-9]*\" ,  \"\" ,  plate_position_char )   plate_position_y -   factor (  plate_position_y ,   rev (   sort (   unique (  plate_position_y ) ) ) )   plate_position_x -   gsub (  \"[A-Z]*\" ,  \"\" ,  plate_position_char )   plate_position_x -   ordered (   as.integer (  plate_position_x ) ) } ## Define data.frame for plotting   df_to_plot -   data.frame (  plate_position_x ,  plate_position_y )  if (  !   is.null (  plate_position_char ) )    df_to_plot [[  \"plate_position_char\" ] ] -  plate_position_char    df_to_plot $ colour_by -  colour_by_vals ## make the plot   aesth -   aes ( x =  plate_position_x , y =  plate_position_y , fill =  colour_by )  if (  !   is.null (  plate_position_char ) )    aesth $ label -   as.symbol (  \"plate_position_char\" )   plot_out -    ggplot (  df_to_plot ,  aesth ) +   geom_point ( shape =  21 , size =  theme_size , colour =  \"gray50\" )  if (  !   is.null (  plate_position_char ) )   plot_out -   plot_out +   geom_text ( colour =  \"gray90\" ) ## make sure colours are nice   plot_out -   .resolve_plot_colours (  plot_out ,   df_to_plot $ colour_by ,  colour_by , fill =  TRUE ) ## Define plotting theme   plot_out -     plot_out +   theme_bw (  theme_size ) +   theme ( axis.title =   element_blank ( ) , axis.ticks =   element_blank ( ) , legend.text =   element_text ( size =   theme_size /  2 ) , legend.title =   element_text ( size =   theme_size /  2 ) ) +   guides ( fill =   guide_legend ( override.aes =   list ( size =   theme_size /  2 ) ) ) ## remove legend if so desired  if (   legend ==  \"none\" )   plot_out -   plot_out +   theme ( legend.position =  \"none\" ) ## return plot  plot_out } ",
    "filename": "plotting.txt"
  },
  "new_function": {
    "name": "plotPlatePosition",
    "representation": "plotPlatePosition",
    "parameters": "function ( object , plate_position = NULL , colour_by = NULL , x_position = NULL , y_position = NULL , exprs_values = \"logcounts\" , theme_size = 24 , legend = \"auto\" )",
    "body": "{ ## check object is SingleCellExperiment object  if (  !   is (  object ,  \"SingleCellExperiment\" ) )   stop (  \"Object must be of class SingleCellExperiment\" ) ## check legend argument   legend -   match.arg (  legend ,   c (  \"auto\" ,  \"none\" ,  \"all\" ) ) ## Checking colour validity   colour_by_out -   .choose_vis_values (  object ,  colour_by , cell_control_default =  TRUE , check_features =  TRUE , exprs_values =  exprs_values )   colour_by -   colour_by_out $ name   colour_by_vals -   colour_by_out $ val ## obtain well positions  if (  !   is.null (  plate_position ) )  {  if (    length (  plate_position ) !=   ncol (  object ) )   stop (  \"Supplied plate_position argument must have same length as number of columns of SingleCellExperiment object.\" )   plate_position_char -  plate_position } else   plate_position_char -   object $ plate_position  if (   is.null (  plate_position_char ) )  {  if (    is.null (  x_position ) ||   is.null (  y_position ) )   stop (  \"If plate_position is NULL then both x_position and y_position must be supplied.\" )   plate_position_x -  x_position   plate_position_y -  y_position } else  {   plate_position_y -   gsub (  \"[0-9]*\" ,  \"\" ,  plate_position_char )   plate_position_y -   factor (  plate_position_y ,   rev (   sort (   unique (  plate_position_y ) ) ) )   plate_position_x -   gsub (  \"[A-Z]*\" ,  \"\" ,  plate_position_char )   plate_position_x -   ordered (   as.integer (  plate_position_x ) ) } ## Define data.frame for plotting   df_to_plot -   data.frame (  plate_position_x ,  plate_position_y )  if (  !   is.null (  plate_position_char ) )    df_to_plot [[  \"plate_position_char\" ] ] -  plate_position_char    df_to_plot $ colour_by -  colour_by_vals ## make the plot   aesth -   aes ( x =  plate_position_x , y =  plate_position_y , fill =  colour_by )  if (  !   is.null (  plate_position_char ) )    aesth $ label -   as.symbol (  \"plate_position_char\" )   plot_out -    ggplot (  df_to_plot ,  aesth ) +   geom_point ( shape =  21 , size =  theme_size , colour =  \"gray50\" )  if (  !   is.null (  plate_position_char ) )   plot_out -   plot_out +   geom_text ( colour =  \"gray90\" ) ## make sure colours are nice   plot_out -   .resolve_plot_colours (  plot_out ,   df_to_plot $ colour_by ,  colour_by , fill =  TRUE ) ## Define plotting theme   plot_out -     plot_out +   theme_bw (  theme_size ) +   theme ( axis.title =   element_blank ( ) , axis.ticks =   element_blank ( ) , legend.text =   element_text ( size =   theme_size /  2 ) , legend.title =   element_text ( size =   theme_size /  2 ) ) +   guides ( fill =   guide_legend ( override.aes =   list ( size =   theme_size /  2 ) ) ) ## remove legend if so desired  if (   legend ==  \"none\" )   plot_out -   plot_out +   theme ( legend.position =  \"none\" ) ## return plot  plot_out } ",
    "filename": "plotting.txt"
  }
}

3.
{
  "old_function": {
    "name": "plotExprsVsTxLength",
    "representation": "plotExprsVsTxLength",
    "parameters": "function ( object , tx_length = \"median_feat_eff_len\" , exprs_values = \"exprs\" , colour_by = NULL , shape_by = NULL , size_by = NULL , xlab = NULL , show_exprs_sd = FALSE , show_smooth = FALSE , alpha = 0.6 , theme_size = 10 , log2_values = FALSE , size = NULL , se = TRUE )",
    "body": "{ ## Check object is an SCESet object  if (  !   is (  object ,  \"SCESet\" ) )   stop (  \"object must be an SCESet\" )   tx_length_values -   rep (  NA ,   nrow (  object ) ) ## Check arguments are valid  if (    length (  tx_length ) ==  1 )  {  if (   tx_length %in%   Biobase :: fvarLabels (  object ) )   tx_length_values -    fData (  object ) [[  tx_length ] ] else  {  if (   tx_length %in%   names (   Biobase :: assayData (  object ) ) )  {   tx_length_mat -    Biobase :: assayData (  object ) [[  tx_length ] ]   tx_length_values -   matrixStats :: rowMedians (  tx_length_mat ) } else   stop (  \"the argument 'tx_length' should specify a column of fData(object) [see Biobase::fvarLabels(object)] or an element of assayData(object) [see names(assayData(object))\" ) } } else  {  if (    length (  tx_length ) !=   nrow (  object ) )   stop (  \"If tx_length is a vector it must have length equal to nrow(object).\" ) else  {  if (  !   is.numeric (  tx_length ) )   stop (  \"If a vector, tx_length must contain numeric values.\" )   tx_length_values -  tx_length } }   exprs_mat -   get_exprs (  object ,  exprs_values )  if (  log2_values )  {   exprs_mat -   log2 (   exprs_mat +  1 )   ylab -   paste0 (  \"Expression (\" ,  exprs_values ,  \"; log2-scale)\" ) } else   ylab -   paste0 (  \"Expression (\" ,  exprs_values ,  \")\" ) ## compute mean expression and sd of expression values   exprs_mean -   rowMeans (  exprs_mat )   exprs_sd -   matrixStats :: rowSds (  exprs_mat )   df_to_plot -   data.frame (  tx_length_values ,  exprs_mean ,  exprs_sd , ymin =   exprs_mean -  exprs_sd , ymax =   exprs_mean +  exprs_sd ) ## check colour, size, shape arguments   colour_by_out -   .choose_vis_values (  object ,  colour_by , check_pdata =  FALSE )   colour_by -   colour_by_out $ name  if (  !   is.null (  colour_by ) )    df_to_plot [[  colour_by ] ] -   colour_by_out $ val   shape_by_out -   .choose_vis_values (  object ,  shape_by , check_pdata =  FALSE , coerce_factor =  TRUE , level_limit =  10 )   shape_by -   shape_by_out $ name  if (  !   is.null (  shape_by ) )    df_to_plot [[  shape_by ] ] -   shape_by_out $ val   size_by_out -   .choose_vis_values (  object ,  size_by , check_pdata =  FALSE )   size_by -   size_by_out $ name  if (  !   is.null (  size_by ) )    df_to_plot [[  size_by ] ] -   size_by_out $ val ## Construct a ggplot2 aesthetic for the plot   aesth -   aes ( )    aesth $ x -   as.symbol (  \"tx_length_values\" )    aesth $ y -   as.symbol (  \"exprs_mean\" )    aesth $ ymin -   as.symbol (  \"ymin\" )    aesth $ ymax -   as.symbol (  \"ymax\" )  if (  !   is.null (  colour_by ) )    aesth $ colour -   as.symbol (  colour_by )  if (  !   is.null (  shape_by ) )    aesth $ shape -   as.symbol (  shape_by )  if (  !   is.null (  size_by ) )    aesth $ size -   as.symbol (  size_by ) ## Define sensible x-axis label if NULL  if (   is.null (  xlab ) )   xlab -  \"Median transcript length\" ## Make the plot   plot_out -     ggplot2 :: ggplot (  df_to_plot ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   df_to_plot [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) )  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  { ## add SDs  if (  show_exprs_sd )   plot_out -   plot_out +   geom_pointrange ( size =  size , alpha =   0.9 *  alpha ) ## add points to plot   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) } else  { ## add SDs  if (  show_exprs_sd )   plot_out -   plot_out +   geom_pointrange ( alpha =   0.9 *  alpha ) ## add points to plot   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } ## show optional decorations on plot if desired  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) } ## Define plotting theme  if (   requireNamespace (  \"cowplot\" , quietly =  TRUE ) )   plot_out -   plot_out +   cowplot :: theme_cowplot (  theme_size ) else   plot_out -   plot_out +   theme_bw (  theme_size )  plot_out } ",
    "filename": "plotting.txt"
  },
  "new_function": {
    "name": "plotExprsVsTxLength",
    "representation": "plotExprsVsTxLength",
    "parameters": "function ( object , tx_length = \"median_feat_eff_len\" , exprs_values = \"logcounts\" , colour_by = NULL , shape_by = NULL , size_by = NULL , xlab = NULL , show_exprs_sd = FALSE , show_smooth = FALSE , alpha = 0.6 , theme_size = 10 , log2_values = FALSE , size = NULL , se = TRUE )",
    "body": "{ ## Check object is an SingleCellExperiment object  if (  !   is (  object ,  \"SingleCellExperiment\" ) )   stop (  \"object must be an SingleCellExperiment\" )   tx_length_values -   rep (  NA ,   nrow (  object ) ) ## Check arguments are valid  if (    length (  tx_length ) ==  1 )  {  if (   tx_length %in%   colnames (   rowData (  object ) ) )   tx_length_values -    rowData (  object ) [[  tx_length ] ] else  {  if (   tx_length %in%   SummarizedExperiment :: assayNames (  object ) )  {   tx_length_mat -   assay (  object ,  tx_length )   tx_length_values -   matrixStats :: rowMedians (  tx_length_mat ) } else   stop (  \"the argument 'tx_length' should specify a column of rowData(object) or an element of assayNames(object) [see names(assayNames(object))\" ) } } else  {  if (    length (  tx_length ) !=   nrow (  object ) )   stop (  \"If tx_length is a vector it must have length equal to nrow(object).\" ) else  {  if (  !   is.numeric (  tx_length ) )   stop (  \"If a vector, tx_length must contain numeric values.\" )   tx_length_values -  tx_length } }   exprs_mat -   assay (  object ,  exprs_values )  if (  log2_values )  {   exprs_mat -   log2 (   exprs_mat +  1 )   ylab -   paste0 (  \"Expression (\" ,  exprs_values ,  \"; log2-scale)\" ) } else   ylab -   paste0 (  \"Expression (\" ,  exprs_values ,  \")\" ) ## compute mean expression and sd of expression values   exprs_mean -   rowMeans (  exprs_mat )   exprs_sd -   sqrt (   .general_rowVars (  exprs_mat ) )   df_to_plot -   data.frame (  tx_length_values ,  exprs_mean ,  exprs_sd , ymin =   exprs_mean -  exprs_sd , ymax =   exprs_mean +  exprs_sd ) ## check colour, size, shape arguments   colour_by_out -   .choose_vis_values (  object ,  colour_by , check_coldata =  FALSE )   colour_by -   colour_by_out $ name  if (  !   is.null (  colour_by ) )    df_to_plot [[  colour_by ] ] -   colour_by_out $ val   shape_by_out -   .choose_vis_values (  object ,  shape_by , check_coldata =  FALSE , coerce_factor =  TRUE , level_limit =  10 )   shape_by -   shape_by_out $ name  if (  !   is.null (  shape_by ) )    df_to_plot [[  shape_by ] ] -   shape_by_out $ val   size_by_out -   .choose_vis_values (  object ,  size_by , check_coldata =  FALSE )   size_by -   size_by_out $ name  if (  !   is.null (  size_by ) )    df_to_plot [[  size_by ] ] -   size_by_out $ val ## Construct a ggplot2 aesthetic for the plot   aesth -   aes ( )    aesth $ x -   as.symbol (  \"tx_length_values\" )    aesth $ y -   as.symbol (  \"exprs_mean\" )    aesth $ ymin -   as.symbol (  \"ymin\" )    aesth $ ymax -   as.symbol (  \"ymax\" )  if (  !   is.null (  colour_by ) )    aesth $ colour -   as.symbol (  colour_by )  if (  !   is.null (  shape_by ) )    aesth $ shape -   as.symbol (  shape_by )  if (  !   is.null (  size_by ) )    aesth $ size -   as.symbol (  size_by ) ## Define sensible x-axis label if NULL  if (   is.null (  xlab ) )   xlab -  \"Median transcript length\" ## Make the plot   plot_out -     ggplot2 :: ggplot (  df_to_plot ,  aesth ) +   xlab (  xlab ) +   ylab (  ylab ) ## if colour aesthetic is defined, then choose sensible colour palette  if (  !   is.null (   aesth $ colour ) )   plot_out -   .resolve_plot_colours (  plot_out ,   df_to_plot [[   as.character (   aesth $ colour ) ] ] ,   as.character (   aesth $ colour ) )  if (    is.null (   aesth $ size ) undefined  !   is.null (  size ) )  { ## add SDs  if (  show_exprs_sd )   plot_out -   plot_out +   geom_pointrange ( size =  size , alpha =   0.9 *  alpha ) ## add points to plot   plot_out -   plot_out +   geom_point ( size =  size , alpha =  alpha ) } else  { ## add SDs  if (  show_exprs_sd )   plot_out -   plot_out +   geom_pointrange ( alpha =   0.9 *  alpha ) ## add points to plot   plot_out -   plot_out +   geom_point ( alpha =  alpha ) } ## show optional decorations on plot if desired  if (  show_smooth )  {   plot_out -   plot_out +   stat_smooth ( colour =  \"firebrick\" , linetype =  2 , se =  se ) } ## Define plotting theme  if (   requireNamespace (  \"cowplot\" , quietly =  TRUE ) )   plot_out -   plot_out +   cowplot :: theme_cowplot (  theme_size ) else   plot_out -   plot_out +   theme_bw (  theme_size )  plot_out } ",
    "filename": "plotting.txt"
  }
}

4.
{
  "old_function": {
    "name": "findImportantPCs",
    "representation": "findImportantPCs",
    "parameters": "function ( object , variable = \"total_features\" , plot_type = \"pcs-vs-vars\" , exprs_values = \"exprs\" , ntop = 500 , feature_set = NULL , scale_features = TRUE , theme_size = 10 )",
    "body": "{  if (   !   is.null (  feature_set ) undefined    typeof (  feature_set ) ==  \"character\" )  {  if (  !  (   all (   feature_set %in%   featureNames (  object ) ) ) )   stop (  \"when the argument 'feature_set' is of type character, all features must be in featureNames(object)\" ) }   df_for_pca -   get_exprs (  object ,  exprs_values )  if (   is.null (  df_for_pca ) )   stop (  \"The supplied 'exprs_values' argument not found in assayData(object). Try 'exprs' or similar.\" )  if (   is.null (  feature_set ) )  {   rv -   matrixStats :: rowVars (  df_for_pca )   feature_set -    order (  rv , decreasing =  TRUE ) [   seq_len (   min (  ntop ,   length (  rv ) ) ) ] }   df_for_pca -   df_for_pca [  feature_set , ]   df_for_pca -   t (  df_for_pca ) ## Drop any features with zero variance   keep_feature -  (    matrixStats :: colVars (  df_for_pca ) undefined  0.001 )    keep_feature [   is.na (  keep_feature ) ] -  FALSE   df_for_pca -   df_for_pca [ ,  keep_feature ] ## compute PCA   pca -   prcomp (  df_for_pca , retx =  TRUE , center =  TRUE , scale. =  scale_features )    colnames (   pca $ x ) -   paste (  \"component\" ,   1 :   ncol (   pca $ x ) )  if (  !  (   variable %in%   colnames (   pData (  object ) ) ) )   stop (  \"variable not found in pData(object).\r\n             Please make sure pData(object)[, variable] exists.\" )   x -    pData (  object ) [ ,  variable ]   x_na -   is.na (  x )   x -   x [  !  x_na ]  if (    length (   unique (  x ) ) =  1 )   stop (  \"variable only has one unique value, so cannot determine important\r\n             principal components.\" ) ## Determine type of variable   typeof_x -   .getTypeOfVariable (  object ,  variable )  if (   typeof_x ==  \"discrete\" )  { ## If x is a discrete variable   x_int -   as.factor (  x ) ## Compute R-squared for each PC   design -   model.matrix (  ~  x_int ) } else  { ## If x is a continuous variable - use as a continuous variable   design -   model.matrix (  ~  x ) } ## Get R-squared for each PC for the variable of interest   pca_r_squared -   .getRSquared (   t (    pca $ x [  !  x_na , ] ) ,  design ) ## Tidy up names and choose top 5 most important PCs for the variable # names(ave_sil_width)    names (  pca_r_squared ) -   colnames (   pca $ x )    colnames (   pca $ x ) -   paste0 (   colnames (   pca $ x ) ,  \"\\n(R-squared \" ,   formatC (   signif (  pca_r_squared , digits =  2 ) , digits =  2 , format =  \"fg\" , flag =  \"#\" ) ,  \")\" )   top5 -    order (  pca_r_squared , decreasing =  TRUE ) [   1 :  5 ]  if (   plot_type ==  \"pairs-pcs\" )  { ## Define colours for points   colour_by -    pData (  object ) [ ,  variable ] ## Generate a larger data.frame for pairs plot   df_to_expand -    pca $ x [ ,  top5 ] #         colnames(df_to_expand) #         rownames(df_to_expand)    names (  df_to_expand ) -   colnames (  df_to_expand )   gg1 -   .makePairs (  df_to_expand ) ## new data frame   df_to_plot_big -   data.frame (   gg1 $ all ,  colour_by ) # colnames(df_to_plot_big)[-c(1:4)] ## pairs plot   plot_out -         ggplot (  df_to_plot_big ,   aes_string ( x =  \"x\" , y =  \"y\" ) ) +   geom_point (   aes_string ( fill =  \"colour_by\" ) , colour =  \"gray40\" , shape =  21 , alpha =  0.65 ) +   facet_grid (   xvar ~  yvar , scales =  \"free\" ) +   stat_density (   aes_string ( x =  \"x\" , y =  \"(..scaled.. * diff(range(x)) + min(x))\" ) , data =   gg1 $ densities , position =  \"identity\" , colour =  \"grey20\" , geom =  \"line\" ) +   xlab (  \"\" ) +   ylab (  \"\" ) +   theme_bw (  theme_size )   plot_out -   .resolve_plot_colours (  plot_out ,  colour_by ,   get (  \"variable\" ) , fill =  TRUE )   return (  plot_out ) } else  {   top6 -    order (  pca_r_squared , decreasing =  TRUE ) [   1 :  6 ]   df_to_plot -   reshape2 :: melt (    pca $ x [ ,  top6 ] )   xvar -    pData (  object ) [ ,  variable ]    df_to_plot $ xvar -   rep (  xvar ,  6 )   pcs_vars_plot -       ggplot (  df_to_plot ,   aes_string ( x =  \"xvar\" , y =  \"value\" ) , colour =  \"black\" ) +   facet_wrap (  ~  Var2 , nrow =  3 , scales =  \"free_y\" ) +   xlab (  variable ) +   ylab (  \"Principal component value\" ) +   theme_bw (  theme_size )  if (   typeof_x ==  \"discrete\" )  {   pcs_vars_plot -    pcs_vars_plot +   geom_violin ( fill =  \"aliceblue\" , colour =  \"gray60\" , alpha =  0.6 , scale =  \"width\" ) +   geom_boxplot ( width =  0.25 , outlier.size =  0 )  if (    ncol (  object ) =  150 )  {   pcs_vars_plot -   pcs_vars_plot +   geom_dotplot ( fill =  \"gray10\" , alpha =  0.6 , binaxis =  'y' , stackdir =  'center' , dotsize =  1 ) } } else  {   pcs_vars_plot -    pcs_vars_plot +   geom_point ( fill =  \"gray10\" , alpha =  0.6 , shape =  21 ) +   stat_smooth (   aes ( group =  1 ) , method =  \"lm\" , alpha =  0.3 ) }   return (  pcs_vars_plot ) } } ",
    "filename": "qc.txt"
  },
  "new_function": {
    "name": "findImportantPCs",
    "representation": "findImportantPCs",
    "parameters": "function ( object , variable = \"total_features\" , plot_type = \"pcs-vs-vars\" , exprs_values = \"logcounts\" , ntop = 500 , feature_set = NULL , scale_features = TRUE , theme_size = 10 )",
    "body": "{  if (   !   is.null (  feature_set ) undefined    typeof (  feature_set ) ==  \"character\" )  {  if (  !  (   all (   feature_set %in%   rownames (  object ) ) ) )   stop (  \"when the argument 'feature_set' is of type character, all features must be in rownames(object)\" ) }   df_for_pca -   assay (  object ,  exprs_values )  if (   is.null (  df_for_pca ) )   stop (  \"The supplied 'exprs_values' argument not found in assayData(object). Try 'exprs' or similar.\" )  if (   is.null (  feature_set ) )  {   rv -   matrixStats :: rowVars (  df_for_pca )   feature_set -    order (  rv , decreasing =  TRUE ) [   seq_len (   min (  ntop ,   length (  rv ) ) ) ] }   df_for_pca -   df_for_pca [  feature_set , ]   df_for_pca -   t (  df_for_pca ) ## Drop any features with zero variance   keep_feature -  (    matrixStats :: colVars (  df_for_pca ) undefined  0.001 )    keep_feature [   is.na (  keep_feature ) ] -  FALSE   df_for_pca -   df_for_pca [ ,  keep_feature ] ## compute PCA   pca -   prcomp (  df_for_pca , retx =  TRUE , center =  TRUE , scale. =  scale_features )    colnames (   pca $ x ) -   paste (  \"component\" ,   1 :   ncol (   pca $ x ) )  if (  !  (   variable %in%   colnames (   colData (  object ) ) ) )   stop (  \"variable not found in colData(object).\r\n             Please make sure colData(object)[, variable] exists.\" )   x -    colData (  object ) [ ,  variable ]   x_na -   is.na (  x )   x -   x [  !  x_na ]  if (    length (   unique (  x ) ) =  1 )   stop (  \"variable only has one unique value, so cannot determine important\r\n             principal components.\" ) ## Determine type of variable   typeof_x -   .getTypeOfVariable (  object ,  variable )  if (   typeof_x ==  \"discrete\" )  { ## If x is a discrete variable   x_int -   as.factor (  x ) ## Compute R-squared for each PC   design -   model.matrix (  ~  x_int ) } else  { ## If x is a continuous variable - use as a continuous variable   design -   model.matrix (  ~  x ) } ## Get R-squared for each PC for the variable of interest   pca_r_squared -   .getRSquared (   t (    pca $ x [  !  x_na , ] ) ,  design ) ## Tidy up names and choose top 5 most important PCs for the variable # names(ave_sil_width)    names (  pca_r_squared ) -   colnames (   pca $ x )    colnames (   pca $ x ) -   paste0 (   colnames (   pca $ x ) ,  \"\\n(R-squared \" ,   formatC (   signif (  pca_r_squared , digits =  2 ) , digits =  2 , format =  \"fg\" , flag =  \"#\" ) ,  \")\" )   top5 -    order (  pca_r_squared , decreasing =  TRUE ) [   1 :  5 ]  if (   plot_type ==  \"pairs-pcs\" )  { ## Define colours for points   colour_by -    colData (  object ) [ ,  variable ] ## Generate a larger data.frame for pairs plot   df_to_expand -    pca $ x [ ,  top5 ] #         colnames(df_to_expand) #         rownames(df_to_expand)    names (  df_to_expand ) -   colnames (  df_to_expand )   gg1 -   .makePairs (  df_to_expand ) ## new data frame   df_to_plot_big -   data.frame (   gg1 $ all ,  colour_by ) # colnames(df_to_plot_big)[-c(1:4)] ## pairs plot   plot_out -         ggplot (  df_to_plot_big ,   aes_string ( x =  \"x\" , y =  \"y\" ) ) +   geom_point (   aes_string ( fill =  \"colour_by\" ) , colour =  \"gray40\" , shape =  21 , alpha =  0.65 ) +   facet_grid (   xvar ~  yvar , scales =  \"free\" ) +   stat_density (   aes_string ( x =  \"x\" , y =  \"(..scaled.. * diff(range(x)) + min(x))\" ) , data =   gg1 $ densities , position =  \"identity\" , colour =  \"grey20\" , geom =  \"line\" ) +   xlab (  \"\" ) +   ylab (  \"\" ) +   theme_bw (  theme_size )   plot_out -   .resolve_plot_colours (  plot_out ,  colour_by ,   get (  \"variable\" ) , fill =  TRUE )   return (  plot_out ) } else  {   top6 -    order (  pca_r_squared , decreasing =  TRUE ) [   1 :  6 ]   df_to_plot -   reshape2 :: melt (    pca $ x [ ,  top6 ] )   xvar -    colData (  object ) [ ,  variable ]    df_to_plot $ xvar -   rep (  xvar ,  6 )   pcs_vars_plot -       ggplot (  df_to_plot ,   aes_string ( x =  \"xvar\" , y =  \"value\" ) , colour =  \"black\" ) +   facet_wrap (  ~  Var2 , nrow =  3 , scales =  \"free_y\" ) +   xlab (  variable ) +   ylab (  \"Principal component value\" ) +   theme_bw (  theme_size )  if (   typeof_x ==  \"discrete\" )  {   pcs_vars_plot -    pcs_vars_plot +   geom_violin ( fill =  \"aliceblue\" , colour =  \"gray60\" , alpha =  0.6 , scale =  \"width\" ) +   geom_boxplot ( width =  0.25 , outlier.size =  0 )  if (    ncol (  object ) =  150 )  {   pcs_vars_plot -   pcs_vars_plot +   geom_dotplot ( fill =  \"gray10\" , alpha =  0.6 , binaxis =  'y' , stackdir =  'center' , dotsize =  1 ) } } else  {   pcs_vars_plot -    pcs_vars_plot +   geom_point ( fill =  \"gray10\" , alpha =  0.6 , shape =  21 ) +   stat_smooth (   aes ( group =  1 ) , method =  \"lm\" , alpha =  0.3 ) }   return (  pcs_vars_plot ) } } ",
    "filename": "qc.txt"
  }
}



##########
Overall Changes
##########

